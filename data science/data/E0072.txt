ID=E0072
URL=http://www.gotw.ca/gotw/062.htm
SIZE=58656
DATE=12/07/02
TIME=19:17:10
DATASET=C
HTML=
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta http-equiv="Content-Language" content="en-us">


<title>GotW #62: Smart Pointer Members</title>
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<link rel="stylesheet" type="text/css" href="../gotw.css">
<meta name="Microsoft Theme" content="gotw 111, default">
<meta name="Microsoft Border" content="tlb, default">
</head>

<body background="../_themes/gotw/glabkgnd.jpg" bgcolor="#CCFFFF" text="#000000" link="#008080" vlink="#008080" alink="#0000FF"  ><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font><table border="0" cellspacing="0" width="100%">
  <tr>
    <td colspan="2"><!--mstheme--><font face="Arial, Arial, Helvetica"><font size="6"><strong>
    GotW #62</strong></font> <!--mstheme--></font></td>
  </tr>
  <tr>
    <td valign="middle"><!--mstheme--><font face="Arial, Arial, Helvetica">




<p align="left" style="margin-top: 0; margin-bottom: 0">

<script language="JavaScript"><!--
MSFPhover = 
  (((navigator.appName == "Netscape") && 
  (parseInt(navigator.appVersion) >= 3 )) || 
  ((navigator.appName == "Microsoft Internet Explorer") && 
  (parseInt(navigator.appVersion) >= 4 ))); 
function MSFPpreload(img) 
{
  var a=new Image(); a.src=img; return a; 
}
// --></script><script language="JavaScript"><!--
if(MSFPhover) { MSFPnav1n=MSFPpreload("../_derived/home_cmp_gotw110_hbtn.gif"); MSFPnav1h=MSFPpreload("../_derived/home_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav1'].src=MSFPnav1h.src" onmouseout="if(MSFPhover) document['MSFPnav1'].src=MSFPnav1n.src"><img src="../_derived/home_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Home" align="middle" name="MSFPnav1"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav2n=MSFPpreload("../_derived/news.htm_cmp_gotw110_hbtn.gif"); MSFPnav2h=MSFPpreload("../_derived/news.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../news.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav2'].src=MSFPnav2h.src" onmouseout="if(MSFPhover) document['MSFPnav2'].src=MSFPnav2n.src"><img src="../_derived/news.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="News &amp; Events" align="middle" name="MSFPnav2"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav3n=MSFPpreload("../resources/_derived/index.htm_cmp_gotw110_hbtn.gif"); MSFPnav3h=MSFPpreload("../resources/_derived/index.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../resources/index.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav3'].src=MSFPnav3h.src" onmouseout="if(MSFPhover) document['MSFPnav3'].src=MSFPnav3n.src"><img src="../resources/_derived/index.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Community Resources" align="middle" name="MSFPnav3"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav4n=MSFPpreload("../_derived/consulting.htm_cmp_gotw110_hbtn.gif"); MSFPnav4h=MSFPpreload("../_derived/consulting.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../consulting.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav4'].src=MSFPnav4h.src" onmouseout="if(MSFPhover) document['MSFPnav4'].src=MSFPnav4n.src"><img src="../_derived/consulting.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Consulting Services" align="middle" name="MSFPnav4"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav5n=MSFPpreload("../_derived/presentations.htm_cmp_gotw110_hbtn.gif"); MSFPnav5h=MSFPpreload("../_derived/presentations.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../presentations.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav5'].src=MSFPnav5h.src" onmouseout="if(MSFPhover) document['MSFPnav5'].src=MSFPnav5n.src"><img src="../_derived/presentations.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Presentations" align="middle" name="MSFPnav5"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav6n=MSFPpreload("../publications/_derived/index.htm_cmp_gotw110_hbtn.gif"); MSFPnav6h=MSFPpreload("../publications/_derived/index.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../publications/index.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav6'].src=MSFPnav6h.src" onmouseout="if(MSFPhover) document['MSFPnav6'].src=MSFPnav6n.src"><img src="../publications/_derived/index.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Publications" align="middle" name="MSFPnav6"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav7n=MSFPpreload("_derived/index.htm_cmp_gotw110_hbtn.gif"); MSFPnav7h=MSFPpreload("_derived/index.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="index.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav7'].src=MSFPnav7h.src" onmouseout="if(MSFPhover) document['MSFPnav7'].src=MSFPnav7n.src"><img src="_derived/index.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Guru of the Week" align="middle" name="MSFPnav7"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav8n=MSFPpreload("../conv/_derived/index.htm_cmp_gotw110_hbtn.gif"); MSFPnav8h=MSFPpreload("../conv/_derived/index.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../conv/index.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav8'].src=MSFPnav8h.src" onmouseout="if(MSFPhover) document['MSFPnav8'].src=MSFPnav8n.src"><img src="../conv/_derived/index.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Conversations" align="middle" name="MSFPnav8"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav9n=MSFPpreload("../_derived/search.htm_cmp_gotw110_hbtn.gif"); MSFPnav9h=MSFPpreload("../_derived/search.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../search.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav9'].src=MSFPnav9h.src" onmouseout="if(MSFPhover) document['MSFPnav9'].src=MSFPnav9n.src"><img src="../_derived/search.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Search GotW.ca" align="middle" name="MSFPnav9"></a>
</p>




    <!--mstheme--></font></td>
    <td valign="middle"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 0; margin-bottom: 0">
      <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav10n=MSFPpreload("../_derived/back_cmp_gotw110_back.gif"); MSFPnav10h=MSFPpreload("../_derived/back_cmp_gotw110_back_a.gif"); }
// --></script><a href="061.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav10'].src=MSFPnav10h.src" onmouseout="if(MSFPhover) document['MSFPnav10'].src=MSFPnav10n.src"><img src="../_derived/back_cmp_gotw110_back.gif" width="100" height="20" border="0" alt="Prev" name="MSFPnav10"></a><br><script language="JavaScript"><!--
if(MSFPhover) { MSFPnav11n=MSFPpreload("../_derived/up_cmp_gotw110_up.gif"); MSFPnav11h=MSFPpreload("../_derived/up_cmp_gotw110_up_a.gif"); }
// --></script><a href="index.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav11'].src=MSFPnav11h.src" onmouseout="if(MSFPhover) document['MSFPnav11'].src=MSFPnav11n.src"><img src="../_derived/up_cmp_gotw110_up.gif" width="100" height="20" border="0" alt="Up" name="MSFPnav11"></a><br><script language="JavaScript"><!--
if(MSFPhover) { MSFPnav12n=MSFPpreload("../_derived/next_cmp_gotw110_next.gif"); MSFPnav12h=MSFPpreload("../_derived/next_cmp_gotw110_next_a.gif"); }
// --></script><a href="063.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav12'].src=MSFPnav12h.src" onmouseout="if(MSFPhover) document['MSFPnav12'].src=MSFPnav12n.src"><img src="../_derived/next_cmp_gotw110_next.gif" width="100" height="20" border="0" alt="Next" name="MSFPnav12"></a><!--mstheme--></font></td>
  </tr>
  <tr>
    <td height="5" background="../images/bar.gif" colspan="2"><!--mstheme--><font face="Arial, Arial, Helvetica">&nbsp;<!--mstheme--></font></td>
  </tr>
</table><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font></td></tr><!--msnavigation--></table><!--msnavigation--><table dir="ltr" border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td valign="top" width="1%"><!--mstheme--><font face="Arial, Arial, Helvetica">

<!--mstheme--></font><table border="0" cellspacing="0" bgcolor="#000000" cellpadding="0">
  <tr>
    <td><!--mstheme--><font face="Arial, Arial, Helvetica">
    <!--mstheme--></font><table border="0" cellpadding="2" cellspacing="1" width="100%" height="483">
        <tr>
          <td align="center" bgcolor="#000000" colspan="2" height="16"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin-top: 0; margin-bottom: 0"><a href="../news.htm"><b><font color="#FFFF00">News</font></b></a><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="center" bgcolor="#CCCCCC" bordercolor="#CCCCCC" rowspan="3"><!--mstheme--><font face="Arial, Arial, Helvetica">
          <font size="1" color="#0000FF">J<br>
          U<br>
          L<br>
          Y</font><!--mstheme--></font></td>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin-left: 3; margin-right: 3; margin-top: 0" align="center"><font size="1" color="#0000FF">
            Print articles newly available online</font><!--mstheme--></font><table border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%" id="AutoNumber1" bgcolor="#FFFFCC" bordercolordark="#006666" bordercolorlight="#99CCCC">
              <tr>
                <td width="100%" bordercolor="#808000"><!--mstheme--><font face="Arial, Arial, Helvetica">
                <p style="margin: 3"><font size="1" color="#0000FF">
                <a href="../publications/mill20.htm"><b><i>
                <font color="#0000FF">Sutter's Mill</font></i></b><font color="#0000FF"> 
                column, &quot;Toward a Standard C++ Library, Part 1&quot;</font></a></font><!--mstheme--></font></td>
              </tr>
              <tr>
                <td width="100%" bordercolor="#808000" bgcolor="#FFFFCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
                <p style="margin: 3"><font size="1" color="#0000FF">
                <a href="../publications/mxc++-item-4.htm">
                <font color="#0000FF">Excerpt from MXC++, &quot;Extensible Templates: 
                Via Inheritance or Traits?&quot;</font></a></font><!--mstheme--></font></td>
              </tr>
              <tr>
                <td width="100%" bordercolor="#808000"><!--mstheme--><font face="Arial, Arial, Helvetica">
                <p style="margin: 3"><font size="1" color="#0000FF">
                <a href="../publications/mcd_review.htm"><font color="#0000FF">
                Book Review: Modern C++ Design</font></a></font><!--mstheme--></font></td>
              </tr>
              <tr>
                <td width="100%" bordercolor="#808000"><!--mstheme--><font face="Arial, Arial, Helvetica">
                <p style="margin: 3"><font size="1" color="#0000FF">
                <a href="../publications/mill21.htm"><b><i>
                <font color="#0000FF">Sutter's Mill</font></i></b><font color="#0000FF"> 
                column, &quot;Toward a Standard C++ Library, Part 2: Namespaceops and 
                Library Versioning&quot;</font></a></font><!--mstheme--></font></td>
              </tr>
            </table><!--mstheme--><font face="Arial, Arial, Helvetica">
          <!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin: 0 3"><font size="1" color="#0000FF"><b><i>Sutter's 
            Mill</i></b> column,
            &quot;A Pragmatic Look at Exception Specifications&quot;<br>
            </font><font size="1" color="#000080">The usefulness, or lack 
            thereof, of exception specifications, and how results can vary 
            across real-world compilers</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin: 0 3">
            <a target="_blank" href="http://www.cuj.com/experts/2007/hyslop.htm"><font size="1" color="#0000FF"><i><b>Conversations</b></i> column,
            &quot;Getting to the Point&quot;</font></a><font color="#0000FF" size="1"><br>
            </font><font size="1" color="#000080">The Boost library has five 
            smart pointers that provide a rich array [sic] of useful behaviors.</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="center" bgcolor="#CCCCCC" bordercolor="#CCCCCC" rowspan="2"><!--mstheme--><font face="Arial, Arial, Helvetica"><font color="#0000FF" size="1">A<br>
            U<br>
          G<br>
          U<br>
          S<br>
          T</font><!--mstheme--></font></td>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin:0 3; ">
            <a target="_blank" href="http://www.cuj.com/experts/2008/sutter.htm"><i><b><font size="1" color="#0000FF">The New C++</font></b></i> <font size="1" color="#0000FF">
            column, &quot;Smart(er) Pointers&quot;</font></a><font size="1" color="#000080"><br>
            A closer look at one of the proposed new standard C++ library 
            features -- smart pointers, particularly those in Boost and Loki, 
            and a sneak peek at the usefulness of the proposed typedef templates</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
          <p style="margin:0 3; ">
          <a target="_blank" href="http://www.cuj.com/experts/2008/hyslop.htm"><font size="1" color="#0000FF"><i><b>Conversations</b></i> column,
            &quot;A Midsummer Night's Madness&quot;</font></a><font color="#0000FF" size="1"><br>
            </font><font size="1" color="#000080">A brew that mixes pointers, 
          typedefs, and const</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="center" bgcolor="#CCCCCC" bordercolor="#CCCCCC" rowspan="3"><!--mstheme--><font face="Arial, Arial, Helvetica">
          <p style="margin-top: 0; margin-bottom: 0">
          <font size="1" color="#0000FF">S<br>
          E<br>
          P<br>
          T<br>
          E<br>
          M<br>
          B<br>
          E<br>
          R</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin: 0 3">
            <font size="1" color="#0000FF">&quot;Standard C++ Meets Managed C++&quot;<br>
            </font><font size="1" color="#000080">A survey of the main (in)compatibilities 
            between Standard C++ and Microsoft’s managed extensions for C++, and 
            how the two could converge</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin: 0 3"><font size="1" color="#0000FF"><b><i>Sutter's 
            Mill</i></b> column,
            &quot;Export Restrictions, Part 1&quot;<br>
            </font><font size="1" color="#000080">The scoop on export -- what 
            some people think it does, what it actually does, and why it’s the 
            most widely-ignored feature in the C++ standard</font><!--mstheme--></font></td>
        </tr>
      </table><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font></td>
  </tr>
</table><!--mstheme--><font face="Arial, Arial, Helvetica">
<p style="margin-top: 0; margin-bottom: 0">
<img border="0" src="../images/140.gif" width="140" height="1"></p>

<!--mstheme--></font></td><td valign="top" width="24"></td><!--msnavigation--><td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
<!--mstheme--></font><table border="1" cellpadding="6" cellspacing="0" width="100%" bgcolor="#CCCCFF" bordercolordark="#006666" bordercolorlight="#99CCCC">
  <tr>
    <td width="100%"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p align="center">This is the original GotW problem and solution
      substantially as posted to Usenet. See the book <i><a href="../publications/mxc++.htm"><b>More
      Exceptional C++</b></a></i> (Addison-Wesley, 2002) for the most current
      solution to this GotW issue. The solutions in the book have been revised
      and expanded since their initial appearance in GotW. The book versions
      also incorporate corrections, new material, and conformance to the final
      ANSI/ISO C++ standard.</p>
    <!--mstheme--></font></td>
  </tr>
</table><!--mstheme--><font face="Arial, Arial, Helvetica">
      <h2><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Smart Pointer Members&nbsp;<font size="3"><br>
      Difficulty: 6 / 10</font><!--mstheme--></font></h2>
<p><i>Most C++ programmers know they have to take special care for classes with pointer
members. But what about classes with auto_ptr members? And can we make life
safer for ourselves and our users by devising a smart pointer class designed
specifically for class membership?</i></p>
<p align="center"><img border="0" src="../images/h-line.gif" width="248" height="2"></p>

<h3><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Problem<!--mstheme--></font></h3>

<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">JG Question<!--mstheme--></font></h4>
<p><b><font size="4">1.</font></b>   Consider the following class:</p>
<blockquote>
<p><font face="Courier New">// Example 1<br>
//<br>
class X1<br>
{<br>
&nbsp; // ...<br>
private:<br>
&nbsp; Y* y_;<br>
};</font></p>
</blockquote>
<p>If an X1 object owns its pointed-at Y object, why can't the author of X use
the compiler-generated destructor, copy constructor, and copy assignment?</p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Guru Questions<!--mstheme--></font></h4>
<p><b><font size="4">2.</font></b>   What are the advantages and drawbacks of
the following approach?</p>
<blockquote>
<p><font face="Courier New">// Example 2<br>
//<br>
class X2<br>
{<br>
&nbsp; // ...<br>
private:<br>
&nbsp; auto_ptr&lt;Y&gt; y_;<br>
};</font></p>
</blockquote>
<p><b><font size="4">3.</font></b>   Write a suitable HolderPtr template that is
used as shown here:</p>
<blockquote>
<p><font face="Courier New">// Example 3<br>
//<br>
class X3<br>
{<br>
&nbsp; // ...<br>
private:<br>
&nbsp; HolderPtr&lt;Y&gt; y_;<br>
};</font></p>
</blockquote>
<p>to suit three specific circumstances:</p>
<blockquote>
  <p>a) Copying and assigning HolderPtrs is not allowed.</p>
  <p>b) Copying and assigning HolderPtrs is allowed, and has the semantics of
  creating a copy of the owned Y object using the Y copy constructor.</p>
  <p>c) Copying and assigning HolderPtrs is allowed, and has the semantics of
  creating a copy of the owned Y object, which is performed using a virtual
  Y::Clone() method if present and the Y copy constructor otherwise.</p>
</blockquote>
<p align="center"><img border="0" src="../images/h-line.gif" width="248" height="2"></p>
<h3><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666"><a name="Solution"></a>Solution<!--mstheme--></font></h3>

<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Recap: Problems of Pointer Members<!--mstheme--></font></h4>

<p><font color="#999933"><b><font size="4">1.</font></b>   Consider the
following class:</font></p>
<blockquote>
<p><font face="Courier New" color="#999933">// Example 1<br>
//<br>
class X1<br>
{<br>
&nbsp; // ...<br>
private:<br>
&nbsp; Y* y_;<br>
};</font></p>
</blockquote>

<p>If X1 owns its pointed-at Y, the compiler-generated versions will do the
wrong thing. First, note that some function (probably a constructor) has to
create the owned Y object, and there has to be another function (likely the
destructor, X1::~X1()) that deletes it:</p>

<blockquote>
  <p><font face="Courier New">// Example 1(a): Ownership semantics.<br>
  //<br>
  {<br>
  &nbsp; X1 a; // allocates a new Y object and points at it<br>
  <br>
  &nbsp; // ...<br>
  <br>
  } // as a goes out of scope and is destroyed, it<br>
  &nbsp; // deletes the pointed-at Y</font></p>
</blockquote>

<p>Then use of the default memberwise copy construction will cause multiple X1
objects to point at the same Y object, which will cause strange results as
modifying one X1 object changes the state of another, and which will also cause
a double delete to take place:</p>

<blockquote>
  <p><font face="Courier New">// Example 1(b): Sharing, and double delete.<br>
  //<br>
  {<br>
  &nbsp; X1 a;&nbsp;&nbsp; // allocates a new Y object and points at it<br>
  <br>
  &nbsp; X1 b( a ); // b now points at the same Y object as a<br>
  <br>
  &nbsp; // ... manipulating a and b modifies<br>
  &nbsp; // the same Y object ...<br>
  <br>
  } // as b goes out of scope and is destroyed, it<br>
  &nbsp; // deletes the pointed-at Y... and so does a, oops</font></p>
</blockquote>

<p>And use of the default memberwise copy assignment will also cause multiple X1
objects to point at the same Y object, which will cause the same state sharing,
the same double delete, and as an added bonus will also cause leaks when some
objects are never deleted at all:</p>

<blockquote>
  <p><font face="Courier New">// Example 1(c): Sharing, double delete, plus
  leak.<br>
  //<br>
  {<br>
  &nbsp; X1 a;&nbsp; // allocates a new Y object and points at it<br>
  <br>
  &nbsp; X1 b;&nbsp; // allocates a new Y object and points at it<br>
  <br>
  &nbsp; b = a; // b now points at the same Y object as a,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // and no one points at the Y
  object that<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // was created by b<br>
  <br>
  &nbsp; // ... manipulating a and b modifies<br>
  &nbsp; // the same Y object ...<br>
  <br>
  } // as b goes out of scope and is destroyed, it<br>
  &nbsp; // deletes the pointed-at Y... and so does a, oops<br>
  <br>
  &nbsp; // the Y object allocated by b is never deleted</font></p>
</blockquote>
<p>In other code, we normally apply the good practice of wrapping bald pointers
in manager objects that own them and simplify cleanup. If the Y member was held
by such a manager object, instead of by a bald pointer, wouldn't that ameliorate
the situation? This brings us to our Guru Questions:</p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">What About auto_ptr Members?<!--mstheme--></font></h4>
<p><font color="#999933"><b><font size="4">2.</font></b>   What are the
advantages and drawbacks of the following approach?</font></p>
<blockquote>
<p><font face="Courier New" color="#999933">// Example 2<br>
//<br>
class X2<br>
{<br>
&nbsp; // ...<br>
private:<br>
&nbsp; auto_ptr&lt;Y&gt; y_;<br>
};</font></p>
</blockquote>
<p>In short, this has some benefits but it doesn't do a whole lot to solve the
problem that the automatically generated copy construction and copy assignment
functions will do the wrong thing. It just makes them do different wrong things.</p>
<p>First, if X2 has any user-written constructors, making them exception-safe is
easier because if an exception is thrown in the constructor the auto_ptr will
perform its cleanup automatically. The writer of X2 is still forced, however, to
allocate his own Y object and hold it, however briefly, by a bald pointer before
the auto_ptr object assumes ownership.</p>
<p>Next, the automatically generated destructor now does in fact do the right
thing. As an X2 object goes out of scope and is destroyed, the auto_ptr&lt;Y&gt;
destructor automatically performs cleanup by deleting the owned Y object. Even
so, there is a subtle caveat here that has already caught me once: If you rely
on the automatically generated destructor, then that destructor will be defined
in each translation unit that uses X2, which means that the definition of Y must
be visible to pretty much anyone who uses an X2 (this is not so good if Y is a
Pimpl, for example, and the whole point is to hide Y's definition from clients
of X2). So you can rely on the automatically generated destructor, but only if
the full definition of Y is supplied along with X2 (for example, if x2.h
includes y.h):</p>
<blockquote>
  <p><font face="Courier New">// Example 2(a): Y must be defined.<br>
  //<br>
  {<br>
  &nbsp; X2 a; // allocates a new Y object and points at it<br>
  <br>
  &nbsp; // ...<br>
  <br>
  } // as a goes out of scope and is destroyed, it<br>
  &nbsp; // deletes the pointed-at Y, and this can only<br>
  &nbsp; // happen if the full definition of Y is available</font></p>
</blockquote>
<p>If you don't want to provide the definition of Y, then you must write the X2
destructor explicitly, even if it is just empty.</p>
<p>Next, the automatically generated copy constructor will no longer have the
double-delete problem described in Example 1(b). That's the good news. The
not-so-good news is that the automatically generated version introduces another
problem, namely grand theft: The X2 object being constructed rips away the Y
belonging to copied-from X2 object, including all knowledge of the Y object:</p>
<blockquote>
  <p><font face="Courier New">// Example 2(b): Grand theft pointer.<br>
  //<br>
  {<br>
  &nbsp; X2 a; // allocates a new Y object and points at it<br>
  <br>
  &nbsp; X2 b( a ); // b rips away a's Y object, leaving a's<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // y_
  member with a null auto_ptr<br>
  <br>
  &nbsp; // if a attempts to use its y_ member, it won't<br>
  &nbsp; // work; if you're lucky, the problem will manifest<br>
  &nbsp; // as an immediate crash, otherwise it will likely<br>
  &nbsp; // manifest as a difficult-to-diagnose intermittent<br>
  &nbsp; // failure<br>
  }</font></p>
</blockquote>
<p>The only redeeming point about the above grand theft, and it isn't much, is
that at least the automatically generated X2 copy constructor gives some fair
warning that theftlike behavior may be impending. Why? Because its signature
will be X2::X2( X2&amp; ) -- note that it takes it parameter by reference to
non-const. That's what auto_ptr's copy constructor does, after all, and so X2's
automatically generated one has to follow suit. This is pretty subtle, though,
but at least it prevents copying from a const X2.</p>
<p>Finally, the automatically generated copy assignment operator will no longer
have either the double-delete problem or the leak problem, both of which were
described in Example 1(c). That's the good news. Alas, again, there's some
not-so-good news, because the same grand theft occurs: The assigned-to X2 object
rips away the Y belonging to assigned-from X2 object, including all knowledge of
the Y object, and in addition it (possibly prematurely) deletes the Y object
that it originally owned:</p>
<blockquote>
  <p><font face="Courier New">// Example 2(c): More grand theft pointer.<br>
  //<br>
  {<br>
  &nbsp; X2 a;&nbsp; // allocates a new Y object and points at it<br>
  <br>
  &nbsp; X2 b;&nbsp; // allocates a new Y object and points at it<br>
  <br>
  &nbsp; b = a; // b deletes its pointed-at Y, rips away<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // a's Y, and leaves a with a
  null auto_ptr<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // again<br>
  <br>
  &nbsp; // as in Example 2(b), any attempts by a to use its<br>
  &nbsp; // y_ member will be disastrous<br>
  }</font></p>
</blockquote>
<p>Similarly above, at least the theftish behavior is hinted at, because the
automatically generated function will be declared as X2&amp; X2::operator=(
X2&amp; ), thus advertising (albeit in the fine print, not in a front-page
banner) that the operand can be modified.</p>
<p>In summary, then, auto_ptr does give some benefits, particularly by
automating cleanup for constructors and the destructor. It does not, however, of
itself answer the main original problems in this case: That we have to write our
own copy construction and copy assignment for X2, or else disable them if
copying doesn't make sense for the class. For that, we can do better with
something a little more special-purpose.</p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Variations On HolderPtr<!--mstheme--></font></h4>
<p>The meat of this article involves development successively refined versions
of a HolderPtr template that is more suitable than auto_ptr for the kinds of
uses outlined above.</p>
<p>A note on exception specifications: For reasons I won't go into here (see a
coming issue of GotW), exception specifications are not as useful as you might
think. On the other hand, it is important to know what exceptions a function
might throw, especially if it is AC-safe (always succeeds and leaves the system
in a consistent state) which means no exception can occur; this is also known as
a nothrow guarantee. Well, you don't need exception specifications to document
behavior, and so I am going to assert the following:</p>
<blockquote>
  <p>For every version of HolderPtr&lt;T&gt; presented in this article, all
  member functions are AC-safe (nothrow) except that construction or assignment
  from a HolderPtr&lt;U&gt; (where U could be T) might cause an exception to be
  thrown from a T constructor.</p>
</blockquote>
<p>Now let's get into the meat of it:</p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">A Simple HolderPtr: Strict Ownership Only<!--mstheme--></font></h4>
<p><font color="#999933"><b><font size="4">3.</font></b>   Write a suitable
HolderPtr template that is used as shown here:</font></p>
<blockquote>
<p><font face="Courier New" color="#999933">// Example 3<br>
//<br>
class X3<br>
{<br>
&nbsp; // ...<br>
private:<br>
&nbsp; HolderPtr&lt;Y&gt; y_;<br>
};</font></p>
</blockquote>
<p>We are going to consider three cases. In all three, the constructor benefit
still applies: Cleanup is automated and there's less work for the writer of
X3::X3() to be exception-safe and avoid leaks from failed constructors.<b><a href="#2"><sup>[2]</sup></a></b> Also,
in all three, the destructor restriction still applies: Either the full
definition of Y must accompany X3, or the X3 destructor must be explicitly
provided, even if it's empty.</p>

<p><font color="#999933">to suit three specific circumstances:</font></p>
<blockquote>
  <p><font color="#999933">a) Copying and assigning HolderPtrs is not allowed.</font></p>
</blockquote>

<p>There's really not much to it:</p>

<blockquote>
  <p><font face="Courier New">// Example 3(a): Simple case: HolderPtr without<br>
  // copying or assignment.<br>
  //<br>
  template&lt;class T&gt;<br>
  class HolderPtr<br>
  {<br>
  public:<br>
  &nbsp; explicit HolderPtr( T* p = 0 ) : p_( p ) { }<br>
  <br>
  &nbsp; ~HolderPtr() { delete p_; p_ = 0; }</font></p>
</blockquote>

<p>Of course, there has to be some way to access the pointer, so add something
like the following, which parallels std::auto_ptr:</p>

<blockquote>
  <p><font face="Courier New">&nbsp; T&amp; operator*() const { return *p_; }<br>
  <br>
  &nbsp; T* operator-&gt;() const { return p_; }</font></p>
</blockquote>
<p>What else might we need? Well, for many smart pointer types it can make sense
to provide additional facilities that parallel auto_ptr's reset() and release()
functions to let users arbitrarily change which object is owned by a HolderPtr.
It may seem at first like that such facilities would be a good idea because they
contribute to HolderPtr's intended purpose and usage as a class member;
consider, for example, Example 4 in the solution to <a href="059.htm"> GotW #59</a>, where the class
member holds a Pimpl pointer and it's desirable to write an exception-safe
assignment operator... then you need a way to swap HolderPtrs without copying
the owned objects. But providing reset()- and release()-like functions isn't the
right way to do it... that would let users do what they need for swapping and
exception-safety, but it would also open the door for many other (unneeded)
options that don't contribute to the purpose of HolderPtr and can cause problems
if abused.</p>
<p>So what to do? Insteading of providing overly general facilities, understand
your requirements well enough to provide just the facility you really need:</p>
<blockquote>
  <p><font face="Courier New">&nbsp; void Swap( HolderPtr&amp; other ) { swap(
  p_, other.p_ ); }<br>
  <br>
  private:<br>
  &nbsp; T* p_;<br>
  <br>
  &nbsp; // no copying<br>
  &nbsp; HolderPtr( const HolderPtr&amp;
  );<br>
  &nbsp; HolderPtr&amp; operator=( const HolderPtr&amp; );<br>
  };</font></p>
</blockquote>
<p>We take ownership of the pointer and delete it afterwards, we handle the null
pointer case, and copying and assignment are specifically disabled in the usual
way by declaring them private and not defining them. Construction is explicit as
good practice to avoid implicit conversions, which are never needed by
HolderPtr's intended audience.</p>
<p>There, that was easy. I hope it didn't lull you into a false sense of
security, because the next steps have some subtleties attached.</p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Copy Construction and Copy Assignment<!--mstheme--></font></h4>
<blockquote>
  <p><font color="#999933">b) Copying and assigning HolderPtrs is allowed, and
  has the semantics of creating a copy of the owned Y object using the Y copy
  constructor.</font></p>
</blockquote>

<p>Here's one way to write it that satisfies the requirements but isn't as
general-purpose as it could be. It's the same as Example 3(a), but with copy
construction and copy assignment defined:</p>

<blockquote>
  <p><font face="Courier New">// Example 3(b)(i): HolderPtr with copying and<br>
  // assignment, take 1.<br>
  //<br>
  template&lt;class T&gt;<br>
  class HolderPtr<br>
  {<br>
  public:<br>
  &nbsp; explicit HolderPtr( T* p = 0 ) : p_( p ) { }<br>
  <br>
  &nbsp; ~HolderPtr() { delete p_; p_ = 0; }<br>
  <br>
  &nbsp; T&amp; operator*() const { return *p_; }<br>
  <br>
  &nbsp; T* operator-&gt;() const { return p_; }<br>
  <br>
  &nbsp; void Swap( HolderPtr&amp; other ) { swap( p_, other.p_ ); }<br>
  <br>
  <font color="#008080">&nbsp; //--- new code begin
  ------------------------------<br>
  &nbsp; HolderPtr( const HolderPtr&amp; other )<br>
  &nbsp;&nbsp;&nbsp; : p_( other.p_ ? new T( *other.p_ ) : 0 ) { }</font></font></p>
</blockquote>

<p>Note that it's important to check whether other's pointer is null or not.
Since, however, operator=() is implemented in terms of copy construction, we
only have to put the check in one place.</p>

<blockquote>
  <p><font face="Courier New"><font color="#008080">&nbsp; HolderPtr&amp;
  operator=( const HolderPtr&amp; other )<br>
  &nbsp; {<br>
  &nbsp;&nbsp;&nbsp; HolderPtr&lt;T&gt; temp( other );<br>
  &nbsp;&nbsp;&nbsp; Swap( temp );<br>
  &nbsp;&nbsp;&nbsp; return *this;<br>
  &nbsp; }<br>
  &nbsp; //--- new code end --------------------------------<br>
  </font><br>
  private:<br>
  &nbsp; T* p_;<br>
  };</font></p>
</blockquote>
<p>This satisfies the stated requirements, because in the intended usage there's
no case where we will be copying or assigning from a HolderPtr that manages any
type other than T. If that's all we know you'll ever need, then that's fine. But
whenever we design a class, we should at least consider designing for
extensibility if it doesn't cost us much extra work and could make the new
facility more useful to users in the future. At the same time, we need to
balance such &quot;design for reusability&quot; with the danger of
overengineering, that is, of providing an overly complex solution to a simple
problem. This brings us to the next point:</p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Templated Construction and Templated Assignment<!--mstheme--></font></h4>
<p>One question to consider is this: What is the impact on the Example 3(b)(i)
code if we want to allow for the possibility of assigning between different
types of HolderPtr in the future? That is, we want to be able to copy or assign
a HolderPtr&lt;X&gt; to a HolderPtr&lt;Y&gt; if X is convertible to Y. It turns
out that the impact is minimal: Duplicate the copy constructor and the copy
assignment operators with templated versions that just add
&quot;template&lt;class U&gt;&quot; in front and take a parameter of type
&quot;HolderPtr&lt;U&gt;&amp;&quot;, as follows:</p>
<blockquote>
  <p><font face="Courier New">// Example 3(b)(ii): HolderPtr with copying and<br>
  // assignment, take 2.<br>
  //<br>
  template&lt;class T&gt;<br>
  class HolderPtr<br>
  {<br>
  public:<br>
  &nbsp; explicit HolderPtr( T* p = 0 ) : p_( p ) { }<br>
  <br>
  &nbsp; ~HolderPtr() { delete p_; p_ = 0; }<br>
  <br>
  &nbsp; T&amp; operator*() const { return *p_; }<br>
  <br>
  &nbsp; T* operator-&gt;() const { return p_; }<br>
  <br>
  &nbsp; void Swap( HolderPtr&amp; other ) { swap( p_, other.p_ ); }<br>
  <br>
  &nbsp; HolderPtr( const HolderPtr&amp; other )<br>
  &nbsp;&nbsp;&nbsp; : p_( other.p_ ? new T( *other.p_ ) : 0 ) { }<br>
  <br>
  &nbsp; HolderPtr&amp; operator=( const HolderPtr&amp; other )<br>
  &nbsp; {<br>
  &nbsp;&nbsp;&nbsp; HolderPtr&lt;T&gt; temp( other );<br>
  &nbsp;&nbsp;&nbsp; Swap( temp );<br>
  &nbsp;&nbsp;&nbsp; return *this;<br>
  &nbsp; }<br>
  <br>
  <font color="#008080">&nbsp; //--- new code begin
  ------------------------------<br>
  &nbsp; template&lt;class U&gt;<br>
  &nbsp; HolderPtr( const HolderPtr&lt;U&gt;&amp; other )<br>
  &nbsp;&nbsp;&nbsp; : p_( other.p_ ? new T( *other.p_ ) : 0 ) { }<br>
  <br>
  &nbsp; template&lt;class U&gt;<br>
  &nbsp; HolderPtr&amp; operator=( const HolderPtr&lt;U&gt;&amp; other )<br>
  &nbsp; {<br>
  &nbsp;&nbsp;&nbsp; HolderPtr&lt;T&gt; temp( other );<br>
  &nbsp;&nbsp;&nbsp; Swap( temp );<br>
  &nbsp;&nbsp;&nbsp; return *this;<br>
  &nbsp; }<br>
  <br>
  private:<br>
  &nbsp; template&lt;class U&gt; friend class HolderPtr;<br>
  &nbsp; //--- new code end --------------------------------<br>
  </font><br>
  T* p_;<br>
  };</font></p>
</blockquote>
<p>Did you notice the trap we avoided? We still need to write the nontemplated
forms of copying and assignment too in order to suppress the automatically
generated versions, because a templated constructor is never a copy constructor
and a templated assignment operator is never a copy assignment operator. For
more information about this, see Item 5 in <i><a href="../publications/xc++.htm">Exceptional
C++</a>.</i><b><a href="#1"><sup>[1]</sup></a></b></p>
<div align="right">
  <!--mstheme--></font><table border="1" cellpadding="6" cellspacing="0" width="50%" align="right" bordercolordark="#006666" bordercolorlight="#99CCCC">
    <tr>
      <td><!--mstheme--><font face="Arial, Arial, Helvetica"><h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Balancing reusability against overengineering<!--mstheme--></font></h4>
        <p>From what I understand of XP, it seems to me that migration from
        3(b)(i) to 3(b)(ii) may happen in an XP environment only if HolderPtr is
        used in a single project, or is owned by the same team that comes across
        the new requirement to copy and assign between different kinds of
        HolderPtr. Part of the core XP philosophy is to only refactor or extend
        when necessary to implement a particular new feature, and that assumes
        that the person implementing the feature also has rights to extend the
        code being reused, here HolderPtr; if not, you'll end up having several
        project teams each writing their own extensions as needed when a
        reusable common component is insufficient, instead of upgrading the
        common component once and saving overall effort across projects. (And
        that's just the &quot;upgrade/extend&quot; case; it's even harder to
        refactor common components already in use in multiple projects even if
        you do have the source rights, because the need to maintain interface
        stability greatly limits the scope of acceptable changes.)</p>
        <p>This kind of situation seems that it might build into XP a systemic impediment
        to &quot;design for extensibility&quot; at least for library creation
        and maintenance and other cross-project reuse efforts, and is part of
        the cost for the short-term rather than long-term thinking encouraged by
        XP. That's not to say that XP's advantages may not outweigh the
        disadvantages in a given situation -- I'm sure there are situations
        where they do --, but it is important to understand both sides of a
        particular methodology before jumping into it with both feet for a
        particular project. For example, XP has a lot to recommend it for a
        single, short-term, focused project that does not overlap much or at all
        with other projects and can be thrown away if needed, but XP might not
        be as appropriate for writing things like space shuttle onboard systems,
        or even shared libraries unless the library team was treated as a
        distinct project.</p>
        <p>This is my feeling only, based on what little I know of XP.
        Corrections and flames are welcome.</p>
      <!--mstheme--></font></td>
    </tr>
  </table><!--mstheme--><font face="Arial, Arial, Helvetica">
</div>
<p>There is still one subtle caveat, though, but fortunately it's not really a
big deal (or even, I would say, our responsibility as the authors of HolderPtr):
With either the templated or nontemplated copy and assignment functions, the
source (&quot;other&quot;) object could still actually be holding a pointer to a
derived type in which case we're slicing. For example:</p>
<blockquote>
  <p><font face="Courier New">class A {};<br>
  class B : public A {};<br>
  class C : public B {};<br>
  <br>
  HolderPtr&lt;A&gt; a1( new B );<br>
  HolderPtr&lt;B&gt; b1( new C );<br>
  <br>
 // calls copy ctor,<br>
  // slices<br>
  HolderPtr&lt;A&gt; a2( a1 );<br>
  <br>
 // calls templated ctor,<br>
  // slices<br>
  HolderPtr&lt;A&gt; a3( b1 );<br>
  <br>
 // calls copy assignment,<br>
  // slices<br>
  a2 = a1;<br>
  <br>
 // calls templated<br>
  // assignment, slices<br>
  a3 = b1;</font></p>
</blockquote>
<p>I point this out because this is the sort of thing one shouldn't forget to
write up in the HolderPtr documentation to warn users, preferably in a
&quot;Don't Do That&quot; section. There's not much else we the authors of
HolderPtr can do in code to stop this kind of abuse.</p>
<p>So which is the right solution to problem 3(b) -- Example 3(b)(i), or Example
3(b)(ii)? Both are good solutions, and it's really a judgment call based on your
own experience at balancing design-for-reuse and overengineering-avoidance. I
imagine that XP advocates in particular would automatically use 3(b)(i) because
it satisfies the minimum requirements. I can also imagine situations where
HolderPtr is in a library written by one group and shared by several distinct
teams and where 3(b)(ii) will end up saving overall development effort through
reuse and the prevention of reinvention.</p>

      <h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Adding Extensibility Using Traits<!--mstheme--></font></h4>
      <p>But, now, what if Y has a virtual Clone() method? It may seem from
      Example 1 that X always creates its own owned Y object, but it might get
      it from a factory or from a new-expression of some derived type. As we've
      already seen, in such a case the owned Y object might not really be a Y
      object at all, but be of some type derived from Y, and copying it as a Y
      would slice it at best and render it unusable at worst. The usual
      technique in this kind of situation is for Y to provide a special virtual
      Clone() member function that allows complete copies to be made even
      without knowing the complete type of the object being pointed at.</p>
      <p>So, what if someone wants to use a HolderPtr to hold such an object,
      that can only be copied using a function other than the copy constructor?
      This is the point of our final question:</p>

<blockquote>
  <p><font color="#999933">c) Copying and assigning HolderPtrs is allowed, and
  has the semantics of creating a copy of the owned Y object, which is performed
  using a virtual Y::Clone() method if present and the Y copy constructor
  otherwise.</font></p>
</blockquote>

      <p>In the HolderPtr template, we don't know what our contained T type
      really is, we don't know whether it has a virtual Clone() function, and so
      we don't know the right way to copy it. Or do we?</p>
      <p>One solution is to apply a technique widely used in the C++ standard
      library itself, namely traits. Briefly, a traits class is defined as
      follows, quoting clause 17.1.18:</p>
      <blockquote>
        <p><i>a class that encapsulates a set of types and functions necessary
        for template classes and template functions to manipulate objects of
        types for which they are instantiated</i></p>
      </blockquote>
      <p>First, let's change Example 3(b)(ii) slightly to remove some
      redundancy. You'll notice that both the templated constructor and the copy
      constructor have to check the source for nullness. Let's put all that work
      in a single place and have a single Create() function that builds a new T
      object (we'll see another reason to do this in a minute):</p>
      <blockquote>
        <p><font face="Courier New">// Example 3(c)(i): HolderPtr with copying
        and<br>
        // assignment, Example 3(b)(ii)<br>
        // with a little factoring.<br>
        //<br>
        template&lt;class T&gt;<br>
        class HolderPtr<br>
        {<br>
        public:<br>
        &nbsp; explicit HolderPtr( T* p = 0 ) : p_( p ) { }<br>
        <br>
        &nbsp; ~HolderPtr() { delete p_; p_ = 0; }<br>
        <br>
        &nbsp; T&amp; operator*() const { return *p_; }<br>
        <br>
        &nbsp; T* operator-&gt;() const { return p_; }<br>
        <br>
        &nbsp; void Swap( HolderPtr&amp; other ) { swap( p_, other.p_ ); }<br>
        <br>
        &nbsp; HolderPtr( const HolderPtr&amp; other )<br>
        &nbsp;&nbsp;&nbsp; : p_( CreateFrom( other.p_ ) ) { } // changed<br>
        <br>
        &nbsp; HolderPtr&amp; operator=( const HolderPtr&amp; other )<br>
        &nbsp; {<br>
        &nbsp;&nbsp;&nbsp; HolderPtr&lt;T&gt; temp( other );<br>
        &nbsp;&nbsp;&nbsp; Swap( temp );<br>
        &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp; }<br>
        <br>
        &nbsp; template&lt;class U&gt;<br>
        &nbsp; HolderPtr( const HolderPtr&lt;U&gt;&amp; other )<br>
        &nbsp;&nbsp;&nbsp; : p_( CreateFrom( other.p_ ) ) { } // changed<br>
        <br>
        &nbsp; template&lt;class U&gt;<br>
        &nbsp; HolderPtr&amp; operator=( const HolderPtr&lt;U&gt;&amp; other )<br>
        &nbsp; {<br>
        &nbsp;&nbsp;&nbsp; HolderPtr&lt;T&gt; temp( other );<br>
        &nbsp;&nbsp;&nbsp; Swap( temp );<br>
        &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp; }<br>
        <br>
        private:<br>
        <font color="#008080">&nbsp; //--- new code begin
        ------------------------------<br>
        &nbsp; template&lt;class U&gt;<br>
        &nbsp; T* CreateFrom( const U* p ) const<br>
        &nbsp; {<br>
        &nbsp;&nbsp;&nbsp; return p ? new T( *p ) : 0;<br>
        &nbsp; }<br>
        &nbsp; //--- new code end --------------------------------<br>
        </font><br>
        &nbsp; template&lt;class U&gt; friend class HolderPtr;<br>
        <br>
        &nbsp; T* p_;<br>
        };</font></p>
      </blockquote>
      <p>Now, CreateFrom() gives us a nice hook to encapsulate all knowledge
      about different ways of copying a T.</p>
      <h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Applying Traits<!--mstheme--></font></h4>
      <p>Now we can apply the traits technique using something like the
      following approach. Note that this is not the only way to apply traits,
      and there are other ways besides traits to deal with different ways of
      copying a T. I chose to use a single traits class template with a single
      static Clone() member that calls whatever is needed to do the actual
      cloning, and which can be thought of as an adapter. This follows the style
      of char_traits, for example, which simply delegates the work to the traits
      class. (Alternatively, for example, the traits class could provide
      typedefs and other aids so that the HolderPtr template to figure out what
      to do, but still have to do it itself, but it's a needless division of
      responsibilities to have one place find out what the right thing to do is,
      and a different place to actually do it.)</p>
      <blockquote>
        <p><font face="Courier New">template&lt;class T&gt;<br>
        class HolderPtr<br>
        {<br>
        &nbsp; // ...<br>
        <br>
        &nbsp; template&lt;class U&gt;<br>
        &nbsp; T* CreateFrom( const U* p ) const<br>
        &nbsp; {<br>
        &nbsp;&nbsp;&nbsp; // the &quot;Do the Right Thing&quot; fix... but how?<br>
        &nbsp;&nbsp;&nbsp; return p ? HPTraits&lt;U&gt;::Clone( p ) : 0;<br>
        &nbsp; }<br>
        };</font></p>
      </blockquote>

<p>We want HPTraits to be a template that does the actual cloning work, where
the main template's implementation of Clone() uses U's copy constructor. Two
notes: First, since HolderPtr assumes responsibility for the null check,
HPTraits::Clone() doesn't have to do it; and second, if T and U are different
this function can only compile if a U* is convertible to a T*, in order to
correctly handle polymorphic cases like T==Base U==Derived.</p>

      <blockquote>

<p><font face="Courier New">template&lt;class T&gt;<br>
class HPTraits<br>
{<br>
&nbsp; static T* Clone( const T* p ) { return new T( *p ); }<br>
};</font></p>

      </blockquote>

<p>Then HPTraits is specialized as follows for any given Y that does not want to
use copy construction. For example, say that some Y has a virtual Y* CloneMe()
function, and some Z has a virtual void CopyTo( Z&amp; ) function; then
HPTraits&lt;Y&gt; is specialized so as to let that function do the cloning:</p>

      <blockquote>
        <p><font face="Courier New">// The most work any user has to do, and it
        only<br>
        // needs to be done once, in one place:<br>
        //<br>
        template&lt;&gt;<br>
        class HPTraits&lt;Y&gt;<br>
        {<br>
        &nbsp; static Y* Clone( const Y* p )<br>
        &nbsp;&nbsp;&nbsp; { return p-&gt;CloneMe(); }<br>
        };<br>
        <br>
        template&lt;&gt;<br>
        class HPTraits&lt;Z&gt;<br>
        {<br>
        &nbsp; static Z* Clone( const Z* p )<br>
        &nbsp;&nbsp;&nbsp; { Z* z = new Z; p-&gt;CopyTo(*z); return z; }<br>
        };</font></p>
      </blockquote>
      <p>This is much better, and it will work with whatever flavor and
      signature of CloneMe() is ever invented in the future; Clone() only needs
      to create it under the covers in whatever way it deems desirable, and the
      only visible result is a pointer to the new object... another good
      argument for strong encapsulation.</p>
      <p>To use HolderPtr with a brand new type Y that was invented centuries
      after HolderPtr was written and its authors turned to dust, the new
      fourth-millennium user (or author) of Y merely needs to specialize
      HPTraits once for all time, then use HolderPtr&lt;Y&gt;s all over the
      place in her code wherever desired. That's pretty easy. And, if Y doesn't
      have a virtual Clone() function, the user (or author) of Y doesn't even
      need to do that and can just use HolderPtr without any work at all.</p>
      <p>A brief coda: Since HPTraits has only a single static function
      template, why make it a class template instead of just a function
      template? The main motive is for encapsulation (in particular, better name
      management) and extensibility. We want to avoid cluttering the global
      namespace with free functions; the function template could be put at
      namespace scope in whatever namespace HolderPtr itself is supplied in, but
      even then this couples it more tightly to HolderPtr as opposed to use by
      perhaps other code also in that namespace. Now, the Clone() function
      template may be the only kind of trait we need today, but what if we need
      new ones tomorrow? If the additional traits are functions, we'd otherwise
      have to continue cluttering things up with extra free functions. But what
      if the additional traits are typedefs or even class types? HPTraits gives
      us a nice place to encapsulate all of those things.</p>
      <h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">HolderPtr With Traits<!--mstheme--></font></h4>
      <p>Here is the code for a HolderPtr that incorporates cloning traits along
      with all of the earlier requirements in Question 3.<b><a href="#3"><sup>[3]</sup></a></b>
      Note that the only change from Example 3(c)(i) is a one-line change to
      HolderPtr and one new template with a single simple function... now that's
      what I call minimum-impact given all of the flexibility we've just bought:</p>
      <blockquote>
        <p><font face="Courier New">// Example 3(c)(ii): HolderPtr with copying
        and<br>
        // assignment and full traits-based<br>
        // customizability.<br>
        //<br>
        <font color="#008080">//--- new code begin
        --------------------------------<br>
        template&lt;class T&gt;<br>
        class HPTraits<br>
        {<br>
        static T* Clone( const T* p ) { return new T( *p ); }<br>
        };<br>
        //--- new code end ----------------------------------<br>
        </font><br>
        template&lt;class T&gt;<br>
        class HolderPtr<br>
        {<br>
        public:<br>
        &nbsp; explicit HolderPtr( T* p = 0 ) : p_( p ) { }<br>
        <br>
        &nbsp; ~HolderPtr() { delete p_; p_ = 0; }<br>
        <br>
        &nbsp; T&amp; operator*() const { return *p_; }<br>
        <br>
        &nbsp; T* operator-&gt;() const { return p_; }<br>
        <br>
        &nbsp; void Swap( HolderPtr&amp; other ) { swap( p_, other.p_ ); }<br>
        <br>
        &nbsp; HolderPtr( const HolderPtr&amp; other )<br>
        &nbsp;&nbsp;&nbsp; : p_( CreateFrom( other.p_ ) ) { }<br>
        <br>
        &nbsp; HolderPtr&amp; operator=( const HolderPtr&amp; other )<br>
        &nbsp; {<br>
        &nbsp;&nbsp;&nbsp; HolderPtr&lt;T&gt; temp( other );<br>
        &nbsp;&nbsp;&nbsp; Swap( temp );<br>
        &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp; }<br>
        <br>
        &nbsp; template&lt;class U&gt;<br>
        &nbsp; HolderPtr( const HolderPtr&lt;U&gt;&amp; other )<br>
        &nbsp;&nbsp;&nbsp; : p_( CreateFrom( other.p_ ) ) { }<br>
        <br>
        &nbsp; template&lt;class U&gt;<br>
        &nbsp; HolderPtr&amp; operator=( const HolderPtr&lt;U&gt;&amp; other )<br>
        &nbsp; {<br>
        &nbsp;&nbsp;&nbsp; HolderPtr&lt;T&gt; temp( other );<br>
        &nbsp;&nbsp;&nbsp; Swap( temp );<br>
        &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp; }<br>
        <br>
        private:<br>
        &nbsp; template&lt;class U&gt;<br>
        &nbsp; T* CreateFrom( const U* p ) const<br>
        &nbsp; {<br>
        <font color="#008080">&nbsp; //--- new code begin
        ----------------------------<br>
        &nbsp;&nbsp;&nbsp; return p ? HPTraits&lt;U&gt;::Clone( p ) : 0;<br>
        &nbsp; //--- new code end ------------------------------<br>
        </font>&nbsp; }<br>
        <br>
        &nbsp; template&lt;class U&gt; friend class HolderPtr;<br>
        <br>
        &nbsp; T* p_;<br>
        };</font></p>
      </blockquote>
      <h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">A Usage Example<!--mstheme--></font></h4>
      <p>Here is an example that shows the typical implementation of the major
      functions (construction, destruction, copying, and assignment) for class
      that uses our final version of HolderPtr, ignoring more detailed issues
      like whether the destructor ought or ought not to be present (or inline)
      because Y is or is not defined:</p>
      <blockquote>
        <p><font face="Courier New">// Example 4: Sample usage of HolderPtr.<br>
        //<br>
        class X<br>
        {<br>
        public:<br>
        &nbsp; X() : y_( new Y(/*...*/) ) { }<br>
        <br>
        &nbsp; ~X() { }<br>
        <br>
        &nbsp; X( const X&amp; other ) : y_( new Y(*(other.y_) ) ) { }<br>
        <br>
        &nbsp; void Swap( X&amp; other ) { y_.Swap( other.y_ ); }<br>
        <br>
        &nbsp; X&amp; operator=( const X&amp; other )<br>
        &nbsp; {<br>
        &nbsp;&nbsp;&nbsp; X temp( other );<br>
        &nbsp;&nbsp;&nbsp; Swap( temp );<br>
        &nbsp;&nbsp;&nbsp; return *this;<br>
        &nbsp; }<br>
        <br>
        private:<br>
        &nbsp; HolderPtr&lt;Y&gt; y_;<br>
        };</font></p>
      </blockquote>
      <h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Summary<!--mstheme--></font></h4>
      <p>One moral I would like you to take away from this issue of GotW is to
      always be aware of extensibility as you're designing. By default, prefer
      to design for reuse. While avoiding the trap of overengineering, always be
      aware of a longer-term view -- you can always decide to reject it, but
      always be aware of it -- so that you save time and effort in the long run
      both for yourself and for all the grateful users who will be happily
      reusing your code with their own new classes well into the new millennium.</p>
      <p>&nbsp;</p>

<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Notes<!--mstheme--></font></h4>
<p><a name="1"></a>1. H. Sutter. <b><a href="../publications/xc++.htm">Exceptional
C++</a></b> (Addison-Wesley, 2000).</p>
<p><a name="2"></a>2. It is also possible to have HolderPtr itself perform the
construction of the owned Y object, but I will omit that for clarity and because
it pretty much just gives HolderPtr&lt;Y&gt; the same Y value semantics, begging
the question &quot;then why not just use a plain old Y member?&quot;</p>
<p><a name="3"></a>3. Alternatively, one might also choose to provide a traits
object as an additional HolderPtr template parameter Traits that just defaults
to HPTraits&lt;T&gt;, the same way std::basic_string does:</p>
      <blockquote>
<p><font face="Courier New">template&lt;class T, class Traits =
HPTraits&lt;T&gt; &gt;<br>
class HolderPtr { /*...*/ };</font></p>
      </blockquote>
<p>so that it's even possible for users to have different HolderPtr&lt;X&gt;
objects in the same program copy in different ways. That didn't seem to make a
lot of sense in this particular case, so I didn't do it, but it shows what's
possible.</p>
<!--mstheme--></font><!--msnavigation--></td></tr><!--msnavigation--></table><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td><!--mstheme--><font face="Arial, Arial, Helvetica"><h4 align="right"><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666"><a href="../copyright.htm"><font size="2">Copyright ©
2002 Herb Sutter</font></a><!--mstheme--></font></h4>

<!--mstheme--></font></td></tr><!--msnavigation--></table></body>
</html>

