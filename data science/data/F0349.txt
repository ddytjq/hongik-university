ID=F0349
URL=http://www.vb-helper.com/tut6.htm
SIZE=29344
DATE=09/07/2002
TIME=13:19:24
DATASET=Visual Basic
HTML=<HTML>
<HEAD>
<TITLE>VB Helper Tutorial: Bug Proofing - Error Handling Fundamentals</TITLE>
<META NAME=Author CONTENT="Rod Stephens">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<META HTTP-EQUIV=Keywords CONTENT="VB Helper, Tutorial, Error Handling Fundamentals, Bug Proofing, Visual Basic Developer, How-To, Example Programs, Tips & Tricks, Advanced Techniques">
<META NAME=Keywords CONTENT="VB Helper, Tutorial, Error Handling Fundamentals, Bug Proofing, Visual Basic Developer, How-To, Example Programs, Tips & Tricks, Advanced Techniques">
<META NAME=Description CONTENT="VB Helper Tutorial: Bug Proofing - Error Handling Fundamentals">
<META NAME=Copyright CONTENT="Copyright 1997-2001, Rocky Mountain Computer Consulting, Inc.">
<META NAME=Rating CONTENT=General>
<META NAME=Robots CONTENT=All>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#CCCCCC" LINK="#0000EE" VLINK="#551A8B" ALINK="#FF0000" BACKGROUND="bg.gif">

<!-- Header Table -->
<TABLE WIDTH=100% CELLPADDING=0 CELLSPACING=0>
	<TR>
	<TD WIDTH=100%>

	<!-- VB Helper Banner -->
	<TABLE WIDTH=100% CELLPADDING=1 CELLSPACING=0>
		<TR BGCOLOR=#000000 ALIGN=Left>
		  <TD><IMG SRC=vbhelper.gif WIDTH=248 HEIGHT=62></TD></TR>
		<TR><TD WIDTH=10 HEIGHT=2 BGCOLOR=#FF0000></TD></TR>
		<TR><TD WIDTH=10 HEIGHT=3 BGCOLOR=#000000></TD></TR>
	</TABLE>

	</TD>
	<TD><A HREF="http://www.wiley.com/compbooks">
		<IMG SRC=logo.gif BORDER=0 ALIGN=Right WIDTH=77 HEIGHT=105></TD>
	<TD><A HREF=amazon.htm><IMG SRC=amlogo.gif BORDER=0 ALIGN=Right
		WIDTH=68 HEIGHT=65></A></TD>
	</TR>
</TABLE>

<!-- Main Page Table -->
<TABLE WIDTH=100% CELLPADDING=0 CELLSPACING=0>
	<TR>

	<!-- ************ -->
	<!-- Menu Entries -->
	<!-- ************ -->
	<TD WIDTH=130 VALIGN=Top>
	<TABLE WIDTH=130 CELLPADDING=0 CELLSPACING=0>
		<TR><TD><B><A HREF=index.html>New Home</A></B></TD></TR>
		<TR><TD><B><A HREF=old_index.htm>Old Home</A></B></TD></TR>
		<TR><TD><B><A HREF=whatsnew.htm>What's New</A></B></TD></TR>
		<TR><TD><B><A HREF=sitemap.htm>Site Map</A></B></TD></TR>
		<TR><TD>&nbsp;</TD></TR>
		<TR><TD><B><A HREF=books.htm>Books</A></B></TD></TR>
		<TR><TD><B><A HREF=howto.htm>How To</A></B></TD></TR>
		<TR><TD><B><A HREF=tips.htm>Tips & Tricks</A></B></TD></TR>
		<TR><TD><B><A HREF=tutorial.htm>Tutorials</A></B></TD></TR>
		<TR><TD><B><A HREF=stories.htm>Stories</A></B></TD></TR>
		<TR><TD><B><A HREF=perform.htm>Performance<A></B></TD></TR>
		<TR><TD><B><A HREF=essays.htm>Essays</A></B></TD></TR>
		<TR><TD><B><A HREF=links.htm>Links</A></B></TD></TR>
		<TR><TD><B><A HREF=q_and_a.htm>Q & A</A></B></TD></TR>
		<TR><TD><B><A HREF=newvb6.htm>New in VB6</A></B></TD></TR>
		<TR><TD><B><A HREF=free.htm>Free Stuff</A></B></TD></TR>
		<TR><TD><B><A HREF=pictures.htm>Pictures</A></B></TD></TR>
		<TR><TD>&nbsp;</TD></TR>
<!--
		<TR><TD><B><A HREF=guru.htm>VB Guru Award</A></B></TD></TR>
		<TR><TD><B><A HREF=guruwin.htm>VB Guru Winners</A></B></TD></TR>
-->		<TR><TD><B><A HREF=awards.htm>Awards Received</A></B></TD></TR>
		<TR><TD><B><A HREF=banners.htm>Banners</A></B></TD></TR>
		<TR><TD>&nbsp;</TD></TR>
		<TR><TD><B><A HREF=subscribe.htm>News Letter</A></B></TD></TR>
		<TR><TD><B>
			<A HREF=mailto:Feedback@vb-helper.com>Feedback</A>
			</B></TD></TR>
		<!-- BEGIN Starting Point Hot Site code
		<TR><TD>&nbsp;</TD></TR>
		<TR><TD ALIGN=Center>
			<A HREF="http://www.stpt.com"><IMG 
				SRC="hotsite3.gif" BORDER=0WIDTH=80 HEIGHT=68></A>
			</TD</TR>
		<TR><TD ALIGN=Center>
			Click <A HREF="http://www.stpt.com/cgi-bin/general/vote.cgi?category=comput&vote=http%3A%2F%2Fwww.vb-helper.com&title=VB+Helper&email=RodStephens@vb-helper.com">HERE</A>
			to vote for this site as a Starting Point Hot Site.
			</TD></TR>
		END Starting Point Hot Site code -->

		<!-- Counter -->
		<TR><TD>
<IMG SRC="/cgi-bin/counter.exe?link=tut6&amp;style=cool&amp;width=7"
			WIDTH=1 HEIGHT=1>
		</TD></TR>
	</TABLE>
	</TD>
	<!-- **************** -->
	<!-- End Menu Entries -->
	<!-- **************** -->

	<!-- ************* -->
	<!-- Content Panel -->
	<!-- ************* -->
	<TD WIDTH=100% VALIGN=Top>
	<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH=100%>
		<!-- Page Title & Description -->
		<TR>
		<TD WIDTH=100%>
		<TABLE WIDTH=100% CELLPADDING=0 CELLSPACING=0 BGCOLOR=#FFD900>
			<TR><TD WIDTH=100%>
			<B>Tutorial: Bug Proofing - Error Handling Fundamentals</B><BR>

			<A HREF=err.htm><IMG SRC=errs.gif ALIGN=RIGHT></A>

			This article contains roughly half of Chapter 12 of the book
			<I>Bug Proofing Visual Basic</I>. This chapter explains the
			fundamentals of using error handlers in Visual Basic.
			<P>
			There is a lot more to writing bug proof programs than just
			using error handlers. This book also explains how to reduce the
			chances of errors occurring in a program, how to detect errors
			when they do occur, and how to recover from unexpected errors.
			Visit the book's 
			<A HREF=err.htm>Web page</A> to learn more.
			</TD></TR>
		</TABLE>
		</TD></TR>
		<!-- End Page Title & Description -->

		<TR><TD>
<!-- BEGIN PAGE CONTENTS -->


<CENTER>
&nbsp;
<H2>Chapter 12</H2>
<H2>Error Handling Fundamentals</H2>
</CENTER>

<P>
<TABLE WIDTH=100% BORDER=1 BGCOLOR=#C0C0C0 CELLPADDING=2>
	<TR><TH COLSPAN=3>Sections</TH></TR>
	<TR>	<TD><A HREF=#UseOnError>Use On Error</A></TD>
		<TD><A HREF=#LeaveErrorHandlers>Leave Error Handlers</A></TD>
		<TD><A HREF=#DefineErrorConstants>Define Error Constants</A></TD>
	</TR>
	<TR>	<TD><A HREF=#KeepErrorHandlersSeparate>Keep Error 
			Handlers Separate</A></TD>
		<TD><A HREF=#UnderstandErrorHandlerScope>Understand Error
			Handler Scope</A></TD>
		<TD><A HREF=#DontNestErrorHandlers>Don't Nest Error Handlers</A></TD>
	</TR>
	<TR>	<TD><A HREF=#ErrTalk>Error Handling Slides</A></TD>
	</TR>
</TABLE>


This chapter explains the family of On Error statements Visual Basic uses to handle errors. It tells how a program installs and removes error handlers, and it explains some of the idiosyncrasies of error handling code. After reading this chapter you will be able to write basic error handlers to protect your programs from the unexpected.

<A NAME=UseOnError>
<H3>Use On Error</H3>
</A>
A Visual Basic program uses the On Error statement to register error handling code. This statement can take one of three forms:
<UL>
<LI>On Error GoTo 0
<LI>On Error Resume Next
<LI>On Error GoTo line
</UL>

These forms tell Visual Basic what it should do when the program encounters an error. The three forms are described in the following sections.

<H4>On Error GoTo 0</H4>
On Error GoTo 0 is relatively straightforward. It simply cancels any currently installed error handler assigned by a previous On Error GoTo line or On Error Resume Next. If the program encounters an error after this statement executes, it crashes.

<H4>On Error Resume Next</H4>
On Error Resume Next makes the program ignore errors. When it encounters an error, the program continues execution after the statement that caused the error.
When a program uses On Error Resume Next, it should check the Err object after every operation that might cause an error. If the value Err.Number is nonzero, the operation caused an error and the program can take special action.
The program should check Err.Number immediately after the statement in question. Certain other actions reset the Err object and remove the previous error information.
<P>
Many programs use On Error Resume Next when they present a common dialog to the user. The CommonDialog control's CancelError property indicates whether the control should raise an error if the user cancels the dialog. The following code fragment shows how a program can use CancelError to decide whether to continue an action such as loading a file.


<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2 BGCOLOR=#C0FFFF>
<TR><TD>
<TT><PRE><B>' Generate an error if the user cancels.</B>
dlgOpenFile.CancelError = True

<B>' Ignore errors for now.</B>
On Error Resume Next

<B>' Present the dialog.</B>
dlgOpenFile.ShowOpen

<B>' See if there was an error.</B>
If Err.Number = cdlCancel Then
    <B>' The user canceled. Do nothing.</B>
    Exit Sub
ElseIf Err.Number &lt;&gt; 0 Then
    <B>' Unknown error. Take more action.</B>
        :
End If

<B>' Resume normal error handling.</B>
On Error GoTo 0</PRE></TT>
</TD></TR>
</TABLE>


<H4>On Error GoTo Line</H4>

The On Error GoTo line statement registers a new error handler. If the program encounters an error, it passes control to the error handler beginning at the indicated line number or label. The error handler can then take appropriate action.
<P>
The following code shows a simple error handler that catches unexpected errors and describes them to the user.


<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2 BGCOLOR=#C0FFFF>
<TR><TD>
<TT><PRE>Private Sub DoSomething()
    <B>' Install the error handler.</B>
    On Error GoTo UnexpectedError

    <B>' Do stuff.</B>
        :

    <B>' Do not pass through into the error handler code.</B>
    Exit Sub

UnexpectedError:
    <B>' Describe the error to the user.</B>
    MsgBox "Unexpected error" & _
        Str$(Err.Number) & _
        " in subroutine DoSomething." & _
        vbCrLf & _
        Err.Description
    Exit Sub
End Sub</PRE></TT>
</TD></TR>
</TABLE>


<A NAME=LeaveErrorHandlers>
<H3>Leave Error Handlers</H3>
</A>
There are several ways a program can leave error handling code and return to normal execution.
<UL>
<LI>Resume
<LI>Resume Next
<LI>Exit Sub/Function/Property
<LI>End Sub/Function/Property
<LI>Err.Raise
</UL>

These different methods are described in the following sections.

<H4>Resume</H4>
The Resume statement continues execution by repeating the statement that caused the error. If the statement is still incorrect, the program will raise the error again. This may put the program in an infinite loop. To avoid an infinite loop, do not use the Resume statement unless something in the error handler should have fixed the problem.
<P>
For example, the following code tries to load a file that might be stored on a floppy disk. If it fails, the code reports the error and asks the user if it should try again. If the disk is not in the floppy drive, the user can insert it and click the Retry button. The program then uses the Resume statement to try to open the file again. If the program fails again, it returns to the error handler to give the user another chance to fix the problem. The program continues looping from the Open statement to the error handler and back until the user fixes the problem or clicks the Cancel button. If the user clicks Cancel, the error handler exits the subroutine without opening the file.


<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2 BGCOLOR=#C0FFFF>
<TR><TD>
<TT><PRE>Private Sub LoadData(ByVal filename As String)
Dim fnum As Integer

    <B>' Open the file.</B>
    fnum = FreeFile
    On Error GoTo OpenError
    Open filename For Input As fnum

    <B>' Read the data.</B>
    On Error GoTo ReadError
        :

    <B>' Close the file.</B>
    On Error GoTo CloseError
    Close fnum
    Exit Sub

OpenError:
    <B>' We could not open the file. Ask the user</B>
    <B>' if we should retry.</B>
    If MsgBox("Error" & _
            Str$(Err.Number) & _
            " opening file " & filename & "." & _
            vbCrLf & Err.Description & vbCrLf & _
            "Check that the disk is properly " & _
            "inserted and click the Retry button.", _
            vbRetryCancel, _
            "Error opening file") = vbRetry _
    Then
        <B>' Try again at the same statement.</B>
        Resume
    End If

    <B>' Otherwise cancel the file loading.</B>
    Exit Sub

ReadError:
    MsgBox "Error" & _
        Str$(Err.Number) & _
        " reading file " & filename & "." & _
        vbCrLf & Err.Description

    <B>' Close the file.</B>
    Close fnum
    Exit Sub

CloseError:
    <B>' Error closing the file.</B>
    MsgBox "Error" & _
        Str$(Err.Number) & _
        " closing file " & filename & "." & _
        vbCrLf & Err.Description
    Exit Sub
End Sub</PRE></TT>
</TD></TR>
</TABLE>


<H4>Resume Next</H4>

Resume Next makes the program continue execution at the statement after the one that caused the error. This is a useful action if the program and user cannot reasonably correct the error, but the program can continue running without the statement completing. 
<P>
For example, the following code tries to convert a string value into a date using the CDate function. If it fails, the error handler assigns the current date to the start_date variable and uses that as a default value.


<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2 BGCOLOR=#C0FFFF>
<TR><TD>
<TT><PRE>Private Sub ValidateStartDate(ByVal date_string As String)
Dim start_date As Date

    <B>' Install the error handler.</B>
    On Error GoTo InvalidDate

    <B>' Convert the string into a date.</B>
    start_date = CDate(date_string)

    <B>' Do something with the date.</B>
        :

    <B>' Do not pass through into the error handler code.</B>
    Exit Sub

InvalidDate:
    <B>' It's an invalid date string. Use today.</B>
    start_date = Date
    Resume Next
End Sub</PRE></TT>
</TD></TR>
</TABLE>


Note that this is probably not the best way to handle this situation because it silently handles the error instead of making it obvious. If the user entered the invalid value, the program should politely tell the user there is a problem and ask for a new value. If the string was passed to this routine from another part of the program, the program may contain a bug. It should stop during design mode or raise an error in the final compiled version so someone can fix the problem.

<H4>Exit Sub/Function/Property</H4>

If the routine cannot continue with its task, it can use Exit Sub, Exit Function, or Exit Property to exit immediately. The following code shows a new version of the previous routine. If the date string is invalid, this version tells the user and then exits.


<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2 BGCOLOR=#C0FFFF>
<TR><TD>
<TT><PRE>Private Sub ValidateStartDate(ByVal date_string As String)
Dim start_date As Date

    <B>' Install the error handler.</B>
    On Error GoTo InvalidDate

    <B>' Convert the string into a date.</B>
    start_date = CDate(date_string)

    <B>' Do something with the date.</B>
        :

    <B>' Do not pass through into the error handler code.</B>
    Exit Sub

InvalidDate:
    <B>' It's an invalid date string. Tell the user and leave.</B>
    MsgBox "The start date """ & _
        date_string & _
        """ is invalid. Please enter a new one."
    Exit Sub
End Sub</PRE></TT>
</TD></TR>
</TABLE>


When a routine exits in this way, the calling routine cannot tell that an error occurred. That means you should use this technique only when the calling routine can properly continue whether this routine succeeded or not. If the caller must know that this routine failed, the code should use the Err.Raise statement described shortly.
<P>

<H4>End Sub/Function/Property</H4>

If the error handler code continues to the routine's End Sub, End Function, or End Property statement, the routine exits just as if it had executed the Exit statement described in the previous section. For example, the end of the previous subroutine could be written:


<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2 BGCOLOR=#C0FFFF>
<TR><TD>
<TT><PRE>InvalidDate:
    <B>' It's an invalid date string. Tell the user and leave.</B>
    MsgBox "The start date """ & _
        date_string & _
        """ is invalid. Please enter a new one."
End Sub</PRE></TT>
</TD></TR>
</TABLE>


Sometimes it can be a little confusing for the error handler to just drop off the end of the routine like this. This version also creates the opportunity for a new bug. A developer who later adds a new error handler to the end of the routine may not notice that the code drops through the end of the routine. If the new error handler is added without a preceding Exit statement, the old error handler will continue into the new one. If the following code encounters an invalid date, it presents the user with two error messages instead of one.


<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2 BGCOLOR=#C0FFFF>
<TR><TD>
<TT><PRE>InvalidDate:
    <B>' It's an invalid date string. Tell the user and leave.</B>
    MsgBox "The start date """ & _
        date_string & _
        """ is invalid. Please enter a new one."

ReadFileError:
    <B>' Error reading the data file.</B>
    MsgBox "Error reading the data."
        :
End Sub</PRE></TT>
</TD></TR>
</TABLE>


To prevent this kind of mistake, do not allow an error handler to continue to the routine's End statement. Use an Exit statement to leave the routine instead.

<H4>Err.Raise</H4>

The Err object provides a Raise method that allows a program to generate errors. It can create new errors or reraise old ones. The syntax for the Raise method is


<TT><PRE>Err.Raise Number, [Source], [Description], [Helpfile], [Helpcontext]</PRE></TT>


<DL>
<DT><B>Number</B>
<DD>The error number. To create a new error code in a class module, add vbObjectError to your number. For example, vbObjectError + 1001.

<DT><B>Source</B>
<DD>The name of the object or application generating the error. For objects, use the format Project.Class. For routines, use the format Project.Routine. For example, MyProgram.LoadData.

<DT><B>Description</B>
<DD>A string describing the error. If you set Number to a standard Visual Basic error code like 9 for subscript out of range, you can omit Description to make Visual Basic use a standard description string.

<DT><B>Helpfile</B>
<DD>The full name of a help file that gives more information on the error.

<DT><B>Helpcontext</B>
<DD>The context ID for this error's topic in the help file.
</DL>

If a routine cannot handle an error itself, it should raise a new error that makes sense within its context. For example, the following routine attempts to read a data file. If the file is not found, the FileOpenError error handler raises the myappErrNoInputFile error. This gives the calling subroutine more information than Visual Basic's initial file not found error. The error Visual Basic generates indicates that some file was not found. The new error explains that an input data file was not found. The Err.Description field even includes the name of the file that was not found.


<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2 BGCOLOR=#C0FFFF>
<TR><TD>
<TT><PRE><B>' Define application error constants.</B>
Private Const myappErrNoInputFile = vbObjectError + 1000
    :
<B>' Define Visual Basic error constants.</B>
Private Const vbErrFileNotFound = 53
    :
Private Sub ReadInputData(ByVal file_name As String)
Dim file_number As Integer

    <B>' Open the file.</B>
    file_number = FreeFile
    On Error GoTo FileOpenError
    Open file_name For Input As file_number

    <B>' Process the file.</B>
    On Error GoTo FileReadError
        :
    <B>' Process the file here.</B>
        :
    <B>' Close the file.</B>
    Close file_number
    Exit Sub

FileOpenError:
    <B>' There was an error opening the file.</B>
    If Err.Number = vbErrFileNotFound Then
        <B>' It's a file not found error. Convert it</B>
        <B>' to myappErrNoInputFile.</B>
        Err.Raise myappErrNoInputFile, _
            "MyApp.ReadInputData", _
            "Could not open input file """ & _
                file_name & """."
    Else
        <B>' It's some other error. Reraise it so some</B>
        <B>' other routine can catch it.</B>
        Err.Raise Err.Number, _
            Err.Source, _
            Err.Description, _
            Err.HelpFile, _
            Err.HelpContext
    End If
    Exit Sub

FileReadError:
    <B>' There was an error reading the file.</B>
        :
    Exit Sub
End Sub</PRE></TT>
</TD></TR>
</TABLE>


A program could invoke this subroutine using code similar to the following. The error handler uses the information stored in the Err object by the Raise method to present a message to the user.


<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2 BGCOLOR=#C0FFFF>
<TR><TD>
<TT><PRE>    On Error GoTo DataInputError
    ReadInputData "c:\mydata.dat"
    Exit Sub

DataInputError:
    <B>' There was an error loading the data.</B>
    MsgBox "Error" & Str$(Err.Number) & _
        " loading the input data." & vbCrLf & _
        Err.Description</PRE></TT>
</TD></TR>
</TABLE>


Routines that present messages to users normally format the error information as shown in the previous code. To make that formatting as simple as possible, routines should not format the error description in the Raise statement. For example, the following code formats an error's description.


<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2 BGCOLOR=#C0FFFF>
<TR><TD>
<TT><PRE>Err.Raise myappErrNoInputFile, _
    "MyApp.ReadInputData", _
    "Error" & Str$(myappErrNoInputFile) & _
    " opening the input file."</PRE></TT>
</TD></TR>
</TABLE>


When this error occurs, the error handler that catches the error will probably display a message like this one:


<TT><PRE>    Error -2147220504 loading the input data.
    Error -2147220504 opening the input file.</PRE></TT>


Leave the formatting to the routine that actually records the error or presents the message to the user.

<A NAME=DefineErrorConstants>
<H3>Define Error Constants</H3>
Microsoft says normal error messages lie in the range of 1 to 65,535. They reserve the range 1 to 1000 for use by Visual Basic, and some of the values between 31,000 and 31,037 are already used by Visual Basic. You can use other values to define your own error codes.
<P>
Microsoft also recommends that you define new error constants for classes by adding a value to the constant vbObjectError as in the following code:
Private Const myclassErrNoInputFile = vbObjectError + 1000
If you follow these rules, your error codes will not overlap Microsoft's.
<P>
Unfortunately, this does not guarantee that your error code will not collide with other error constants defined by other developers or libraries you use.
One method for preventing confusion is to define a base value similar to vbObjectError for your constants. Then define error codes in terms of that constant. For example, a ray-tracing package might define error codes as in the following code:


<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2 BGCOLOR=#C0FFFF>
<TR><TD>
<TT><PRE>Public Const rayErrorBase = 45300
Public Const rayParametersNotSet = rayErrorBase + 1
Public Const rayInvalidSphereFormat = rayErrorBase + 2
Public Const rayLightAtEye = rayErrorBase + 3
    :</PRE></TT>
</TD></TR>
</TABLE>


If you later discover that your error codes collide with those of another developer or library, you can quickly redefine all of the error codes by changing the error base value.

<A NAME=KeepErrorHandlersSeparate>
<H3>Keep Error Handlers Separate</H3>
</A>
End every error handler with Resume, Resume Next, Exit Sub/Function/Property, End Sub/Function/Property, or Err.Raise. Never allow the code to fall through from one error handler into another. This can produce some clever code, but it can produce confusion as well.
<P>
For example, the following code falls through its error handlers to close the file it has opened.


<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2 BGCOLOR=#C0FFFF>
<TR><TD>
<TT><PRE>Private Sub LoadData(ByVal filename As String)
Dim fnum As Integer

    <B>' The file is not yet open.</B>
    On Error GoTo FileIsClosed

    <B>' Open the file.</B>
    fnum = FreeFile
    Open filename For Input As fnum

    <B>' The file is now open.</B>
    On Error GoTo FileIsOpen

    <B>' Read the data.</B>
        :

    <B>' Fall into the error handlers to close the file.</B>
    On Error Resume Next

FileIsOpen:
    <B>' Close the file.</B>
    Close fnum

FileIsClosed:
    <B>' Perform any final tasks.</B>
        :

    <B>' Fall through to the End Sub.</B>
End Sub</PRE></TT>
</TD></TR>
</TABLE>


This code has a number of problems. First, it is confusing. Another developer who tries to add a new error handler would be likely to make a mistake and cause a bug. This code also does not signal its errors. Instead, it quietly continues as if nothing has gone wrong. It hides bugs that might otherwise be easy to fix.
Prevent confusion and possible bugs by keeping error handlers separate.

<A NAME=UnderstandErrorHandlerScope>
<H3>Understand Error Handler Scope</H3>
</A>
When a program encounters an error, Visual Basic checks to see if an error handler is presently installed in the current routine. If so, control passes to that error handler.
<P>
If no error handler is in effect, Visual Basic moves up the call stack to the calling routine to see if an error handler is currently installed there. If so, the system resumes execution at that error handler.
<P>
If no error handler is installed in the calling routine either, Visual Basic continues moving up the call stack until it finds a routine with an error handler installed. If it runs off the top of the stack before it finds an active error handler, the program crashes.
<P>
Execution of all Visual Basic code begins with either an event handler or the Main subroutine. That means you can guard against almost all errors if you place error handlers in every event handler and the Main subroutine (if the program uses one). Then, no matter where the program encounters an error, control eventually passes up through the call stack to the event handler or Main subroutine that started the code. The error handler installed at that point can handle the error.

<A NAME=DontNestErrorHandlers>
<H3>Don't Nest Error Handlers</H3>
</A>
Error handler code runs a little differently from other code. No other error handler can be active within another error handler's code. In other words, an error handler cannot use On Error GoTo to define an error handler to catch its mistakes. If an error handler uses On Error GoTo, the new error handler only takes effect when the error handler finishes and returns control to the main code sequence.
<P>
This sort of thing can be very confusing. If Subroutine2 raises an error in the following code, it is not clear whether control passes to the Error1 or Error2 error handler. Control passes to Error1 if Subroutine1 ran correctly, but it passes to Error2 if Subroutine1 also generated an error.


<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2 BGCOLOR=#C0FFFF>
<TR><TD>
<TT><PRE>    On Error GoTo Error1
    Subroutine1
    Subroutine2
    Exit Sub

Error1:
    On Error GoTo Error2
    MsgBox "Error1:" & Str$(Err.Number) & "." & vbCrLf & _
        Err.Description
    Resume Next

Error2:
    MsgBox "Error2:" & Str$(Err.Number) & "." & vbCrLf & _
        Err.Description
    Resume Next</PRE></TT>
</TD></TR>
</TABLE>


Avoid this confusion by not using On Error statements within error handler code. Keep all On Error statements in the main code sequence.
<P>
(This ends approximately the first half of Chapter 12, Error Handling Fundamentals)
<P>



<A NAME=ErrTalk>
<H3>Error Handling Slides</H3>
</A>

<A HREF=errtalk.zip>Click here</A> to download a zip file containing Powerpoint slides used for a talk to the Denver Area Visual Basic User's Group Lab meeting on March 15, 1999.
<P>



<TABLE WIDTH=100% CELLPADDING=0 CELLSPACING=0 BGCOLOR=#00D9FF>
	<TR><TD WIDTH=100%>
			<FONT SIZE=-1>
			This material originally appeared in the book <I>Bug Proofing
			Visual Basic</I> by Rod Stephens, 1998, John Wiley & Sons.
			If you like the article, visit the books's
			<A HREF=err.htm>Web page</A> to learn more. 
			</FONT>
	</TD></TR>
</TABLE>


<!-- END PAGE CONTENTS -->
		</TD></TR>
	</TABLE> <!-- End content panel -->
	</TD></TR>
</TABLE> <!-- End Main Page Table -->

<HR>

<!-- Copyright Information Table -->
<TABLE WIDTH=100% CELLPADDING=0 CELLSPACING=0>
	<TR>

	<!-- Empty left column -->
	<TD WIDTH=130>
	<TABLE WIDTH=130 CELLPADDING=0 CELLSPACING=0>
		<TR><TD><B>&nbsp;</TD></TR>
	</TABLE>
	</TD>

	<!-- Copyright information -->
	<TD WIDTH=100% VALIGN=Top>
	<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH=100%>

		<!-- Begin mailing list Code -->
<TABLE BORDER="0" CELLPADDING="5" CELLSPACING="0" BGCOLOR="#00C0FF">
  <TR><TD><A HREF="newsletter.html">Subscribe to the VB Helper newsletter</A></TD></TR>
</TABLE>
		<!-- End mailing list Code -->

		<TR>
		<TD COLSPAN=2 ALIGN=Center><FONT SIZE="-2">
		Copyright &copy; 1997-2001 Rocky Mountain Computer Consulting, Inc.
		&nbsp; All rights reserved.
		</TD></TR>
		<TD ALIGN=Left><FONT SIZE="-2">www.vb-helper.com/tut6.htm</TD>
		<TD ALIGN=Right><FONT SIZE="-2">Updated 

		<SCRIPT LANGUAGE=JavaScript>
		    document.write(document.lastModified)
		</SCRIPT>

		</TD>
		</TR>
	</TABLE>
	</TD></TR>
</TABLE> <!-- End Copyright Information Table -->

</BODY>
</HTML>











