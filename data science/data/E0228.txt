ID=E0228
URL=http://www.gotw.ca/gotw/070.htm
SIZE=41245
DATE=12/07/02
TIME=19:18:56
DATASET=C
HTML=
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta http-equiv="Content-Language" content="en-us">


<title>GotW #70: Encapsulation</title>
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<link rel="stylesheet" type="text/css" href="../gotw.css">
<meta name="Microsoft Theme" content="gotw 111, default">
<meta name="Microsoft Border" content="tlb, default">
</head>

<body background="../_themes/gotw/glabkgnd.jpg" bgcolor="#CCFFFF" text="#000000" link="#008080" vlink="#008080" alink="#0000FF"  ><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font><table border="0" cellspacing="0" width="100%">
  <tr>
    <td colspan="2"><!--mstheme--><font face="Arial, Arial, Helvetica"><font size="6"><strong>
    GotW #70</strong></font> <!--mstheme--></font></td>
  </tr>
  <tr>
    <td valign="middle"><!--mstheme--><font face="Arial, Arial, Helvetica">




<p align="left" style="margin-top: 0; margin-bottom: 0">

<script language="JavaScript"><!--
MSFPhover = 
  (((navigator.appName == "Netscape") && 
  (parseInt(navigator.appVersion) >= 3 )) || 
  ((navigator.appName == "Microsoft Internet Explorer") && 
  (parseInt(navigator.appVersion) >= 4 ))); 
function MSFPpreload(img) 
{
  var a=new Image(); a.src=img; return a; 
}
// --></script><script language="JavaScript"><!--
if(MSFPhover) { MSFPnav1n=MSFPpreload("../_derived/home_cmp_gotw110_hbtn.gif"); MSFPnav1h=MSFPpreload("../_derived/home_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav1'].src=MSFPnav1h.src" onmouseout="if(MSFPhover) document['MSFPnav1'].src=MSFPnav1n.src"><img src="../_derived/home_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Home" align="middle" name="MSFPnav1"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav2n=MSFPpreload("../_derived/news.htm_cmp_gotw110_hbtn.gif"); MSFPnav2h=MSFPpreload("../_derived/news.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../news.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav2'].src=MSFPnav2h.src" onmouseout="if(MSFPhover) document['MSFPnav2'].src=MSFPnav2n.src"><img src="../_derived/news.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="News &amp; Events" align="middle" name="MSFPnav2"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav3n=MSFPpreload("../resources/_derived/index.htm_cmp_gotw110_hbtn.gif"); MSFPnav3h=MSFPpreload("../resources/_derived/index.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../resources/index.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav3'].src=MSFPnav3h.src" onmouseout="if(MSFPhover) document['MSFPnav3'].src=MSFPnav3n.src"><img src="../resources/_derived/index.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Community Resources" align="middle" name="MSFPnav3"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav4n=MSFPpreload("../_derived/consulting.htm_cmp_gotw110_hbtn.gif"); MSFPnav4h=MSFPpreload("../_derived/consulting.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../consulting.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav4'].src=MSFPnav4h.src" onmouseout="if(MSFPhover) document['MSFPnav4'].src=MSFPnav4n.src"><img src="../_derived/consulting.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Consulting Services" align="middle" name="MSFPnav4"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav5n=MSFPpreload("../_derived/presentations.htm_cmp_gotw110_hbtn.gif"); MSFPnav5h=MSFPpreload("../_derived/presentations.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../presentations.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav5'].src=MSFPnav5h.src" onmouseout="if(MSFPhover) document['MSFPnav5'].src=MSFPnav5n.src"><img src="../_derived/presentations.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Presentations" align="middle" name="MSFPnav5"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav6n=MSFPpreload("../publications/_derived/index.htm_cmp_gotw110_hbtn.gif"); MSFPnav6h=MSFPpreload("../publications/_derived/index.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../publications/index.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav6'].src=MSFPnav6h.src" onmouseout="if(MSFPhover) document['MSFPnav6'].src=MSFPnav6n.src"><img src="../publications/_derived/index.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Publications" align="middle" name="MSFPnav6"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav7n=MSFPpreload("_derived/index.htm_cmp_gotw110_hbtn.gif"); MSFPnav7h=MSFPpreload("_derived/index.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="index.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav7'].src=MSFPnav7h.src" onmouseout="if(MSFPhover) document['MSFPnav7'].src=MSFPnav7n.src"><img src="_derived/index.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Guru of the Week" align="middle" name="MSFPnav7"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav8n=MSFPpreload("../conv/_derived/index.htm_cmp_gotw110_hbtn.gif"); MSFPnav8h=MSFPpreload("../conv/_derived/index.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../conv/index.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav8'].src=MSFPnav8h.src" onmouseout="if(MSFPhover) document['MSFPnav8'].src=MSFPnav8n.src"><img src="../conv/_derived/index.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Conversations" align="middle" name="MSFPnav8"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav9n=MSFPpreload("../_derived/search.htm_cmp_gotw110_hbtn.gif"); MSFPnav9h=MSFPpreload("../_derived/search.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../search.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav9'].src=MSFPnav9h.src" onmouseout="if(MSFPhover) document['MSFPnav9'].src=MSFPnav9n.src"><img src="../_derived/search.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Search GotW.ca" align="middle" name="MSFPnav9"></a>
</p>




    <!--mstheme--></font></td>
    <td valign="middle"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 0; margin-bottom: 0">
      <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav10n=MSFPpreload("../_derived/back_cmp_gotw110_back.gif"); MSFPnav10h=MSFPpreload("../_derived/back_cmp_gotw110_back_a.gif"); }
// --></script><a href="069.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav10'].src=MSFPnav10h.src" onmouseout="if(MSFPhover) document['MSFPnav10'].src=MSFPnav10n.src"><img src="../_derived/back_cmp_gotw110_back.gif" width="100" height="20" border="0" alt="Prev" name="MSFPnav10"></a><br><script language="JavaScript"><!--
if(MSFPhover) { MSFPnav11n=MSFPpreload("../_derived/up_cmp_gotw110_up.gif"); MSFPnav11h=MSFPpreload("../_derived/up_cmp_gotw110_up_a.gif"); }
// --></script><a href="index.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav11'].src=MSFPnav11h.src" onmouseout="if(MSFPhover) document['MSFPnav11'].src=MSFPnav11n.src"><img src="../_derived/up_cmp_gotw110_up.gif" width="100" height="20" border="0" alt="Up" name="MSFPnav11"></a><br><script language="JavaScript"><!--
if(MSFPhover) { MSFPnav12n=MSFPpreload("../_derived/next_cmp_gotw110_next.gif"); MSFPnav12h=MSFPpreload("../_derived/next_cmp_gotw110_next_a.gif"); }
// --></script><a href="071.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav12'].src=MSFPnav12h.src" onmouseout="if(MSFPhover) document['MSFPnav12'].src=MSFPnav12n.src"><img src="../_derived/next_cmp_gotw110_next.gif" width="100" height="20" border="0" alt="Next" name="MSFPnav12"></a><!--mstheme--></font></td>
  </tr>
  <tr>
    <td height="5" background="../images/bar.gif" colspan="2"><!--mstheme--><font face="Arial, Arial, Helvetica">&nbsp;<!--mstheme--></font></td>
  </tr>
</table><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font></td></tr><!--msnavigation--></table><!--msnavigation--><table dir="ltr" border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td valign="top" width="1%"><!--mstheme--><font face="Arial, Arial, Helvetica">

<!--mstheme--></font><table border="0" cellspacing="0" bgcolor="#000000" cellpadding="0">
  <tr>
    <td><!--mstheme--><font face="Arial, Arial, Helvetica">
    <!--mstheme--></font><table border="0" cellpadding="2" cellspacing="1" width="100%" height="483">
        <tr>
          <td align="center" bgcolor="#000000" colspan="2" height="16"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin-top: 0; margin-bottom: 0"><a href="../news.htm"><b><font color="#FFFF00">News</font></b></a><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="center" bgcolor="#CCCCCC" bordercolor="#CCCCCC" rowspan="3"><!--mstheme--><font face="Arial, Arial, Helvetica">
          <font size="1" color="#0000FF">J<br>
          U<br>
          L<br>
          Y</font><!--mstheme--></font></td>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin-left: 3; margin-right: 3; margin-top: 0" align="center"><font size="1" color="#0000FF">
            Print articles newly available online</font><!--mstheme--></font><table border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%" id="AutoNumber1" bgcolor="#FFFFCC" bordercolordark="#006666" bordercolorlight="#99CCCC">
              <tr>
                <td width="100%" bordercolor="#808000"><!--mstheme--><font face="Arial, Arial, Helvetica">
                <p style="margin: 3"><font size="1" color="#0000FF">
                <a href="../publications/mill20.htm"><b><i>
                <font color="#0000FF">Sutter's Mill</font></i></b><font color="#0000FF"> 
                column, &quot;Toward a Standard C++ Library, Part 1&quot;</font></a></font><!--mstheme--></font></td>
              </tr>
              <tr>
                <td width="100%" bordercolor="#808000" bgcolor="#FFFFCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
                <p style="margin: 3"><font size="1" color="#0000FF">
                <a href="../publications/mxc++-item-4.htm">
                <font color="#0000FF">Excerpt from MXC++, &quot;Extensible Templates: 
                Via Inheritance or Traits?&quot;</font></a></font><!--mstheme--></font></td>
              </tr>
              <tr>
                <td width="100%" bordercolor="#808000"><!--mstheme--><font face="Arial, Arial, Helvetica">
                <p style="margin: 3"><font size="1" color="#0000FF">
                <a href="../publications/mcd_review.htm"><font color="#0000FF">
                Book Review: Modern C++ Design</font></a></font><!--mstheme--></font></td>
              </tr>
              <tr>
                <td width="100%" bordercolor="#808000"><!--mstheme--><font face="Arial, Arial, Helvetica">
                <p style="margin: 3"><font size="1" color="#0000FF">
                <a href="../publications/mill21.htm"><b><i>
                <font color="#0000FF">Sutter's Mill</font></i></b><font color="#0000FF"> 
                column, &quot;Toward a Standard C++ Library, Part 2: Namespaceops and 
                Library Versioning&quot;</font></a></font><!--mstheme--></font></td>
              </tr>
            </table><!--mstheme--><font face="Arial, Arial, Helvetica">
          <!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin: 0 3"><font size="1" color="#0000FF"><b><i>Sutter's 
            Mill</i></b> column,
            &quot;A Pragmatic Look at Exception Specifications&quot;<br>
            </font><font size="1" color="#000080">The usefulness, or lack 
            thereof, of exception specifications, and how results can vary 
            across real-world compilers</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin: 0 3">
            <a target="_blank" href="http://www.cuj.com/experts/2007/hyslop.htm"><font size="1" color="#0000FF"><i><b>Conversations</b></i> column,
            &quot;Getting to the Point&quot;</font></a><font color="#0000FF" size="1"><br>
            </font><font size="1" color="#000080">The Boost library has five 
            smart pointers that provide a rich array [sic] of useful behaviors.</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="center" bgcolor="#CCCCCC" bordercolor="#CCCCCC" rowspan="2"><!--mstheme--><font face="Arial, Arial, Helvetica"><font color="#0000FF" size="1">A<br>
            U<br>
          G<br>
          U<br>
          S<br>
          T</font><!--mstheme--></font></td>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin:0 3; ">
            <a target="_blank" href="http://www.cuj.com/experts/2008/sutter.htm"><i><b><font size="1" color="#0000FF">The New C++</font></b></i> <font size="1" color="#0000FF">
            column, &quot;Smart(er) Pointers&quot;</font></a><font size="1" color="#000080"><br>
            A closer look at one of the proposed new standard C++ library 
            features -- smart pointers, particularly those in Boost and Loki, 
            and a sneak peek at the usefulness of the proposed typedef templates</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
          <p style="margin:0 3; ">
          <a target="_blank" href="http://www.cuj.com/experts/2008/hyslop.htm"><font size="1" color="#0000FF"><i><b>Conversations</b></i> column,
            &quot;A Midsummer Night's Madness&quot;</font></a><font color="#0000FF" size="1"><br>
            </font><font size="1" color="#000080">A brew that mixes pointers, 
          typedefs, and const</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="center" bgcolor="#CCCCCC" bordercolor="#CCCCCC" rowspan="3"><!--mstheme--><font face="Arial, Arial, Helvetica">
          <p style="margin-top: 0; margin-bottom: 0">
          <font size="1" color="#0000FF">S<br>
          E<br>
          P<br>
          T<br>
          E<br>
          M<br>
          B<br>
          E<br>
          R</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin: 0 3">
            <font size="1" color="#0000FF">&quot;Standard C++ Meets Managed C++&quot;<br>
            </font><font size="1" color="#000080">A survey of the main (in)compatibilities 
            between Standard C++ and Microsoft’s managed extensions for C++, and 
            how the two could converge</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin: 0 3"><font size="1" color="#0000FF"><b><i>Sutter's 
            Mill</i></b> column,
            &quot;Export Restrictions, Part 1&quot;<br>
            </font><font size="1" color="#000080">The scoop on export -- what 
            some people think it does, what it actually does, and why it’s the 
            most widely-ignored feature in the C++ standard</font><!--mstheme--></font></td>
        </tr>
      </table><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font></td>
  </tr>
</table><!--mstheme--><font face="Arial, Arial, Helvetica">
<p style="margin-top: 0; margin-bottom: 0">
<img border="0" src="../images/140.gif" width="140" height="1"></p>

<!--mstheme--></font></td><td valign="top" width="24"></td><!--msnavigation--><td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <h2><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Encapsulation&nbsp;<font size="3"><br>
      Difficulty: 4 / 10</font><!--mstheme--></font></h2>
<p><i>What exactly is encapsulation as it applies to C++ programming? What does
proper encapsulation and access control mean for member data -- should it ever
be public or protected? This issue focuses on alternative answers to these
questions, and shows how those answers can increase either the robustness or the
fragility of your code.</i></p>
<p align="center"><img border="0" src="../images/h-line.gif" width="248" height="2"></p>

<h3><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Problem<!--mstheme--></font></h3>

<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">JG Question<!--mstheme--></font></h4>
<p><b><font size="4">1.</font></b>   What does &quot;encapsulation&quot; mean?
How important is it to object- oriented design and programming?</p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Guru Questions<!--mstheme--></font></h4>
<p><b><font size="4">2.</font></b>   Under what circumstances, if any, should
nonstatic class data members be made public, protected, and private? Express
your answer as a coding standard guideline.</p>
<p><b><font size="4">3.</font></b>   The std::pair class template uses public
data members because it is not an encapsulated class but only a simple way of
grouping data. Imagine a class template that is like std::pair but which
additionally provides a deleted flag, which can be set and queried but cannot be
unset. Clearly the flag itself must be private so as to prevent users from
unsetting it directly. If we choose to keep the other data members public, as
they are in std::pair, we end up with something like the following:</p>
<blockquote>
  <p><font face="Courier New">template&lt;class T, class U&gt;<br>
  class Couple<br>
  {<br>
  public:<br>
  &nbsp; // The main data members are public...<br>
  &nbsp; //<br>
  &nbsp; T first;<br>
  &nbsp; U second;<br>
  <br>
  &nbsp; // ... but there is still classlike machinery<br>
  &nbsp; // and private implementation.<br>
  &nbsp; //<br>
  &nbsp; Couple() : deleted_(false) {}<br>
  &nbsp; void MarkDeleted() { deleted_ = true; }<br>
  &nbsp; bool IsDeleted() { return deleted_; }<br>
  private:<br>
  &nbsp; bool deleted_;<br>
  };</font></p>
</blockquote>
<p>Should the other data members still be public, as shown above? Why or why
not? If so, is this a good example of why mixing public and private data in the
same class might sometimes be good design?</p>
<p align="center"><img border="0" src="../images/h-line.gif" width="248" height="2"></p>
<h3><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666"><a name="Solution"></a>Solution<!--mstheme--></font></h3>

<p><font color="#999933"><b><font size="4">1.</font></b>   What does
&quot;encapsulation&quot; mean?</font></p>
<p>According to Webster's Third New International Dictionary:</p>
<blockquote>
  <p><b>en-cap-su-late</b> vt: to surround, encase, or protect in or as if in a
  capsule</p>
</blockquote>
<p>Encapsulation in programming has precisely the same sense: To protect the
internal implementation of a class by hiding those internals behind a
surrounding and encasing interface visible to the outside world.</p>
<p>The definition of the word &quot;capsule,&quot; in turn, gives good guidance
as to what makes a good class interface:</p>
<blockquote>

<p><b>cap-sule</b> [F, fr. L /capsula/ small box, dim. of /capsa/ chest, case]<br>
1a: a membrane or saclike structure enclosing a part or organ ...<br>
2 : a closed container bearing spores or seeds ...<br>
4a: a gelatin shell enclosing medicine ...<br>
5 : a metal seal ...<br>
6 : ... envelope surrounding certain microscopic organisms ...<br>
9 : a small pressurized compartment for an aviator or astronaut ...</p>

</blockquote>
<p>Note the recurring theme in the words:</p>
<p>a) Surround, encase, enclose, envelope: A good class interface hides the
class's internals, presenting a &quot;face&quot; to the outside world that is
separate and distinct from the internals. Because a capsule surrounds exactly
one cohesive group of subobjects, its interface should likewise be cohesive --
its parts should be directly related.</p>
<p>The outer surface of a bacterium's capsule contains its means for sensing,
touching, and interacting with the outside world, and the outside world with it.
(Those means would be a lot less useful if they were inside.)</p>
<p>b) Closed, seal: A good class interface is complete, and does not expose any
internals. The interface acts as a hermetic seal, and often acts as a code
firewall (at compile time, runtime, or both) whereby outside code cannot depend
on class internals and changes to class internals therefore cause no impact on
outside code.</p>
<p>A bacterium whose capsule isn't closed won't live long; its internals will
quickly escape, and the organism will die.</p>
<p>c) Protect, shell: A good class interface protects the internals against
unauthorized access and manipulation. In particular, a primary job of the
interface is to ensure that all access to and manipulation of internal
structures is guaranteed to preserve class invariants.</p>
<p>The principal methods for killing bacteria (and humans) involve fashioning
devices to break outer and/or inner capsules. On the micro level, these include
chemicals, enzymes, or organisms (and possibly eventual nanomachines)
responsible capable of making appropriate holes. On the macro level, knives and
guns are perennial favorites, and many well-funded lobby groups encourage the
&quot;right and duty&quot; to bear capsule-breaching armaments even of types
useful only against Kevlar-encapsulated humans of the police variety, on the
theory that deer may someday take the anticompetitive action of donning
bulletproof vests.</p>
<p>[See United States v. United Antlered Wildlife (UAW) Oregon Local 507, a
landmark Department of Justice deer antitrust case currently under appeal. If
the DoJ succeeds, the UAW will be divided into two specialized groups, one for
soup and one for hunting trophies, neither of which will be permitted to wear
vests or initiate other anticompetitive practices. Mr. H. Eston, prominent
leader of pro-personal-ICBM group People for the Eating of Tasty Animals (PETA)
announced support for the sanctions, stating that hunters have a constitutional
right not to have to cope with prey that might defend itself. In related news,
in a move apparently designed to defend against accusations of trademark
infringement, UAW has just announced that it will soon ship to its members vests
made of Protect# (pronounced &quot;Protect- Sharp&quot;) which it judiciously
describes without using the name &quot;Kevlar&quot; or the letter
&quot;K.&quot;]</p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Encapsulation's Place in OO<!--mstheme--></font></h4>
<p><font color="#999933">How important is it to object- oriented design and
programming?</font></p>
<p>Encapsulation is the prime concept in object-oriented programming. Period.</p>
<p>Other OO techniques -- such as data hiding, inheritance, and polymorphism --
are important principally because they support special cases of encapsulation.
For example, encapsulation nearly always implies data hiding; runtime
polymorphism using virtual functions more completely separates the interface
(provided by a base class) from the implementation (provided by the derived
class, which need not even exist at the time that the code which will eventually
use it is written); compile-time polymorphism using templates completely
divorces interface from implementation, as any class having the required
operations can be used interchangeably without requiring any inheritance or
other relationship. Encapsulation is not always data hiding, but data hiding is
always a form of encapsulation. Encapsulation is not always polymorphism, but
polymorphism is always a form of encapsulation.</p>
<p>Object-orientation is often defined as:</p>
<blockquote>
  <p>the bundling together of data and the functions that operate on that data.</p>
</blockquote>
<p>That definition is true to a point -- it excludes nonmember functions that
are also logically part of a class, such as operator&lt;&lt;() in C++ -- and it
stresses high cohesion. It does not, however, adequately emphasize the other
essential element of object-orientation, namely:</p>
<blockquote>
  <p>the simultaneous separation of data from calling code through an interface
  of functions that operate on that data.</p>
</blockquote>
<p>This complementary aspect stresses low coupling, and that the purpose of the
assembled functions is to form a protective interface.</p>
<p>In short, object-orientation is all about separating interfaces from
implementation in a way that promotes high cohesion and low coupling -- both of
which have been known to be sound software engineering goals since long before
objects were invented. These concepts address dependency management, which is
one of the key concepts in modern software engineering, especially for large
systems.<b><a href="#1"><sup>[1]</sup></a></b> <b><sup><a href="#2">[2]</a></sup></b></p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Public, Protected, or Private Data?<!--mstheme--></font></h4>
<p><font color="#999933"><b><font size="4">2.</font></b>   Under what
circumstances, if any, should nonstatic class data members be made public,
protected, and private? Express your answer as a coding standard guideline.</font></p>
<p>Normally we first look at the rule, then at the exception. This time, let's
do things the other way around and consider the exception first.</p>
<p>The only exception to the general rule that follows is the case when all
class members (both functions and data) are public, as with a C-style struct. In
this case the &quot;class&quot; isn't really a full-fledged class with its
interface, behavior, and invariants -- it's not even a half-fledged class; it's
just a bundle-o-data. The &quot;class&quot; is merely a convenient bundling of
objects, and that's fine, especially for backward compatibility with C programs
that manipulate C-style structs.</p>
<p>Other than that special case, however, data members should always be private.</p>
<p>Public data is a breach of encapsulation because it permits calling code to
manipulate the object's internals directly. This implies a high level of trust!
After all, in real life, most other people don't get to manipulate my internals
directly (e.g., by operating directly on my stomach) because they might then
easily and unintentionally do the wrong thing; at best, they only get to
manipulate my internals indirectly by going through my public interface with my
knowledge and consent (e.g., by handing me a bottle labeled &quot;Drink Me&quot;
which I will then decide to drink, or shampoo my hair with, or wash my car with,
according to my own feelings and judgment). Of course, some people really are
qualified to manipulate my internals directly (e.g., a surgeon), but even then:
a) it's rare; and b) I get to elect whether or not to have the surgery, and if
so in which surgeon I will declare the requisite high level of trust.</p>
<p>Similarly, most calling code shouldn't ever manipulate a class's internals
directly (e.g., by viewing or changing member data) because they may quite
easily and unintentionally do the wrong thing; at best, they only get to
manipulate the class's internals indirectly by going through the class's public
interface with the class's knowledge and consent (e.g., by handing a
Bottle(&quot;Drink Me&quot;) object to a public member function, which will then
decide what, if anything, to do with the object according to the class author's
own feelings and judgment). Of course, some nonmember code may really be
qualified to manipulate a class's internals directly (usually such code should
be a member function, but for example operator&lt;&lt;() cannot be a member),
but even then: a) it's rare; and b) the class gets to elect what such outside
code will be declared a &quot;friend&quot; with that declaration's attendant
high level of trust.</p>
<p>In short, public data is evil (except only for C-style structs).</p>
<p>Likewise, in short, protected data is evil (this time with no exceptions).
Why is it evil? Because the same argument above applies to protected data, which
is part of an interface too -- the protected interface, which is still an
interface to outside code, just a smaller set of outside code, namely the code
in derived classes. Why is there no exception? Because protected data is never
just a bundle-o-data; if it were, it could only be used as such by derived
classes, and since when do you use additional instances of one of your base
classes as a convenient bundle-o-data? That would be bizarre. For most on the
history of why protected data was originally permitted, and why even the person
who campaigned for it now agrees it was a bad idea, see Stroustrup's <i>The
Design and Evolution of C++.</i><b><a href="#3"><sup>[3]</sup></a></b></p>
<p>From the GotW coding standards:</p>
<blockquote>
  <p>- encapsulation and insulation:</p>
  <blockquote>
    <p>- always keep class data members private (Lakos96: 65-69; Meyers92:
    71-72; Murray93: 33-36)</p>
    <blockquote>
      <p>- except for the special case where all class members are public (e.g.,
      C-style struct)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Related guidelines include:</p>
<blockquote>
  <p>- encapsulation and insulation:</p>
  <blockquote>
    <p>- avoid returning 'handles' to internal data, especially from const
    member functions (Meyers92: 96-99)</p>
    <p>- where reasonable, avoid showing private members of a class in its
    declaration: use the Pimpl Idiom</p>
  </blockquote>
  <p>- programming style:</p>
  <blockquote>
    <p>- never subvert the language; for example, never attempt to break
    encapsulation by copying a class definition and adding a friend declaration,
    or by providing a local instantiation of a template member function</p>
  </blockquote>
  <p>- design style:</p>
  <blockquote>
    <p>- prefer cohesion:</p>
    <blockquote>
      <p>- prefer to follow the &quot;one class, one responsibility&quot;
      principle</p>
      <p>- prefer to give each piece of code (e.g., each module, each class,
      each function) a single well-defined responsibility (Items 10, 12, 19, and
      23)</p>
    </blockquote>
  </blockquote>
</blockquote>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">A General Transformation<!--mstheme--></font></h4>
<p>Now let's prove the &quot;member data should always be private&quot;
guideline by assuming the opposite (that public/protect member data can be
appropriate) and showing that in every such case the data should not in fact be
public/protected at all.</p>
<blockquote>

<p><font face="Courier New">// Example 2(a): Nonprivate data (evil)<br>
//<br>
class X<br>
{<br>
&nbsp; // ...<br>
public:<br>
&nbsp; T1 t1_;<br>
protected:<br>
&nbsp; T2 t2_;<br>
};</font></p>

</blockquote>

<p>First, we note that this can always be transformed, without loss of either
generality or efficiency, to:</p>

<blockquote>

<p><font face="Courier New">// Example 2(b): Encapsulated data (good)<br>
//<br>
class X<br>
{<br>
&nbsp; // ...<br>
public:<br>
&nbsp; T1&amp; UseT1() { return t1_; }<br>
protected:<br>
&nbsp; T2&amp; UseT2() { return t2_; }<br>
private:<br>
&nbsp; T1 t1_;<br>
&nbsp; T2 t2_;<br>
};</font></p>

</blockquote>
<p>Therefore even if there's a reason to allow direct access to t1_ or t2_,
there exists a simple transformation that causes the access to be performed
through a(n initially inline) member function. Examples 2(a) and 2(b) are
equivalent. But is there any benefit to using the method in Example 2(a)?</p>
<p>To prove that Example 2(a) should never be used, all that remains is to show
that that:</p>
<blockquote>
  <p>1. Example 2(a) has no advantages not present in Example 2(b);</p>
  <p>2. Example 2(b) has concrete advantages; and</p>
  <p>3. Example 2(b) costs nothing.</p>
</blockquote>
<p>Taking them in reverse order:</p>
<p>Point 3 is trivial to show. The inline function, which returns by reference
and hence incurs no copying cost, will probably be optimized away entirely by
the compiler.</p>
<p>Point 2 is easy: Just look at the source dependencies. In Example 2(a), all
calling code that uses t1_ and/or t2_ mentions them explicitly by name; in
Example 2(b), all calling code that uses t1_ or t2_ mentions only the names of
the functions UseT1() and UseT2(). Example 2(a) is rigid, because any change to
t1_ or t2_ (e.g., removing them and replacing them with something else, or just
tacking on some instrumentation) requires all calling code to be changed to
suit. In Example 2(b), however, instrumentation can be added, and t1_ and/or t2_
can even be removed entirely, without any change to calling code, because the
member function completes the class's interface and &quot;surrounds,&quot;
&quot;seals,&quot; and &quot;protects&quot; the internals.</p>
<p>Finally, Point 1 is demonstrated by observing that anything that calling code
could do with t1_ or t2_ directly in Example 2(a) it can still do by using the
member accessor in Example 2(b). The caller may have to write an extra pair of
brackets, but that's it.</p>
<p>Let's consider a concrete example: Say you want to add some instrumentation,
perhaps something as simple as counting the number of accesses to t1_ or t2_. If
it's a data member, as in Example 2(a), here's what you have to do:</p>
<blockquote>
  <p>1. You create accessor functions that do what you want, and make the data
  private. (In other words, you do Example 2(b) anyway, only later as a
  retrofit.)</p>
  <p>2. All your users get to experience the joy of finding and changing every
  use of t1_ and t2_ in their code to the functional equivalent. This is just
  bound to cause rejoicing among a user community with pressing deadlines who
  already have other real work to do. Your users may thank you profusely and buy
  you gifts as a reward; don't open them if they're ticking.</p>
  <p>3. All your users recompile.</p>
  <p>4. The compile will break if they missed any instances; fix them by
  repeating steps 2 and 3 until done.</p>
</blockquote>
<p>If you already have simple accessor member functions, as in Example 2(b),
here's what you have to do:</p>
<blockquote>
  <p>1. You make the change inside the existing accessor functions.</p>
  <p>2. All your users relink (if the functions are in a separate .cpp and not
  inline), or at worst recompile (if the functions are in the header).</p>
</blockquote>
<p>The worst part is that, in real life, if you started with Example 2(a) you
may never even be allowed later to make the change to get to Example 2(b). The
more users there are that depend on an interface, the more difficult it is to
ever change the interface. This brings us to a law (not just a guideline):</p>
<blockquote>
  <p><i>Sutter's Law of Second Chances:</i></p>
  <p>The most important thing to get right is the interface. Everything else can
  be fixed later.</p>
  <p>Get the interface wrong, and you may never be allowed to fix it.</p>
</blockquote>
<p>Once an interface is in widespread use, there may be so many people who
depend on it that it becomes infeasible to change it. True, interfaces can
always be extended (added to instead of changed) without impacting anyone, but
just adding member functions doesn't help to fix existing parts that you later
decide were a bad idea -- at most it lets you add alternative ways of doing
things that will confuse your users, who will legitimately ask: &quot;But there
are two (or three, or N) ways of doing it... why? Which one do I use?&quot;</p>
<p>In short, a bad interface can be difficult or impossible to fix after the
fact. Do your best to get the interface right the first time, and make it
surround, seal, and protect its internals.</p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">A Case In Point<!--mstheme--></font></h4>
<p><font color="#999933"><b><font size="4">3.</font></b>   The std::pair class
template uses public data members because it is not an encapsulated class but
only a simple way of grouping data.</font></p>

<p>Note that the above is the exceptional valid use of public data. Even so,
std::pair would have been no worse off with accessors instead of public data.</p>

<p><font color="#999933">Imagine a class template that is like std::pair but
which additionally provides a deleted flag, which can be set and queried but
cannot be unset. Clearly the flag itself must be private so as to prevent users
from unsetting it directly. If we choose to keep the other data members public,
as they are in std::pair, we end up with something like the following:</font></p>
<blockquote>
  <p><font face="Courier New">// Example 3(a): Mixing public and private data?<br>
  //<br>
  </font><font face="Courier New" color="#999933">template&lt;class T, class
  U&gt;<br>
  class Couple<br>
  {<br>
  public:<br>
  &nbsp; // The main data members are public...<br>
  &nbsp; //<br>
  &nbsp; T first;<br>
  &nbsp; U second;<br>
  <br>
  &nbsp; // ... but there is still classlike machinery<br>
  &nbsp; // and private implementation.<br>
  &nbsp; //<br>
  &nbsp; Couple() : deleted_(false) {}<br>
  &nbsp; void MarkDeleted() { deleted_ = true; }<br>
  &nbsp; bool IsDeleted() { return deleted_; }<br>
  private:<br>
  &nbsp; bool deleted_;<br>
  };</font></p>
</blockquote>
<p><font color="#999933">Should the other data members still be public, as shown
above? Why or why not? If so, is this a good example of why mixing public and
private data in the same class might sometimes be good design?</font></p>
<p>This Couple class was proposed as a counterexample to the above coding
guidelines. It attempts to show a class that is &quot;mostly a struct&quot; but
has some private housekeeping data. The housekeeping data (here a simple
attribute) has an invariant. The claim is that updates to the attribute flag are
totally independent of updates to the Couple's values.</p>
<p>Let's start with the last statement: I don't buy it. The updates may be
independent, but the attribute is clearly not independent of the values, else it
wouldn't be grouped together cohesively with them. Of course the deleted_
attribute isn't independent of the accompanying objects -- it applies to them!</p>
<p>Note how, instead of mixing public and private data, we can model the
solution using accessors even if the accessors' initial implementation was to
give up references:</p>
<blockquote>
  <p><font face="Courier New">// Example 3(b): Proper encapsulation, initially<br>
  // with inline accessors. Later in life, these<br>
  // may grow into nontrivial functions if needed;<br>
  // if not, then not.<br>
  //<br>
  template&lt;class T, class U&gt;<br>
  class Couple<br>
  {<br>
  &nbsp; Couple() : deleted_(false) { }<br>
  &nbsp; T&amp; First()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { return
  first_;&nbsp;&nbsp; }<br>
  &nbsp; U&amp; Second()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { return
  second_;&nbsp; }<br>
  &nbsp; void MarkDeleted() { deleted_ = true; }<br>
  &nbsp; bool IsDeleted()&nbsp;&nbsp; { return deleted_; }<br>
  <br>
  private:<br>
  &nbsp; T first_;<br>
  &nbsp; U second_;<br>
  &nbsp; bool deleted_;<br>
  };</font></p>
</blockquote>
<p>&quot;Huh?&quot; someone might say. &quot;Why bother writing do-nothing
accessor functions?&quot; Answer: As described with Example 2(b) above. If today
calling code can change some aspect of this object (in this example, the
tagalong &quot;deleted_&quot; attribute), tomorrow you may well want to add new
features even if they do no more than add debugging information or add checks.
Example 3(b) lets you do that, and that flexibility doesn't cost you anything in
terms of efficiency because of the inline functions.</p>
<p>For example, say that one month in the future you decide that you want to
check all attempted accesses to an object marked deleted:</p>
<blockquote>
  <p>- In Example 3(a), you can't, period -- not without changing the design and
  requiring all code that uses first_ and second_ to be rewritten.</p>
  <p>- In Example 3(b), you simply put the check into the First() and Second()
  members. The change is transparent to all past and present users of Couple (at
  worst a recompile is needed; no code changes are needed).</p>
</blockquote>
<p>It turns out that Example 3(b) has other practical side benefits in the real
world. For example, as Nick Mein (nmein@trimble.co.nz) points out: &quot;You can
put a breakpoint (or whatever) in the accessor to find out just where and when
the value is being modified. This can be pretty helpful in tracking down a
bug.&quot;</p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Summary<!--mstheme--></font></h4>
<p>Except for the case of a C-style struct (all members public), all data
members should always be private. Doing otherwise violates all of the principles
of encapsulation noted at the start of this article, and creates dependencies on
the data names which makes it harder to later encapsulate them correctly. There
is never a good reason to write public or protected data members because they
can always be trivially wrapped in (at first) inline accessor functions at no
cost, so it's always right to do the right thing the first time.</p>
<p>Get your interfaces right first. Internals are easy enough to fix later, but
if you get the interface wrong you may never be allowed to fix it.</p>

<p>&nbsp;</p>

<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Notes<!--mstheme--></font></h4>
<p><a name="1"></a>1. Robert C. Martin. <b>Designing Object-Oriented
Applications Using the Booch Method</b> (Prentice-Hall, 1995).</p>
      <p><a name="2"></a>2. Various 1996 articles by Martin, especially those with
&quot;Principle&quot; in the title, at the <a target="_blank" href="http://www.objectmentor.com/publications/articlesByDate.html" target="_blank">ObjectMentor
      website</a>.</p>
<p><a name="3"></a>3. B. Stroustrup. <b>The Design and Evolution of C++</b>,
Section 13.9 (Addison-Wesley, 1994).</p>
<!--mstheme--></font><!--msnavigation--></td></tr><!--msnavigation--></table><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td><!--mstheme--><font face="Arial, Arial, Helvetica"><h4 align="right"><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666"><a href="../copyright.htm"><font size="2">Copyright ©
2002 Herb Sutter</font></a><!--mstheme--></font></h4>

<!--mstheme--></font></td></tr><!--msnavigation--></table></body>
</html>

