ID=E0328
URL=http://www.gotw.ca/gotw/068.htm
SIZE=37534
DATE=12/07/02
TIME=19:19:57
DATASET=C
HTML=
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta http-equiv="Content-Language" content="en-us">


<title>GotW #68: Flavors of Genericity</title>
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<link rel="stylesheet" type="text/css" href="../gotw.css">
<meta name="Microsoft Theme" content="gotw 111, default">
<meta name="Microsoft Border" content="tlb, default">
</head>

<body background="../_themes/gotw/glabkgnd.jpg" bgcolor="#CCFFFF" text="#000000" link="#008080" vlink="#008080" alink="#0000FF"  ><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font><table border="0" cellspacing="0" width="100%">
  <tr>
    <td colspan="2"><!--mstheme--><font face="Arial, Arial, Helvetica"><font size="6"><strong>
    GotW #68</strong></font> <!--mstheme--></font></td>
  </tr>
  <tr>
    <td valign="middle"><!--mstheme--><font face="Arial, Arial, Helvetica">




<p align="left" style="margin-top: 0; margin-bottom: 0">

<script language="JavaScript"><!--
MSFPhover = 
  (((navigator.appName == "Netscape") && 
  (parseInt(navigator.appVersion) >= 3 )) || 
  ((navigator.appName == "Microsoft Internet Explorer") && 
  (parseInt(navigator.appVersion) >= 4 ))); 
function MSFPpreload(img) 
{
  var a=new Image(); a.src=img; return a; 
}
// --></script><script language="JavaScript"><!--
if(MSFPhover) { MSFPnav1n=MSFPpreload("../_derived/home_cmp_gotw110_hbtn.gif"); MSFPnav1h=MSFPpreload("../_derived/home_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav1'].src=MSFPnav1h.src" onmouseout="if(MSFPhover) document['MSFPnav1'].src=MSFPnav1n.src"><img src="../_derived/home_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Home" align="middle" name="MSFPnav1"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav2n=MSFPpreload("../_derived/news.htm_cmp_gotw110_hbtn.gif"); MSFPnav2h=MSFPpreload("../_derived/news.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../news.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav2'].src=MSFPnav2h.src" onmouseout="if(MSFPhover) document['MSFPnav2'].src=MSFPnav2n.src"><img src="../_derived/news.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="News &amp; Events" align="middle" name="MSFPnav2"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav3n=MSFPpreload("../resources/_derived/index.htm_cmp_gotw110_hbtn.gif"); MSFPnav3h=MSFPpreload("../resources/_derived/index.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../resources/index.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav3'].src=MSFPnav3h.src" onmouseout="if(MSFPhover) document['MSFPnav3'].src=MSFPnav3n.src"><img src="../resources/_derived/index.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Community Resources" align="middle" name="MSFPnav3"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav4n=MSFPpreload("../_derived/consulting.htm_cmp_gotw110_hbtn.gif"); MSFPnav4h=MSFPpreload("../_derived/consulting.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../consulting.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav4'].src=MSFPnav4h.src" onmouseout="if(MSFPhover) document['MSFPnav4'].src=MSFPnav4n.src"><img src="../_derived/consulting.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Consulting Services" align="middle" name="MSFPnav4"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav5n=MSFPpreload("../_derived/presentations.htm_cmp_gotw110_hbtn.gif"); MSFPnav5h=MSFPpreload("../_derived/presentations.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../presentations.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav5'].src=MSFPnav5h.src" onmouseout="if(MSFPhover) document['MSFPnav5'].src=MSFPnav5n.src"><img src="../_derived/presentations.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Presentations" align="middle" name="MSFPnav5"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav6n=MSFPpreload("../publications/_derived/index.htm_cmp_gotw110_hbtn.gif"); MSFPnav6h=MSFPpreload("../publications/_derived/index.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../publications/index.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav6'].src=MSFPnav6h.src" onmouseout="if(MSFPhover) document['MSFPnav6'].src=MSFPnav6n.src"><img src="../publications/_derived/index.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Publications" align="middle" name="MSFPnav6"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav7n=MSFPpreload("_derived/index.htm_cmp_gotw110_hbtn.gif"); MSFPnav7h=MSFPpreload("_derived/index.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="index.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav7'].src=MSFPnav7h.src" onmouseout="if(MSFPhover) document['MSFPnav7'].src=MSFPnav7n.src"><img src="_derived/index.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Guru of the Week" align="middle" name="MSFPnav7"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav8n=MSFPpreload("../conv/_derived/index.htm_cmp_gotw110_hbtn.gif"); MSFPnav8h=MSFPpreload("../conv/_derived/index.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../conv/index.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav8'].src=MSFPnav8h.src" onmouseout="if(MSFPhover) document['MSFPnav8'].src=MSFPnav8n.src"><img src="../conv/_derived/index.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Conversations" align="middle" name="MSFPnav8"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav9n=MSFPpreload("../_derived/search.htm_cmp_gotw110_hbtn.gif"); MSFPnav9h=MSFPpreload("../_derived/search.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../search.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav9'].src=MSFPnav9h.src" onmouseout="if(MSFPhover) document['MSFPnav9'].src=MSFPnav9n.src"><img src="../_derived/search.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Search GotW.ca" align="middle" name="MSFPnav9"></a>
</p>




    <!--mstheme--></font></td>
    <td valign="middle"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 0; margin-bottom: 0">
      <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav10n=MSFPpreload("../_derived/back_cmp_gotw110_back.gif"); MSFPnav10h=MSFPpreload("../_derived/back_cmp_gotw110_back_a.gif"); }
// --></script><a href="067.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav10'].src=MSFPnav10h.src" onmouseout="if(MSFPhover) document['MSFPnav10'].src=MSFPnav10n.src"><img src="../_derived/back_cmp_gotw110_back.gif" width="100" height="20" border="0" alt="Prev" name="MSFPnav10"></a><br><script language="JavaScript"><!--
if(MSFPhover) { MSFPnav11n=MSFPpreload("../_derived/up_cmp_gotw110_up.gif"); MSFPnav11h=MSFPpreload("../_derived/up_cmp_gotw110_up_a.gif"); }
// --></script><a href="index.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav11'].src=MSFPnav11h.src" onmouseout="if(MSFPhover) document['MSFPnav11'].src=MSFPnav11n.src"><img src="../_derived/up_cmp_gotw110_up.gif" width="100" height="20" border="0" alt="Up" name="MSFPnav11"></a><br><script language="JavaScript"><!--
if(MSFPhover) { MSFPnav12n=MSFPpreload("../_derived/next_cmp_gotw110_next.gif"); MSFPnav12h=MSFPpreload("../_derived/next_cmp_gotw110_next_a.gif"); }
// --></script><a href="069.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav12'].src=MSFPnav12h.src" onmouseout="if(MSFPhover) document['MSFPnav12'].src=MSFPnav12n.src"><img src="../_derived/next_cmp_gotw110_next.gif" width="100" height="20" border="0" alt="Next" name="MSFPnav12"></a><!--mstheme--></font></td>
  </tr>
  <tr>
    <td height="5" background="../images/bar.gif" colspan="2"><!--mstheme--><font face="Arial, Arial, Helvetica">&nbsp;<!--mstheme--></font></td>
  </tr>
</table><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font></td></tr><!--msnavigation--></table><!--msnavigation--><table dir="ltr" border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td valign="top" width="1%"><!--mstheme--><font face="Arial, Arial, Helvetica">

<!--mstheme--></font><table border="0" cellspacing="0" bgcolor="#000000" cellpadding="0">
  <tr>
    <td><!--mstheme--><font face="Arial, Arial, Helvetica">
    <!--mstheme--></font><table border="0" cellpadding="2" cellspacing="1" width="100%" height="483">
        <tr>
          <td align="center" bgcolor="#000000" colspan="2" height="16"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin-top: 0; margin-bottom: 0"><a href="../news.htm"><b><font color="#FFFF00">News</font></b></a><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="center" bgcolor="#CCCCCC" bordercolor="#CCCCCC" rowspan="3"><!--mstheme--><font face="Arial, Arial, Helvetica">
          <font size="1" color="#0000FF">J<br>
          U<br>
          L<br>
          Y</font><!--mstheme--></font></td>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin-left: 3; margin-right: 3; margin-top: 0" align="center"><font size="1" color="#0000FF">
            Print articles newly available online</font><!--mstheme--></font><table border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%" id="AutoNumber1" bgcolor="#FFFFCC" bordercolordark="#006666" bordercolorlight="#99CCCC">
              <tr>
                <td width="100%" bordercolor="#808000"><!--mstheme--><font face="Arial, Arial, Helvetica">
                <p style="margin: 3"><font size="1" color="#0000FF">
                <a href="../publications/mill20.htm"><b><i>
                <font color="#0000FF">Sutter's Mill</font></i></b><font color="#0000FF"> 
                column, &quot;Toward a Standard C++ Library, Part 1&quot;</font></a></font><!--mstheme--></font></td>
              </tr>
              <tr>
                <td width="100%" bordercolor="#808000" bgcolor="#FFFFCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
                <p style="margin: 3"><font size="1" color="#0000FF">
                <a href="../publications/mxc++-item-4.htm">
                <font color="#0000FF">Excerpt from MXC++, &quot;Extensible Templates: 
                Via Inheritance or Traits?&quot;</font></a></font><!--mstheme--></font></td>
              </tr>
              <tr>
                <td width="100%" bordercolor="#808000"><!--mstheme--><font face="Arial, Arial, Helvetica">
                <p style="margin: 3"><font size="1" color="#0000FF">
                <a href="../publications/mcd_review.htm"><font color="#0000FF">
                Book Review: Modern C++ Design</font></a></font><!--mstheme--></font></td>
              </tr>
              <tr>
                <td width="100%" bordercolor="#808000"><!--mstheme--><font face="Arial, Arial, Helvetica">
                <p style="margin: 3"><font size="1" color="#0000FF">
                <a href="../publications/mill21.htm"><b><i>
                <font color="#0000FF">Sutter's Mill</font></i></b><font color="#0000FF"> 
                column, &quot;Toward a Standard C++ Library, Part 2: Namespaceops and 
                Library Versioning&quot;</font></a></font><!--mstheme--></font></td>
              </tr>
            </table><!--mstheme--><font face="Arial, Arial, Helvetica">
          <!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin: 0 3"><font size="1" color="#0000FF"><b><i>Sutter's 
            Mill</i></b> column,
            &quot;A Pragmatic Look at Exception Specifications&quot;<br>
            </font><font size="1" color="#000080">The usefulness, or lack 
            thereof, of exception specifications, and how results can vary 
            across real-world compilers</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin: 0 3">
            <a target="_blank" href="http://www.cuj.com/experts/2007/hyslop.htm"><font size="1" color="#0000FF"><i><b>Conversations</b></i> column,
            &quot;Getting to the Point&quot;</font></a><font color="#0000FF" size="1"><br>
            </font><font size="1" color="#000080">The Boost library has five 
            smart pointers that provide a rich array [sic] of useful behaviors.</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="center" bgcolor="#CCCCCC" bordercolor="#CCCCCC" rowspan="2"><!--mstheme--><font face="Arial, Arial, Helvetica"><font color="#0000FF" size="1">A<br>
            U<br>
          G<br>
          U<br>
          S<br>
          T</font><!--mstheme--></font></td>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin:0 3; ">
            <a target="_blank" href="http://www.cuj.com/experts/2008/sutter.htm"><i><b><font size="1" color="#0000FF">The New C++</font></b></i> <font size="1" color="#0000FF">
            column, &quot;Smart(er) Pointers&quot;</font></a><font size="1" color="#000080"><br>
            A closer look at one of the proposed new standard C++ library 
            features -- smart pointers, particularly those in Boost and Loki, 
            and a sneak peek at the usefulness of the proposed typedef templates</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
          <p style="margin:0 3; ">
          <a target="_blank" href="http://www.cuj.com/experts/2008/hyslop.htm"><font size="1" color="#0000FF"><i><b>Conversations</b></i> column,
            &quot;A Midsummer Night's Madness&quot;</font></a><font color="#0000FF" size="1"><br>
            </font><font size="1" color="#000080">A brew that mixes pointers, 
          typedefs, and const</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="center" bgcolor="#CCCCCC" bordercolor="#CCCCCC" rowspan="3"><!--mstheme--><font face="Arial, Arial, Helvetica">
          <p style="margin-top: 0; margin-bottom: 0">
          <font size="1" color="#0000FF">S<br>
          E<br>
          P<br>
          T<br>
          E<br>
          M<br>
          B<br>
          E<br>
          R</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin: 0 3">
            <font size="1" color="#0000FF">&quot;Standard C++ Meets Managed C++&quot;<br>
            </font><font size="1" color="#000080">A survey of the main (in)compatibilities 
            between Standard C++ and Microsoft’s managed extensions for C++, and 
            how the two could converge</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin: 0 3"><font size="1" color="#0000FF"><b><i>Sutter's 
            Mill</i></b> column,
            &quot;Export Restrictions, Part 1&quot;<br>
            </font><font size="1" color="#000080">The scoop on export -- what 
            some people think it does, what it actually does, and why it’s the 
            most widely-ignored feature in the C++ standard</font><!--mstheme--></font></td>
        </tr>
      </table><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font></td>
  </tr>
</table><!--mstheme--><font face="Arial, Arial, Helvetica">
<p style="margin-top: 0; margin-bottom: 0">
<img border="0" src="../images/140.gif" width="140" height="1"></p>

<!--mstheme--></font></td><td valign="top" width="24"></td><!--msnavigation--><td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <h2><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Flavors of Genericity&nbsp;<font size="3"><br>
      Difficulty: 7 / 10</font><!--mstheme--></font></h2>
<p><i>How generic is a generic function, really? The answer can depend as much
on its implementation as on its interface, and a perfectly generalized interface
can be hobbled by simple -- and awkward-to-diagnose -- programming lapses.</i></p>
<p align="center"><img border="0" src="../images/h-line.gif" width="248" height="2"></p>

<h3><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Problem<!--mstheme--></font></h3>

<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">JG Question<!--mstheme--></font></h4>
<p><b><font size="4">1.</font></b>   What's the purpose of C++'s template
feature?</p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Guru Questions<!--mstheme--></font></h4>
<p>The code in the following questions is taken from the box on page 42<br>
of <i><a href="../publications/xc++.htm">Exceptional C++</a></i>.<b><a href="#1">[1]</a></b></p>
<p><b><font size="4">2.</font></b>   What are the semantics of the following
function? Be as complete as you can, and be sure to explain why there are two
template parameters and not just one.</p>
<blockquote>
<p><font face="Courier New">// Example 2(a): construct().<br>
//<br>
template &lt;class T1, class T2&gt;<br>
void construct( T1* p, const T2&amp; value )<br>
{<br>
&nbsp; new (p) T1(value);<br>
}</font></p>
</blockquote>
<p><b><font size="4">3.</font></b>   There is a subtle genericity trap in the
following functions. What is it, and what's the best way to fix it?</p>
<blockquote>
  <p><font face="Courier New">// Example 3(a): destroy().<br>
  //<br>
  template &lt;class T&gt;<br>
  void destroy( T* p )<br>
  {<br>
  &nbsp; p-&gt;~T();<br>
  }<br>
  <br>
  template &lt;class FwdIter&gt;<br>
  void destroy( FwdIter first, FwdIter last )<br>
  {<br>
  &nbsp; while( first != last )<br>
  &nbsp; {<br>
  &nbsp;&nbsp;&nbsp; destroy( first );<br>
  &nbsp;&nbsp;&nbsp; ++first;<br>
  &nbsp; }<br>
  }</font></p>
</blockquote>
<p><b><font size="4">4.</font></b>   What are the semantics of the following
function, including the requirements on T? Is it possible to remove any of those
requirements? If so, demonstrate how, and argue whether doing so is a good idea
or a bad idea.</p>
<blockquote>
<p>/<font face="Courier New">/ Example 4(a): swap().<br>
//<br>
template &lt;class T&gt;<br>
void swap( T&amp; a, T&amp; b )<br>
{<br>
&nbsp; T temp(a); a = b; b = temp;<br>
}</font></p>
<p align="center"><img border="0" src="../images/h-line.gif" width="248" height="2"></p>
</blockquote>
<h3><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666"><a name="Solution"></a>Solution<!--mstheme--></font></h3>

<p><font color="#999933"><b><font size="4">1.</font></b>   What's the purpose of
C++'s template feature?</font></p>
<p>Templates provide powerful compile-time polymorphism. Misuse of templates can
cause really hard-to-read error messages on many compilers, but templates are
also one of C++'s most powerful features.</p>
<p>When we think of polymorphism in an object-oriented world, we think of the
kind of runtime polymorphism we get from using virtual functions. A base class
establishes an interface &quot;contract&quot; as defined by a set of virtual
functions, and derived classes may inherit from the base class and override the
virtual functions in a way that preserves the contracted semantics. Then other
code that expects to work on a Base object (and accepts the Base object by
pointer or reference) can work equally well with a Derived object:</p>
<blockquote>
  <p><font face="Courier New">// Example 1(a): Ye olde garden-variety runtime<br>
  // polymorphism. Doesn't draw big crowds these days.<br>
  //<br>
  class Base<br>
  {<br>
  public:<br>
  &nbsp; virtual void f();<br>
  &nbsp; virtual void g();<br>
  };<br>
  <br>
  class Derived : public Base<br>
  {<br>
  &nbsp; // override f() and/or g() if desired<br>
  };<br>
  <br>
  void h( Base&amp; b )<br>
  {<br>
  &nbsp; b.f();<br>
  &nbsp; b.g();<br>
  }<br>
  <br>
  int main()<br>
  {<br>
  &nbsp; Derived d;<br>
  &nbsp; h( d );<br>
  }</font></p>
</blockquote>
<p>This is great stuff, and gives a lot of runtime flexibility. The main
drawbacks of runtime polymorphism are that the types must be related in a
hierarchy derived from a common base class, and when the virtual functions are
called in a tight loop you may notice some performance penalty because normally
each call to a virtual function must be made through an extra pointer
indirection, as the compiler figures out the Derived function you
&quot;really&quot; mean to call.</p>
<p>If you know the types you're using at compile time, then you can get around
both of the above drawbacks: You can use types that are not related by
inheritance, as long as they provide the expected operations:</p>
<blockquote>
  <p><font face="Courier New">// Example 1(b): Ye newe C++-variety compile-time<br>
  // polymorphism. Powerful stuff. We're still<br>
  // finding out just what kinds of nifty things<br>
  // this makes possible.<br>
  //<br>
  class Xyzzy<br>
  {<br>
  public:<br>
  &nbsp; void f( bool someParm = true );<br>
  &nbsp; void g();<br>
  &nbsp; void GoToGazebo();<br>
  &nbsp; // ... more functions ...<br>
  };<br>
  <br>
  class Murgatroyd<br>
  {<br>
  public:<br>
  &nbsp; void f();<br>
  &nbsp; void g( double two = 6.28, double e = 2.71828 );<br>
  &nbsp; int HeavensTo( const Z&amp; ) const;<br>
  &nbsp; // ... more functions ...<br>
  };<br>
  <br>
  template&lt;class T&gt;<br>
  void h( T&amp; t )<br>
  {<br>
  &nbsp; t.f();<br>
  &nbsp; t.g();<br>
  }<br>
  <br>
  int main()<br>
  {<br>
  &nbsp; Xyzzy x;<br>
  &nbsp; Murgatroyd m;<br>
  <br>
  &nbsp; h( x );<br>
  &nbsp; h( m );<br>
  }</font></p>
</blockquote>

<p>As long as both objects x and m are of a type that provides member functions
f() and g() that can be called with no parameters, h() will work. In Example
1(b), both types actually have different signatures for f() and g(), and they
also provide additional functions beyond just those two, but h() doesn't care...
as long as f() and g() can be called without parameters, the compiler will allow
h() to make the calls. Of course, when called, those functions should also do
something that's sensible for h()!</p>

<p><font color="#999933"><b><font size="4">2.</font></b>   What are the
semantics of the following function? Be as complete as you can, and be sure to
explain why there are two template parameters and not just one.</font></p>
<blockquote>
<p><font face="Courier New" color="#999933">// Example 2(a): construct().<br>
//<br>
template &lt;class T1, class T2&gt;<br>
void construct( T1* p, const T2&amp; value )<br>
{<br>
&nbsp; new (p) T1(value);<br>
}</font></p>
</blockquote>
<p>construct() constructs an object in a given memory location using an initial
value. The form of new used here is called &quot;placement new,&quot; and
instead of allocating memory for the new object, it just puts it into the memory
pointed at by p. Any object new'd in this way should generally be destroyed by
calling its destructor explicitly (as shown in Question 3), rather than by using
a delete expression.</p>
<p>Why two template parameters? Isn't one sufficient to make a copy of the value
object? Well, if construct() had only one template parameter, then you would
need to explicitly state the type of that parameter when copying from an object
of a different type:</p>
<blockquote>
  <p><font face="Courier New">// Example 2(b): A less functional construct(),<br>
  // and why it's less functional.<br>
  //<br>
  template &lt;class T1&gt;<br>
  void construct( T1* p, const T1&amp; value )<br>
  {<br>
  &nbsp; new (p) T1(value);<br>
  }<br>
  <br>
  // Assume that both p1 and p2 point to raw memory.<br>
  //<br>
  void f( double* p1, Base* p2 )<br>
  {<br>
  &nbsp; Base b;<br>
  &nbsp; Derived d;<br>
  <br>
  &nbsp; construct( p1, 2.718 );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ok<br>
  &nbsp; construct( p2, b
  );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ok<br>
  <br>
  &nbsp; construct( p1, 42 ); // error: is T1 double or int?<br>
  &nbsp; construct&lt;double&gt;( p1, 42 ); // ok<br>
  <br>
  &nbsp; construct( p2, d );&nbsp; // error: is T1 Base or Derived?<br>
  &nbsp; construct&lt;Base&gt;( p2, d );&nbsp;&nbsp;&nbsp; // ok<br>
  }</font></p>
</blockquote>
<p>The reason the two noted cases are ambiguous is that the compiler doesn't
know enough to deduce the template parameter, and so the programmer is forced to
nominate a template parameter explicitly. Yet shouldn't we allow programmers to
silently construct a double from an integer value? Probably; the worst that
could happen is that we might lose some precision. Shouldn't we allow
programmers to silently construct a Base from a Derived? Possibly; if Base
allows that, then slicing would occur but that can be a legitimate choice of
operation.</p>
<p>Assuming that we want to allow the programmer to be able to do such things
without explicitly naming types, we need to use the originally-presented version
that has two independent template parameters.</p>
<p><font color="#999933"><b><font size="4">3.</font></b>   There is a subtle
genericity trap in the following functions. What is it, and what's the best way
to fix it?</font></p>
<blockquote>
  <p><font face="Courier New" color="#999933">// Example 3(a): destroy().<br>
  //<br>
  template &lt;class T&gt;<br>
  void destroy( T* p )<br>
  {<br>
  &nbsp; p-&gt;~T();<br>
  }<br>
  <br>
  template &lt;class FwdIter&gt;<br>
  void destroy( FwdIter first, FwdIter last )<br>
  {<br>
  &nbsp; while( first != last )<br>
  &nbsp; {<br>
  &nbsp;&nbsp;&nbsp; destroy( first );<br>
  &nbsp;&nbsp;&nbsp; ++first;<br>
  &nbsp; }<br>
  }</font></p>
</blockquote>
<p>destroy() destroys an object or a range of objects. The first version takes a
single pointer, and calls the pointed-at object's destructor. The second version
takes an iterator range, and iteratively destroys the individual objects in the
designated range.</p>
<p>Still, there's a subtle trap here. This didn't make a difference in any
example in the book, but it's a little odd: The two-parameter
destroy(FwdIter,FwdIter) version is templatized to take any generic iterator,
and yet it calls the one-parameter destroy(T*) by passing it one of the
iterators -- which requires that FwdIter must be a plain old pointer! This
needlessly loses some of the generality of templatizing on FwdIter. It also
means you can get Really Obscure error messages when compiling code that tries
to call destroy(FwdIter,FwdIter) with non-pointer iterators, because (at least
one of) the actual failure(s) will be on the destroy(first) line inside the
two-parameter version, which typically generates such useful messages as the
following, taken from one popular compiler:</p>
<blockquote>
  <p><font face="Courier New">'void __cdecl
  destroy(template-parameter-1,template-parameter-1)' : expects 2 arguments - 1
  provided</font></p>
  <p><font face="Courier New">'void __cdecl destroy(template-parameter-1 *)' :
  could not deduce template argument for 'template-parameter-1 *' from '[the
  iterator type I was using]'</font></p>
</blockquote>
<p>These error messages aren't as bad as some I've seen, and with only a little
bit of extra reading they do actually tell you (mostly) what's going on. The
first message indicates that the compiler was trying to resolve the line
&quot;destroy(first)&quot; as a call to the two-parameter version; the second
indicates an attempt instead to resolve it as a call to the one-parameter
version. Both attempts failed, each for a different reason: The two-parameter
version can take iterators, but needs two of them, not just one; and the
one-parameter version can take just one parameter, but needs it to be a pointer.
No dice.</p>
<p>Having said all that, in reality we'd almost never want to use destroy() with
anything but pointers in the first place just because of the way the function is
intended to be used, given that it turns things back into raw memory and all.
Still, only a simple change is needed to let FwdIter be any iterator type, not
just a pointer, so why not do it: Have destroy(iter,iter) call the destructor
explicitly. In the two-parameter version of destroy(), change:</p>
<blockquote>
  <p><font face="Courier New" color="#999933">destroy( first );</font></p>
</blockquote>
<p>To:</p>
<blockquote>
  <p><font face="Courier New">destroy( &amp;*first );</font></p>
</blockquote>
<p>This will almost always work. After all, we can usually expect that, for an
iterator iter, the expression &amp;*iter really does yield a pointer to the T
object to which the iterator refers. Consider why it would usually work fine:
All standard-conforming iterators <b><sup><a href="#2">[2]</a></sup></b> are
required to supply an operator*() that returns a true T&amp;. This is one of the
reasons why proxied containers are not supported by the C++ standard; for more
information about this and related issues, see the discussion of the expression
&amp;*t.begin() in <a href="050.htm">GotW #50</a> <b><a href="#3"><sup>[3] </sup></a></b>and
my May 1999 <i>C++ Report</i> column.<b><a href="#4"><sup>[4]</sup></a></b> (It
is possible, if rare, to make &quot;destroy( &amp;*first );&quot; not work: As
Astute Reader Bill Wade pointed out, that formulation will fail to work if T
overrides its operator&amp;() to return something besides the object's address.)</p>
<p>What's the moral of the story? Beware subtle genericity drawbacks when
implementing one generic function in terms of another. In this case, there was a
subtle principal drawback: The two-parameter version wasn't as generic for
iterators as we originally thought. There was also an even subtler secondary
drawback: The quick fix of changing &quot;destroy( first );&quot; to
&quot;destroy( &amp;*first );&quot; introduced a new requirement on T, namely
that it provide an operator&amp;() with normal semantics, namely one that really
returns a pointer to the object. Both traps were neatly avoided when we stopped
implementing one function in terms of the other.</p>
<p><font color="#999933"><b><font size="4">4.</font></b>   What are the
semantics of the following function, including the requirements on T? Is it
possible to remove any of those requirements? If so, demonstrate how, and argue
whether doing so is a good idea or a bad idea.</font></p>
<blockquote>
<p><font color="#999933">/<font face="Courier New">/ Example 4(a): swap().<br>
//<br>
template &lt;class T&gt;<br>
void swap( T&amp; a, T&amp; b )<br>
{<br>
&nbsp; T temp(a); a = b; b = temp;<br>
}</font></font></p>
</blockquote>
<p>swap() just exchanges two values using the copy constructor and copy
assignment operator. It therefore requires that T have a copy constructor and a
copy assignment operator.</p>
<p>If that's all you said, give yourself half marks only. One of the important
things to note about the semantics of any function is its exception safety
status, including what guarantees it provides: In this case, swap() is not at
all exception-safe if T's copy assignment operator can throw an exception. In
particular, if T::operator=() can throw but is atomic (all-or-nothing), then if
the second assignment fails we exit via an exception but a has already been
modified; if additionally T::operator=() can throw but is not atomic, then it is
possible for swap() to exit via an exception but both parameters may have been
modified and one may now contain neither of the two values. Therefore this
swap() must be documented as follows:</p>
<blockquote>
  <p>- if T::operator=() doesn't throw, swap() gives the aC guarantee
  (all-or-nothing, except for side effects of T operations);<b><a href="#5"><sup>[5]</sup></a></b></p>
  <p>- otherwise, if T::operator=() can throw:</p>
  <blockquote>
    <p>- if T::operator=() is atomic, and swap() exits by means of an exception,
    the first argument might or might not already have been modified;</p>
    <p>- otherwise, if T::operator=() isn't atomic, and swap() exits by means of
    an exception, both arguments might or might not already have been modified,
    and one of them might contain neither of the original two values.</p>
  </blockquote>
</blockquote>
<p>There are two ways to remove the requirement that T have an assignment
operator, and the first additionally provides better exception safety:</p>
<p>1. Specialize or overload swap(). Say that we have a class MyClass that uses
the common idiom of providing a nonthrowing Swap(). Then we can specialize
standard functions for MyClass as follows.</p>
<blockquote>
  <p><font face="Courier New">// Example 4(b): Specializing swap().<br>
  //<br>
  class MyClass<br>
  {<br>
  public:<br>
  &nbsp; void Swap( MyClass&amp; ) throw();<br>
  &nbsp; // ...<br>
  };<br>
  <br>
  namespace std<br>
  {<br>
  &nbsp; template&lt;&gt; swap&lt;MyClass&gt;( MyClass&amp; a, MyClass&amp; b )<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  // throw()<br>
  &nbsp; {<br>
  &nbsp;&nbsp;&nbsp; a.Swap( b );<br>
  &nbsp; }<br>
  }</font></p>
</blockquote>

<p>Alternatively, we can overload standard functions for MyClass as follows:</p>

<blockquote>
  <p><font face="Courier New">// Example 4(c): Overloading swap().<br>
  //<br>
  class MyClass<br>
  {<br>
  public:<br>
  &nbsp; void Swap( MyClass&amp; ) throw();<br>
  &nbsp; // ...<br>
  };<br>
  <br>
  // NOTE: Not in namespace std.<br>
  swap( MyClass&amp; a, MyClass&amp; b ) // throw()<br>
  {<br>
  &nbsp; a.Swap( b );<br>
  }</font></p>
</blockquote>
<p>Doing this is usually a good idea -- even if T does have an assignment
operator that would allow the original version to work!</p>
<p>For example, the standard library itself overloads swap() for vector&lt;&gt;
so that calling swap() actually invokes vector&lt;&gt;::swap(). This makes a lot
of sense, because vector&lt;&gt;::swap() can be much more efficient by avoiding
making any copies of the vectors' data at all. The primary template above would
create a complete new copy (temp) of one of the vectors, then perform additional
copying from one vector to the other, then perform additional copying from temp
to the other vector, which results in a lot of T operations and has complexity
O(N) where N is the combined size of the vectors being swapped. The specialized
version will typically simply just assign a few pointers and integral types, and
runs in constant (and usually negligible) time.</p>
<p>So, if you create a type that provides a swap()-like operation, it's usually
a good idea to specialize std::swap() (or provide your own overloaded swap() in
another namespace) that's specific to your new type. It will usually be more
efficient than a routine application of the primary std::swap() template's
brute-force procedure, and will often improve swap()'s own exception safety.</p>
<p>2. Destroy-and-reconstruct. The idea here is to write swap() in terms of T's
copy constructor instead of its copy assignment operator, and of course this
only works if T indeed has a copy constructor:</p>
<blockquote>
  <p><font face="Courier New">// Example 4(d): swap() without assignment.<br>
  //<br>
  template &lt;class T&gt;<br>
  void swap( T&amp; a, T&amp; b )<br>
  {<br>
  if( &amp;a != &amp;b ) // note: this check is now necessary!<br>
  {<br>
  &nbsp; T temp( a );<br>
  <br>
  &nbsp; destroy( &amp;a );<br>
  &nbsp; construct( &amp;a, b );<br>
  <br>
  &nbsp; destroy( &amp;b );<br>
  &nbsp; construct( &amp;b, temp );<br>
  &nbsp; }<br>
  }</font></p>
</blockquote>
<p>First, this is never appropriate if T copy assignment can throw, because then
you get all the exception safety problems of the original version, only in
spades: You can get into situations where the objects hold not only
indeterminate values, but no longer exist at all!</p>
<p>If we know that T copy assignment is guaranteed not to throw, though, this
version does have the extra ability to deal with types that can't be assigned
but can be copy-constructed, and there are indeed many such types. Being able to
swap such types is -not- necessarily a good thing, though, because if a type
can't be assigned then it's probably set up that way for a good reason -- for
example, it likely doesn't have value semantics, and it may have const or
reference members -- and so providing a mechanism to &quot;imbue&quot; (or
&quot;impose&quot;) value semantics may be misguided and produce surprising and
incorrect results.</p>
<p>Worse still, this approach plays games with object lifetimes, and that's
always questionable. Here by &quot;plays games&quot; I mean that it changes not
only the values, but the very -existence-, of the operated-upon objects. Code
using the Example 4(d) form of swap() could easily produce surprising results
when users forget about the unusual destruction semantics.</p>
<p>A guideline: If you must play games with object lifetimes and you know that
doing so is okay, and you're certain that the operated-upon objects' copy
constructors can never thow, and you're very sure that the unusually
&quot;imposed&quot; value semantics will be all right in your application for
those specific objects, then (and only then) you may legitimately decide to use
such an approach in those specific situations only -- but even then, don't make
such an operation a general template that could be accidentally instantiated for
-any- type, and be very sure to document the blazes out of it so that the poor
unsuspecting user next door knows what to expect, because this technique falls
squarely into the &quot;unusual&quot; section of the C++ coding catalog.</p>

<p>&nbsp;</p>

<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Notes<!--mstheme--></font></h4>
<p><a name="1"></a>1. H. Sutter. <b><a href="../publications/xc++.htm">Exceptional
C++</a></b> (Addison-Wesley, 2000).</p>
<p><a name="2"></a>2. Note that this does not include
vector&lt;bool&gt;::iterator, which is not a conforming iterator.</p>
<p><a name="3"></a>3. Available at <a href="050.htm">http://www.gotw.ca/gotw/050.htm</a>.</p>
<p><a name="4"></a>4. Sutter, H. <b><a href="../publications/mill09.htm">&quot;When Is a Container Not a
Container?&quot;</a></b> (<i>C++ Report</i>, 11(5), May 1999). This discusses some
of the evils of vector&lt;bool&gt;.</p>
<p><a name="5"></a>5. See <a href="061.htm">GotW #61</a>.</p>
<!--mstheme--></font><!--msnavigation--></td></tr><!--msnavigation--></table><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td><!--mstheme--><font face="Arial, Arial, Helvetica"><h4 align="right"><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666"><a href="../copyright.htm"><font size="2">Copyright ©
2002 Herb Sutter</font></a><!--mstheme--></font></h4>

<!--mstheme--></font></td></tr><!--msnavigation--></table></body>
</html>

