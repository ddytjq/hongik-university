ID=E0203
URL=http://www.gotw.ca/gotw/071.htm
SIZE=41283
DATE=12/07/02
TIME=19:18:38
DATASET=C
HTML=
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta http-equiv="Content-Language" content="en-us">


<title>GotW #71: Inheritance Traits?</title>
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<link rel="stylesheet" type="text/css" href="../gotw.css">
<meta name="Microsoft Theme" content="gotw 111, default">
<meta name="Microsoft Border" content="tlb, default">
</head>

<body background="../_themes/gotw/glabkgnd.jpg" bgcolor="#CCFFFF" text="#000000" link="#008080" vlink="#008080" alink="#0000FF"  ><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font><table border="0" cellspacing="0" width="100%">
  <tr>
    <td colspan="2"><!--mstheme--><font face="Arial, Arial, Helvetica"><font size="6"><strong>
    GotW #71</strong></font> <!--mstheme--></font></td>
  </tr>
  <tr>
    <td valign="middle"><!--mstheme--><font face="Arial, Arial, Helvetica">




<p align="left" style="margin-top: 0; margin-bottom: 0">

<script language="JavaScript"><!--
MSFPhover = 
  (((navigator.appName == "Netscape") && 
  (parseInt(navigator.appVersion) >= 3 )) || 
  ((navigator.appName == "Microsoft Internet Explorer") && 
  (parseInt(navigator.appVersion) >= 4 ))); 
function MSFPpreload(img) 
{
  var a=new Image(); a.src=img; return a; 
}
// --></script><script language="JavaScript"><!--
if(MSFPhover) { MSFPnav1n=MSFPpreload("../_derived/home_cmp_gotw110_hbtn.gif"); MSFPnav1h=MSFPpreload("../_derived/home_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav1'].src=MSFPnav1h.src" onmouseout="if(MSFPhover) document['MSFPnav1'].src=MSFPnav1n.src"><img src="../_derived/home_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Home" align="middle" name="MSFPnav1"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav2n=MSFPpreload("../_derived/news.htm_cmp_gotw110_hbtn.gif"); MSFPnav2h=MSFPpreload("../_derived/news.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../news.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav2'].src=MSFPnav2h.src" onmouseout="if(MSFPhover) document['MSFPnav2'].src=MSFPnav2n.src"><img src="../_derived/news.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="News &amp; Events" align="middle" name="MSFPnav2"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav3n=MSFPpreload("../resources/_derived/index.htm_cmp_gotw110_hbtn.gif"); MSFPnav3h=MSFPpreload("../resources/_derived/index.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../resources/index.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav3'].src=MSFPnav3h.src" onmouseout="if(MSFPhover) document['MSFPnav3'].src=MSFPnav3n.src"><img src="../resources/_derived/index.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Community Resources" align="middle" name="MSFPnav3"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav4n=MSFPpreload("../_derived/consulting.htm_cmp_gotw110_hbtn.gif"); MSFPnav4h=MSFPpreload("../_derived/consulting.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../consulting.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav4'].src=MSFPnav4h.src" onmouseout="if(MSFPhover) document['MSFPnav4'].src=MSFPnav4n.src"><img src="../_derived/consulting.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Consulting Services" align="middle" name="MSFPnav4"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav5n=MSFPpreload("../_derived/presentations.htm_cmp_gotw110_hbtn.gif"); MSFPnav5h=MSFPpreload("../_derived/presentations.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../presentations.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav5'].src=MSFPnav5h.src" onmouseout="if(MSFPhover) document['MSFPnav5'].src=MSFPnav5n.src"><img src="../_derived/presentations.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Presentations" align="middle" name="MSFPnav5"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav6n=MSFPpreload("../publications/_derived/index.htm_cmp_gotw110_hbtn.gif"); MSFPnav6h=MSFPpreload("../publications/_derived/index.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../publications/index.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav6'].src=MSFPnav6h.src" onmouseout="if(MSFPhover) document['MSFPnav6'].src=MSFPnav6n.src"><img src="../publications/_derived/index.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Publications" align="middle" name="MSFPnav6"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav7n=MSFPpreload("_derived/index.htm_cmp_gotw110_hbtn.gif"); MSFPnav7h=MSFPpreload("_derived/index.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="index.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav7'].src=MSFPnav7h.src" onmouseout="if(MSFPhover) document['MSFPnav7'].src=MSFPnav7n.src"><img src="_derived/index.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Guru of the Week" align="middle" name="MSFPnav7"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav8n=MSFPpreload("../conv/_derived/index.htm_cmp_gotw110_hbtn.gif"); MSFPnav8h=MSFPpreload("../conv/_derived/index.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../conv/index.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav8'].src=MSFPnav8h.src" onmouseout="if(MSFPhover) document['MSFPnav8'].src=MSFPnav8n.src"><img src="../conv/_derived/index.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Conversations" align="middle" name="MSFPnav8"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav9n=MSFPpreload("../_derived/search.htm_cmp_gotw110_hbtn.gif"); MSFPnav9h=MSFPpreload("../_derived/search.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../search.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav9'].src=MSFPnav9h.src" onmouseout="if(MSFPhover) document['MSFPnav9'].src=MSFPnav9n.src"><img src="../_derived/search.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Search GotW.ca" align="middle" name="MSFPnav9"></a>
</p>




    <!--mstheme--></font></td>
    <td valign="middle"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 0; margin-bottom: 0">
      <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav10n=MSFPpreload("../_derived/back_cmp_gotw110_back.gif"); MSFPnav10h=MSFPpreload("../_derived/back_cmp_gotw110_back_a.gif"); }
// --></script><a href="070.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav10'].src=MSFPnav10h.src" onmouseout="if(MSFPhover) document['MSFPnav10'].src=MSFPnav10n.src"><img src="../_derived/back_cmp_gotw110_back.gif" width="100" height="20" border="0" alt="Prev" name="MSFPnav10"></a><br><script language="JavaScript"><!--
if(MSFPhover) { MSFPnav11n=MSFPpreload("../_derived/up_cmp_gotw110_up.gif"); MSFPnav11h=MSFPpreload("../_derived/up_cmp_gotw110_up_a.gif"); }
// --></script><a href="index.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav11'].src=MSFPnav11h.src" onmouseout="if(MSFPhover) document['MSFPnav11'].src=MSFPnav11n.src"><img src="../_derived/up_cmp_gotw110_up.gif" width="100" height="20" border="0" alt="Up" name="MSFPnav11"></a><br><script language="JavaScript"><!--
if(MSFPhover) { MSFPnav12n=MSFPpreload("../_derived/next_cmp_gotw110_next.gif"); MSFPnav12h=MSFPpreload("../_derived/next_cmp_gotw110_next_a.gif"); }
// --></script><a href="072.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav12'].src=MSFPnav12h.src" onmouseout="if(MSFPhover) document['MSFPnav12'].src=MSFPnav12n.src"><img src="../_derived/next_cmp_gotw110_next.gif" width="100" height="20" border="0" alt="Next" name="MSFPnav12"></a><!--mstheme--></font></td>
  </tr>
  <tr>
    <td height="5" background="../images/bar.gif" colspan="2"><!--mstheme--><font face="Arial, Arial, Helvetica">&nbsp;<!--mstheme--></font></td>
  </tr>
</table><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font></td></tr><!--msnavigation--></table><!--msnavigation--><table dir="ltr" border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td valign="top" width="1%"><!--mstheme--><font face="Arial, Arial, Helvetica">

<!--mstheme--></font><table border="0" cellspacing="0" bgcolor="#000000" cellpadding="0">
  <tr>
    <td><!--mstheme--><font face="Arial, Arial, Helvetica">
    <!--mstheme--></font><table border="0" cellpadding="2" cellspacing="1" width="100%" height="483">
        <tr>
          <td align="center" bgcolor="#000000" colspan="2" height="16"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin-top: 0; margin-bottom: 0"><a href="../news.htm"><b><font color="#FFFF00">News</font></b></a><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="center" bgcolor="#CCCCCC" bordercolor="#CCCCCC" rowspan="3"><!--mstheme--><font face="Arial, Arial, Helvetica">
          <font size="1" color="#0000FF">J<br>
          U<br>
          L<br>
          Y</font><!--mstheme--></font></td>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin-left: 3; margin-right: 3; margin-top: 0" align="center"><font size="1" color="#0000FF">
            Print articles newly available online</font><!--mstheme--></font><table border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%" id="AutoNumber1" bgcolor="#FFFFCC" bordercolordark="#006666" bordercolorlight="#99CCCC">
              <tr>
                <td width="100%" bordercolor="#808000"><!--mstheme--><font face="Arial, Arial, Helvetica">
                <p style="margin: 3"><font size="1" color="#0000FF">
                <a href="../publications/mill20.htm"><b><i>
                <font color="#0000FF">Sutter's Mill</font></i></b><font color="#0000FF"> 
                column, &quot;Toward a Standard C++ Library, Part 1&quot;</font></a></font><!--mstheme--></font></td>
              </tr>
              <tr>
                <td width="100%" bordercolor="#808000" bgcolor="#FFFFCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
                <p style="margin: 3"><font size="1" color="#0000FF">
                <a href="../publications/mxc++-item-4.htm">
                <font color="#0000FF">Excerpt from MXC++, &quot;Extensible Templates: 
                Via Inheritance or Traits?&quot;</font></a></font><!--mstheme--></font></td>
              </tr>
              <tr>
                <td width="100%" bordercolor="#808000"><!--mstheme--><font face="Arial, Arial, Helvetica">
                <p style="margin: 3"><font size="1" color="#0000FF">
                <a href="../publications/mcd_review.htm"><font color="#0000FF">
                Book Review: Modern C++ Design</font></a></font><!--mstheme--></font></td>
              </tr>
              <tr>
                <td width="100%" bordercolor="#808000"><!--mstheme--><font face="Arial, Arial, Helvetica">
                <p style="margin: 3"><font size="1" color="#0000FF">
                <a href="../publications/mill21.htm"><b><i>
                <font color="#0000FF">Sutter's Mill</font></i></b><font color="#0000FF"> 
                column, &quot;Toward a Standard C++ Library, Part 2: Namespaceops and 
                Library Versioning&quot;</font></a></font><!--mstheme--></font></td>
              </tr>
            </table><!--mstheme--><font face="Arial, Arial, Helvetica">
          <!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin: 0 3"><font size="1" color="#0000FF"><b><i>Sutter's 
            Mill</i></b> column,
            &quot;A Pragmatic Look at Exception Specifications&quot;<br>
            </font><font size="1" color="#000080">The usefulness, or lack 
            thereof, of exception specifications, and how results can vary 
            across real-world compilers</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin: 0 3">
            <a target="_blank" href="http://www.cuj.com/experts/2007/hyslop.htm"><font size="1" color="#0000FF"><i><b>Conversations</b></i> column,
            &quot;Getting to the Point&quot;</font></a><font color="#0000FF" size="1"><br>
            </font><font size="1" color="#000080">The Boost library has five 
            smart pointers that provide a rich array [sic] of useful behaviors.</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="center" bgcolor="#CCCCCC" bordercolor="#CCCCCC" rowspan="2"><!--mstheme--><font face="Arial, Arial, Helvetica"><font color="#0000FF" size="1">A<br>
            U<br>
          G<br>
          U<br>
          S<br>
          T</font><!--mstheme--></font></td>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin:0 3; ">
            <a target="_blank" href="http://www.cuj.com/experts/2008/sutter.htm"><i><b><font size="1" color="#0000FF">The New C++</font></b></i> <font size="1" color="#0000FF">
            column, &quot;Smart(er) Pointers&quot;</font></a><font size="1" color="#000080"><br>
            A closer look at one of the proposed new standard C++ library 
            features -- smart pointers, particularly those in Boost and Loki, 
            and a sneak peek at the usefulness of the proposed typedef templates</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
          <p style="margin:0 3; ">
          <a target="_blank" href="http://www.cuj.com/experts/2008/hyslop.htm"><font size="1" color="#0000FF"><i><b>Conversations</b></i> column,
            &quot;A Midsummer Night's Madness&quot;</font></a><font color="#0000FF" size="1"><br>
            </font><font size="1" color="#000080">A brew that mixes pointers, 
          typedefs, and const</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="center" bgcolor="#CCCCCC" bordercolor="#CCCCCC" rowspan="3"><!--mstheme--><font face="Arial, Arial, Helvetica">
          <p style="margin-top: 0; margin-bottom: 0">
          <font size="1" color="#0000FF">S<br>
          E<br>
          P<br>
          T<br>
          E<br>
          M<br>
          B<br>
          E<br>
          R</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin: 0 3">
            <font size="1" color="#0000FF">&quot;Standard C++ Meets Managed C++&quot;<br>
            </font><font size="1" color="#000080">A survey of the main (in)compatibilities 
            between Standard C++ and Microsoft’s managed extensions for C++, and 
            how the two could converge</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin: 0 3"><font size="1" color="#0000FF"><b><i>Sutter's 
            Mill</i></b> column,
            &quot;Export Restrictions, Part 1&quot;<br>
            </font><font size="1" color="#000080">The scoop on export -- what 
            some people think it does, what it actually does, and why it’s the 
            most widely-ignored feature in the C++ standard</font><!--mstheme--></font></td>
        </tr>
      </table><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font></td>
  </tr>
</table><!--mstheme--><font face="Arial, Arial, Helvetica">
<p style="margin-top: 0; margin-bottom: 0">
<img border="0" src="../images/140.gif" width="140" height="1"></p>

<!--mstheme--></font></td><td valign="top" width="24"></td><!--msnavigation--><td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font><table border="1" cellpadding="6" cellspacing="0" width="100%" bgcolor="#CCCCFF" bordercolordark="#006666" bordercolorlight="#99CCCC">
  <tr>
    <td width="100%"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p align="center">This is the original GotW problem and solution
      substantially as posted to Usenet. See the book <i><a href="../publications/mxc++.htm"><b>More
      Exceptional C++</b></a></i> (Addison-Wesley, 2002) for the most current
      solution to this GotW issue. The solutions in the book have been revised
      and expanded since their initial appearance in GotW. The book versions
      also incorporate corrections, new material, and conformance to the final
      ANSI/ISO C++ standard.</p>
    <!--mstheme--></font></td>
  </tr>
</table><!--mstheme--><font face="Arial, Arial, Helvetica">
      <h2><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Inheritance Traits?&nbsp;<font size="3"><br>
      Difficulty: 5 / 10</font><!--mstheme--></font></h2>
<p><i>This issue reviews traits templates, and demonstrates some cool traits
techniques. What can a template figure out about its type -- and then what can
it do about it? The answers are nifty and illuminating, and not just for people
who write C++ libraries.</i></p>
<p align="center"><img border="0" src="../images/h-line.gif" width="248" height="2"></p>

<h3><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Problem<!--mstheme--></font></h3>

<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">JG Questions<!--mstheme--></font></h4>
<p><b><font size="4">1.</font></b>   What is a traits class?</p>
<p><b><font size="4">2.</font></b> Demonstrate how to detect and make use of
class members within templates, using the following motivating case: You want to
write a templated class C that can only be instantiated on types having a
function named Clone that takes no parameters and returns a pointer to the same
kind of object.</p>
<blockquote>
<p><font face="Courier New">// T must provide T* T::Clone() const<br>
template&lt;class T&gt;<br>
class C<br>
{<br>
&nbsp; // ...<br>
};</font></p>
</blockquote>
<p>Note: It's obvious that if C just writes code that tries to invoke T::Clone()
without parameters, then such code will fail to compile if there isn't a
T::Clone() that can be called without parameters. But that's not enough to
answer this question: Just trying to call T::Clone() without parameters would
also succeed in calling a Clone() that has defaulted parameters and/or does not
return a T*. The goal here is to specifically enforce that T provide a function
that looks exactly like this: T* T::Clone().</p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Guru Questions<!--mstheme--></font></h4>
<p><b><font size="4">3.</font></b> A programmer wants to write a template that
can require (or just detect) whether the type on which it is instantiated has a
Clone() member function. The programmer decides to do this by requiring that
classes offering such a Clone() must derive from a fixed Clonable class.
Demonstrate how to write this template:</p>
<blockquote>
<p><font face="Courier New">template&lt;class T&gt;<br>
class X<br>
{<br>
&nbsp; // ...<br>
};</font></p>
  <p>a) to require that T be derived from Clonable; and</p>
  <p>b) to provide an alternative implementation if T is derived from Clonable,
  and work in some default mode otherwise.</p>
</blockquote>
<p><b><font size="4">4.</font></b> Is the approach in #3 the best way to
require/detect the availability of a Clone()? Describe alternatives.</p>
<p><b><font size="4">5.</font></b> Can a template benefit significantly from
knowing that is parameter type T is inherited from some other type, in a way
that could not be achieved at least as well otherwise without the inheritance
relationship?</p>
<p align="center"><img border="0" src="../images/h-line.gif" width="248" height="2"></p>
<h3><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666"><a name="Solution"></a>Solution<!--mstheme--></font></h3>

<p><font color="#999933"><b><font size="4">1.</font></b>   What is a traits
class?</font></p>
<p>Quoting 17.1.18 in the C++ standard, a traits class is:</p>
<blockquote>
  <p><i>&quot;a class that encapsulates a set of types and functions necessary
  for template classes and template functions to manipulate objects of types for
  which they are instantiated.&quot;</i></p>
</blockquote>
<p>The idea is that traits classes are templates used to carry extra information
-- especially information that templates can use -- about the classes on which
the traits template is instantiated. The nice thing is that the traits class
T&lt;C&gt; tacks on said extra information to class C without requiring any
change at all to C. Despite all the talk about &quot;tacking on,&quot; traits
are quite useful -- not &quot;tacky&quot; at all.</p>
<p>For examples, see:</p>
<blockquote>
  <p>- Items 2 and 3 in <a href="../publications/xc++.htm"><i>Exceptional C++</i></a>.<b><a href="#1"><sup>[1]</sup></a></b></p>
  <p>- <a href="062.htm">GotW #62</a> on &quot;Smart Pointer Members.&quot;<b><sup><a href="#2">[2]</a></sup></b></p>
  <p>- The April, May, and June 2000 issues of <i>C++ Report</i>, which
  contained several excellent columns about traits.</p>
  <p>- The C++ standard library's own char_traits, iterator categories, and
  similar mechanisms.</p>
</blockquote>

<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Requiring Member Functions<!--mstheme--></font></h4>

<p><font color="#999933"><b><font size="4">2.</font></b> Demonstrate how to
detect and make use of class members within templates, using the following
motivating case: You want to write a templated class C that can only be
instantiated on types having a function named Clone that takes no parameters and
returns a pointer to the same kind of object.</font></p>
<blockquote>
<p><font face="Courier New" color="#999933">// T must provide T* T::Clone()
const<br>
template&lt;class T&gt;<br>
class C<br>
{<br>
&nbsp; // ...<br>
};</font></p>
</blockquote>
<p><font color="#999933">Note: It's obvious that if C just writes code that
tries to invoke T::Clone() without parameters, then such code will fail to
compile if there isn't a T::Clone() that can be called without parameters.</font></p>

<p>For an example to illustrate that last note, consider:</p>

<blockquote>

<p><font face="Courier New">// Example 2(a): Initial attempt,<br>
// sort of requires Clone()<br>
//<br>
// T must provide /*...*/ T::Clone( /*...*/ )<br>
template&lt;class T&gt;<br>
class C<br>
{<br>
public:<br>
&nbsp; void SomeFunc( T* t )<br>
&nbsp; {<br>
&nbsp;&nbsp;&nbsp; // ...<br>
&nbsp;&nbsp;&nbsp; t-&gt;Clone();<br>
&nbsp;&nbsp;&nbsp; // ...<br>
&nbsp; }<br>
};</font></p>

</blockquote>
<p>The first problem with Example 2(a) is that it doesn't necessarily require
anything at all -- in a template, only the member functions that are actually
used will be instantiated, or even parsed for that matter.<b><sup><a href="#3">[3]</a></sup></b> If SomeFunc() is
never used, it will never be instantiated and so C can easily be instantiated
with T's that don't have anything resembling Clone().</p>
<p>The solution is to put the code that enforces the requirement into a function
that's sure to be instantiated. The first thing most people think of is to put
it in the constructor, because of course it's impossible to use C without
invoking its constructor somewhere, right? True enough, but there could be
multiple constructors and then to be safe we'd have to put the
requirement-enforcing code into every constructor. There's a much easier
solution, namely: Put it in the destructor. There's only one destructor, and
it's equally impossible to use C without invoking its destructor, so that's the
simplest place for the requirement-enforcing code to live.</p>
<blockquote>

<p><font face="Courier New">// Example 2(b): Revised attempt, requires Clone()<br>
//<br>
// T must provide /*...*/ T::Clone( /*...*/ )<br>
template&lt;class T&gt;<br>
class C<br>
{<br>
public:<br>
&nbsp; ~C()<br>
&nbsp; {<br>
&nbsp;&nbsp;&nbsp; // ...<br>
&nbsp;&nbsp;&nbsp; T t; // kind of wasteful<br>
&nbsp;&nbsp;&nbsp; t.Clone();<br>
&nbsp;&nbsp;&nbsp; // ...<br>
&nbsp; }<br>
};</font></p>

</blockquote>

<p>This leaves us with the second problem: Both Examples 2(a) and 2(b) don't so
much test the constraint as simply rely on it. (In the case of Example 2(b),
it's even worse because 2(b) does it in a wasteful way that adds unnecessary
runtime code just to try to enforce a constraint.) As noted in the question
statement itself, continuing on:</p>

<p><font color="#999933">But that's not enough to answer this question: Just
trying to call T::Clone() without parameters would also succeed in calling a
Clone() that has defaulted parameters and/or does not return a T*.</font></p>
<p>The code in Examples 2(a) and 2(b) will indeed work most swimmingly if there
is a function &quot;T* T::Clone();&quot;. The problem is that it will also work
most swimmingly if there is a function &quot;void T::Clone();&quot;, or &quot;T*
T::Clone( int = 42 );&quot;, or other variant signature, as long as it can be
called without parameters. (For that matter, it will also work even if there
isn't a Clone() member function at all, as long as there's a macro that changes
the name Clone to something else, but there's little we can do about that.)</p>
<p>All that may be fine in some applications, but it's not what the question
asked for. What we want to achieve is stronger:</p>
<p><font color="#999933">The goal here is to specifically enforce that T provide
a function that looks exactly like this: T* T::Clone().</font></p>

<p>So here's one way we can do it:</p>

<blockquote>
  <p><font face="Courier New">// Example 2(c): Better, requires<br>
  // exactly T* T::Clone() const<br>
  //<br>
  // T must provide T* T::Clone() const<br>
  template&lt;class T&gt;<br>
  class C<br>
  {<br>
  public:<br>
  &nbsp; // in C's destructor (easier than putting it<br>
  &nbsp; // in every C ctor):<br>
  &nbsp; ~C()<br>
  &nbsp; {<br>
  &nbsp;&nbsp;&nbsp; T* (T::*test)() const = T::Clone;<br>
  &nbsp;&nbsp;&nbsp; test; // suppress warnings about unused variables<br>
  &nbsp;&nbsp;&nbsp; // this unused variable is likely to be optimized<br>
  &nbsp;&nbsp;&nbsp; // away entirely<br>
  <br>
  &nbsp;&nbsp;&nbsp; // ...<br>
  &nbsp; }<br>
  <br>
  &nbsp; // ...<br>
  };</font></p>
</blockquote>

<p>Or, a little more cleanly and extensibly:</p>

<blockquote>
  <p><font face="Courier New">// Example 2(d): Alternative way of requiring<br>
  // exactly T* T::Clone() const<br>
  //<br>
  // T must provide T* T::Clone() const<br>
  template&lt;class T&gt;<br>
  class C<br>
  {<br>
  &nbsp; bool ValidateRequirements()<br>
  &nbsp; {<br>
  &nbsp;&nbsp;&nbsp; T* (T::*test)() const = T::Clone;<br>
  &nbsp;&nbsp;&nbsp; test; // suppress warnings about unused variables<br>
  &nbsp;&nbsp;&nbsp; // ...<br>
  &nbsp;&nbsp;&nbsp; return true;<br>
  &nbsp; }<br>
  <br>
  public:<br>
  &nbsp; // in C's destructor (easier than putting it<br>
  &nbsp; // in every C ctor):<br>
  &nbsp; ~C()<br>
  &nbsp; {<br>
  &nbsp;&nbsp;&nbsp; assert( ValidateRequirements() );<br>
  &nbsp; }<br>
  <br>
  &nbsp; // ...<br>
  };</font></p>
</blockquote>
<p>Having a ValidateRequirements() function is extensible -- it gives us a nice
clean place to add any future requirements checks. Calling it within an assert()
further ensures that all traces of the requirements machinery will disappear
from release builds.</p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Requiring Inheritance<!--mstheme--></font></h4>
<p>NOTE: I have seen the following ideas in several places -- I think that two
of those places were in published or unpublished articles by Andrei Alexandrescu
and Bill Gibbons. My apologies if the code I'm about to show looks really
similar to someone's published code; I'm reusing other people's good ideas, but
writing this code off the top of my head. (Later note: see Andrei's
&quot;Mappings Between Types and Values.&quot;<a href="#4"><b><sup>[4]</sup></b></a>)</p>

<p><font color="#999933"><b><font size="4">3.</font></b> A programmer wants to
write a template that can require (or just detect) whether the type on which it
is instantiated has a Clone() member function. The programmer decides to do this
by requiring that classes offering such a Clone() must derive from a fixed
Clonable class. Demonstrate how to write this template:</font></p>

<blockquote>
<p><font face="Courier New" color="#999933">template&lt;class T&gt;<br>
class X<br>
{<br>
&nbsp; // ...<br>
};</font></p>
  <p><font color="#999933">a) to require that T be derived from Clonable; and</font></p>
</blockquote>

<p>First, we define a helper template that tests whether a candidate type D is
derived from B. It determines this by determining whether a pointer to D can be
converted to a pointer to B:</p>

<blockquote>
  <p><font face="Courier New">// Example 3(a): An IsDerivedFrom helper<br>
  //<br>
  template&lt;class D, class B&gt;<br>
  class IsDerivedFrom<br>
  {<br>
  private:<br>
  &nbsp; class Yes { char a[1]; };<br>
  &nbsp; class No { char a[10]; };<br>
  <br>
  &nbsp; static Yes Test( B* ); // undefined<br>
  &nbsp; static No Test( ... ); // undefined<br>
  <br>
  public:<br>
  &nbsp; enum { Is = sizeof(Test(static_cast&lt;D*&gt;(0))) == sizeof(Yes) ? 1 :
  0 };<br>
  };</font></p>
</blockquote>
<p>Get it? Think about this code for a moment before reading on.</p>
<p>The above trick relies on three things:</p>
<blockquote>
  <p>- Yes and No have different sizes. I may just be being paranoid, but the
  reason I don't use just char[1] and char[2] is the off chance that the sizes
  of Yes and No might be the same, for example if the compiler happened to
  require that an object's size be a multiple of four bytes. I doubt it would
  ever happen, but I can't see any wording in the standard that would prohibit
  it.</p>
  <p>- Overload resolution and determining the value of sizeof are both
  performed at compile time, not runtime.</p>
  <p>- Enums are initialized, and values can be used, at compile time.</p>
</blockquote>
<p>Let's analyze the enum definition in a little more detail. First, the
innermost part is:</p>
<blockquote>
<p><font face="Courier New">Test(static_cast&lt;D*&gt;(0))</font></p>
</blockquote>
<p>All this does is mention a function named Test and pretend to pass it a D* --
in this case, a suitably cast null pointer will do. Note that nothing is
actually being done here, and no code is being generated, so the pointer is
never dereferenced or for that matter even ever actually created. All we're
doing is creating a typed expression. Now, the compiler knows what D is, and
will apply overload resolution at compile time to decide which of the two
overloads of Test() ought to be chosen: If a D* can be converted to a B*, then
Test( B* ), which returns a Yes, would get selected; otherwise, Test( ... ),
which returns a No, would get selected.</p>
<p>The next step is to check which overload would get selected:</p>
<blockquote>
<p><font face="Courier New">sizeof(Test(static_cast&lt;D*&gt;(0))) ==
sizeof(Yes) ? 1 : 0</font></p>
</blockquote>
<p>This expression, still evaluated entirely at compile time, will yield 1 if a
D* can be converted to a B*, and 0 otherwise. And that's pretty much all we want
to know, because a D* can be converted to a B* if and only if D is derived from
B (or D is the same as B, but we'll plug that hole presently).</p>
<p>So, now that we've calculated what we need to know, we just need to store the
result someplace. The said &quot;someplace&quot; has to be a place that can be
set and the value used all at compile time. Fortunately, an enum fits the bill
nicely:</p>
<blockquote>

<p><font face="Courier New">enum { Is = sizeof(Test(static_cast&lt;D*&gt;(0)))
== sizeof(Yes) ? 1 : 0 };</font></p>

</blockquote>

<p>Finally, there is still that potential hole when D is the same as B, and
depending on the way we plan to use IsDerivedFrom we may not want this template
to report that a class is derived from itself (a lie, if perhaps a benign one in
some applications). If we do need to plug the hole, we can do it easily by
partially specializing the template to say that a class is not derived from
itself:</p>

<blockquote>

<p><font face="Courier New">// Example 3(a), continued<br>
//<br>
template&lt;class T&gt;<br>
class IsDerivedFrom&lt;T,T&gt;<br>
{<br>
public:<br>
&nbsp; enum { Is = 0 };<br>
};</font></p>

</blockquote>

<p>That's it. We can now use this facility to help build an answer to the
question, to wit:</p>

<blockquote>
  <p><font face="Courier New">// Example 3(a), continued: Using IsDerivedFrom<br>
  // to enforce derivation from Clonable<br>
  //<br>
  template&lt;class T&gt;<br>
  class X<br>
  {<br>
  &nbsp; bool ValidateRequirements() const<br>
  &nbsp; {<br>
  &nbsp;&nbsp;&nbsp; // typedef needed because of the ,<br>
  &nbsp;&nbsp;&nbsp; typedef IsDerivedFrom&lt;T, Clonable&gt; Y;&nbsp;<br>
  <br>
  &nbsp;&nbsp;&nbsp; // a runtime check, but one that can be turned<br>
  &nbsp;&nbsp;&nbsp; // into a compile-time check without much work<br>
  &nbsp;&nbsp;&nbsp; assert( Y::Is );<br>
  <br>
  &nbsp;&nbsp;&nbsp; return true;<br>
  &nbsp; }<br>
  <br>
  public:<br>
  &nbsp; // in X's destructor (easier than putting it<br>
  &nbsp; // in every X ctor):<br>
  &nbsp; ~X()<br>
  &nbsp; {<br>
  &nbsp; assert( ValidateRequirements() );<br>
  &nbsp; }<br>
  <br>
  // ...<br>
  };</font></p>
</blockquote>

<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Selecting Alternative Implementations<!--mstheme--></font></h4>

<p>Well, the solution in Example 3(a) is nice and all, and it'll make sure T
must be a Clonable, but what if T isn't a Clonable? What if there were some
alternative action we could take? Perhaps we could make things even more
flexible -- which brings us to the second part of the question.</p>

<blockquote>
  <p><font color="#999933">b) to provide an alternative implementation if T is
  derived from Clonable, and work in some default mode otherwise.</font></p>
</blockquote>

<p>To do this, we introduce the proverbial extra level of indirection, in this
case a helper template. In short, X will use IsDerivedFrom, and use partial
specialization of the helper to switch between is-Clonable and isn't-Clonable
implementations:</p>

<blockquote>
  <p><font face="Courier New">// Example 3(b): Using IsDerivedFrom to make use
  of<br>
  // derivation from Clonable if available, and do<br>
  // something else otherwise.<br>
  //<br>
  template&lt;class T, int&gt;<br>
  class XImpl<br>
  {<br>
  &nbsp; // general case: T is not derived from Clonable<br>
  };<br>
  <br>
  template&lt;class T&gt;<br>
  class XImpl&lt;T, 1&gt;<br>
  {<br>
  &nbsp; // T is derived from Clonable<br>
  };<br>
  <br>
  template&lt;class T&gt;<br>
  class X<br>
  {<br>
  &nbsp; XImpl&lt;T, IsDerivedFrom&lt;T, Clonable&gt;::Is&gt; impl_;<br>
  &nbsp; // ... delegates to impl_ ...<br>
  };</font></p>
</blockquote>

<p>Do you see how this works? Let's work through it with a quick example:</p>

<blockquote>
  <p><font face="Courier New">class MyClonable : public Clonable { /*...*/ };<br>
  <br>
  X&lt;MyClonable&gt; x1;</font></p>
</blockquote>

<p>X&lt;T&gt;'s impl_ has type XImpl&lt;T, IsDerivedFrom&lt;T,
Clonable&gt;::Is&gt;. In this case, T is MyClonable, and so
X&lt;MyClonable&gt;'s impl_ has type XImpl&lt;MyClonable,
IsDerivedFrom&lt;MyClonable, Clonable&gt;::Is&gt;, which evaluates to
XImpl&lt;MyClonable, 1&gt;, which uses the specialization of XImpl that makes
use of the fact that MyClonable is derived from Clonable. But what if we
instantiate X with some other type? Consider:</p>

<blockquote>

<p><font face="Courier New">X&lt;int&gt; x2;</font></p>

</blockquote>
<p>Now T is int, and so X&lt;int&gt;'s impl_ has type XImpl&lt;MyClonable,
IsDerivedFrom&lt;int, Clonable&gt;::Is&gt;, which evaluates to
XImpl&lt;MyClonable, 0&gt;, which uses the unspecialized XImpl. Nifty, isn't it?</p>
<p>Note that at most XImpl&lt;T,0&gt; and XImpl&lt;T,1&gt; will ever be
instantiated for any given T. Even though XImpl's second parameter could
theoretically take any integer value, the way we've set things up here the
integer can only ever be 0 or 1. (In that case, why not use a bool instead of an
int? Extensibility: It doesn't hurt to use an int, and doing so allows
additional alternative implementations to be added easily in the future.)</p>

<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Requirements vs. Traits<!--mstheme--></font></h4>

<p><font color="#999933"><b><font size="4">4.</font></b> Is the approach in #3
the best way to require/detect the availability of a Clone()? Describe
alternatives.</font></p>
<p>The approach in #3 is nifty, but I tend to like traits better in many cases
-- they're about as simple (except when they have to be specialized for every
class in a hierarchy), and they're more extensible as shown in <a href="062.htm">GotW
#62</a>.</p>
<p>The idea is to create a traits template whose sole purpose in life, in this
case, is to implement a Clone() operation. The traits template looks a lot like
XImpl, in that there'll be a general-purpose unspecialized version that does
something general-purpose, and possibly multiple specialized versions that deal
with classes that provide better or just different ways of cloning.</p>

<blockquote>
  <p><font face="Courier New">// Example 4: Using traits instead of
  IsDerivedFrom<br>
  // to make use of Clonability if available, and do<br>
  // something else otherwise. Requires writing a<br>
  // specialization for each Clonable class.<br>
  //<br>
  template&lt;class T&gt;<br>
  class XTraits<br>
  {<br>
  &nbsp; // general case: use copy constructor<br>
  &nbsp; static T* Clone( const T* p )<br>
  &nbsp;&nbsp;&nbsp; { return new T( *p ); }<br>
  };<br>
  <br>
  template&lt;&gt;<br>
  class XTraits&lt;MyClonable&gt;<br>
  {<br>
  &nbsp; // MyClonable is derived from Clonable, so use Clone()<br>
  &nbsp; static MyClonable* Clone( const MyClonable* p )<br>
  &nbsp;&nbsp;&nbsp; { return p-&gt;Clone(); }<br>
  };<br>
  <br>
  // ... etc. for every class derived from Clonable</font></p>
</blockquote>
<p>X&lt;T&gt; then simply calls XTraits&lt;T&gt;::Clone() where appropriate, and
it will do the right thing.</p>
<p>The main difference between traits and the plain old XImpl shown in Example
3(b) is that, with traits, when the user defines some new type the most work
they have to do to use it with X is to specialize the traits template to
&quot;do the right thing&quot; for the new type. That's more extensible than the
relatively hard-wired approach in #3 above, which does all the selection inside
the implementation of XImpl instead of opening it up for extensibility. It also
allows for other cloning methods besides a function specifically named Clone()
inherited from a specifically named base class, and this too provides extra
flexibility.</p>
<p>For more details, including a longer sample implementation of traits for a
very similar example, see <a href="062.htm">GotW #62</a>, Examples 3(c)(i) and
3(c)(ii).</p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Hierarchy-Wide Traits<!--mstheme--></font></h4>
<p>The main drawback of the traits approach above is that it requires individual
specializations for every class in a hierarchy. There are ways to provide traits
for a whole hierarchy of classes at a time, instead of tediously writing lots of
specializations. See Andrei Alexandrescu's excellent column in the June 2000 C++
Report, where he describes a nifty technique to do just this.<b><a href="#5"><sup>[5]</sup></a></b>
Andrei's technique requires minor surgery on the base class of the outside class
hierarchy, in this case Clonable. It would be nice if we could specialize
XTraits for the whole Clonable hierarchy in one shot without requiring any
change to Clonable -- this is a topic for a potential future issue of GotW.</p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Inheritance vs. Traits<!--mstheme--></font></h4>

<p><font color="#999933"><b><font size="4">5.</font></b> Can a template benefit
significantly from knowing that is parameter type T is inherited from some other
type, in a way that could not be achieved at least as well otherwise without the
inheritance relationship?</font></p>

<p>As far as I can tell at this writing, there is little extra benefit a
template can gain from knowing that one of its template parameters is derived
from some given base class that the template couldn't gain more extensibly via
traits. The only real drawback to using traits is that it can require writing
lots of traits specializations to handle many classes in a big hierarchy, but
there are techniques that mitigate or eliminate this drawback.</p>
<p>A principal motivator for this GotW issue was to demonstrate that &quot;using
inheritance for categorization in templates&quot; is perhaps not as necessary a
reason to use inheritance as some have thought. Traits provide a more general
mechanism that's much more extensible when it comes time to instantiate an
existing template on new types, such as types that come from a third-party
library, that may not be easy to derive from a foreordained base class.</p>

<p>&nbsp;</p>

<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Notes<!--mstheme--></font></h4>
<p><a name="1"></a>1. H. Sutter. <b><a href="../publications/xc++.htm">Exceptional
C++</a></b> (Addison-Wesley, 2000).</p>
<p><a name="2"></a>2. Available at <a href="062.htm">http://www.gotw.ca/gotw/062.htm</a>.</p>
<p><a name="3"></a>3. I'm not sure that all compilers get this rule right yet.
Yours may well instantiate all functions, not just the ones that are used.</p>
<p><a name="4"></a>4. A. Alexandrescu. <b><a href="http://www.cuj.com/experts/1810/alexandr.htm" target="_blank">&quot;Mappings Between Types and
Values&quot;</a></b> (<i>C/C++ Users Journal</i> C++ Experts Forum, October
2000).</p>
<p><a name="5"></a>5. A. Alexandrescu. <b>&quot;Traits on Steroids&quot;</b> (<i>C++
Report</i> 12(6), June 2000).</p>
<!--mstheme--></font><!--msnavigation--></td></tr><!--msnavigation--></table><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td><!--mstheme--><font face="Arial, Arial, Helvetica"><h4 align="right"><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666"><a href="../copyright.htm"><font size="2">Copyright ©
2002 Herb Sutter</font></a><!--mstheme--></font></h4>

<!--mstheme--></font></td></tr><!--msnavigation--></table></body>
</html>

