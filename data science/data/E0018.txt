ID=E0018
URL=http://www.gotw.ca/gotw/061.htm
SIZE=81627
DATE=12/07/02
TIME=19:16:28
DATASET=C
HTML=
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta http-equiv="Content-Language" content="en-us">


<title>GotW #61: CHALLENGE EDITION: ACID Programming</title>
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<link rel="stylesheet" type="text/css" href="../gotw.css">
<meta name="Microsoft Theme" content="gotw 111, default">
<meta name="Microsoft Border" content="tlb, default">
</head>

<body background="../_themes/gotw/glabkgnd.jpg" bgcolor="#CCFFFF" text="#000000" link="#008080" vlink="#008080" alink="#0000FF"  ><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font><table border="0" cellspacing="0" width="100%">
  <tr>
    <td colspan="2"><!--mstheme--><font face="Arial, Arial, Helvetica"><font size="6"><strong>
    GotW #61</strong></font> <!--mstheme--></font></td>
  </tr>
  <tr>
    <td valign="middle"><!--mstheme--><font face="Arial, Arial, Helvetica">




<p align="left" style="margin-top: 0; margin-bottom: 0">

<script language="JavaScript"><!--
MSFPhover = 
  (((navigator.appName == "Netscape") && 
  (parseInt(navigator.appVersion) >= 3 )) || 
  ((navigator.appName == "Microsoft Internet Explorer") && 
  (parseInt(navigator.appVersion) >= 4 ))); 
function MSFPpreload(img) 
{
  var a=new Image(); a.src=img; return a; 
}
// --></script><script language="JavaScript"><!--
if(MSFPhover) { MSFPnav1n=MSFPpreload("../_derived/home_cmp_gotw110_hbtn.gif"); MSFPnav1h=MSFPpreload("../_derived/home_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav1'].src=MSFPnav1h.src" onmouseout="if(MSFPhover) document['MSFPnav1'].src=MSFPnav1n.src"><img src="../_derived/home_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Home" align="middle" name="MSFPnav1"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav2n=MSFPpreload("../_derived/news.htm_cmp_gotw110_hbtn.gif"); MSFPnav2h=MSFPpreload("../_derived/news.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../news.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav2'].src=MSFPnav2h.src" onmouseout="if(MSFPhover) document['MSFPnav2'].src=MSFPnav2n.src"><img src="../_derived/news.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="News &amp; Events" align="middle" name="MSFPnav2"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav3n=MSFPpreload("../resources/_derived/index.htm_cmp_gotw110_hbtn.gif"); MSFPnav3h=MSFPpreload("../resources/_derived/index.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../resources/index.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav3'].src=MSFPnav3h.src" onmouseout="if(MSFPhover) document['MSFPnav3'].src=MSFPnav3n.src"><img src="../resources/_derived/index.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Community Resources" align="middle" name="MSFPnav3"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav4n=MSFPpreload("../_derived/consulting.htm_cmp_gotw110_hbtn.gif"); MSFPnav4h=MSFPpreload("../_derived/consulting.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../consulting.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav4'].src=MSFPnav4h.src" onmouseout="if(MSFPhover) document['MSFPnav4'].src=MSFPnav4n.src"><img src="../_derived/consulting.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Consulting Services" align="middle" name="MSFPnav4"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav5n=MSFPpreload("../_derived/presentations.htm_cmp_gotw110_hbtn.gif"); MSFPnav5h=MSFPpreload("../_derived/presentations.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../presentations.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav5'].src=MSFPnav5h.src" onmouseout="if(MSFPhover) document['MSFPnav5'].src=MSFPnav5n.src"><img src="../_derived/presentations.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Presentations" align="middle" name="MSFPnav5"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav6n=MSFPpreload("../publications/_derived/index.htm_cmp_gotw110_hbtn.gif"); MSFPnav6h=MSFPpreload("../publications/_derived/index.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../publications/index.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav6'].src=MSFPnav6h.src" onmouseout="if(MSFPhover) document['MSFPnav6'].src=MSFPnav6n.src"><img src="../publications/_derived/index.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Publications" align="middle" name="MSFPnav6"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav7n=MSFPpreload("_derived/index.htm_cmp_gotw110_hbtn.gif"); MSFPnav7h=MSFPpreload("_derived/index.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="index.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav7'].src=MSFPnav7h.src" onmouseout="if(MSFPhover) document['MSFPnav7'].src=MSFPnav7n.src"><img src="_derived/index.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Guru of the Week" align="middle" name="MSFPnav7"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav8n=MSFPpreload("../conv/_derived/index.htm_cmp_gotw110_hbtn.gif"); MSFPnav8h=MSFPpreload("../conv/_derived/index.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../conv/index.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav8'].src=MSFPnav8h.src" onmouseout="if(MSFPhover) document['MSFPnav8'].src=MSFPnav8n.src"><img src="../conv/_derived/index.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Conversations" align="middle" name="MSFPnav8"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav9n=MSFPpreload("../_derived/search.htm_cmp_gotw110_hbtn.gif"); MSFPnav9h=MSFPpreload("../_derived/search.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../search.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav9'].src=MSFPnav9h.src" onmouseout="if(MSFPhover) document['MSFPnav9'].src=MSFPnav9n.src"><img src="../_derived/search.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Search GotW.ca" align="middle" name="MSFPnav9"></a>
</p>




    <!--mstheme--></font></td>
    <td valign="middle"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 0; margin-bottom: 0">
      <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav10n=MSFPpreload("../_derived/back_cmp_gotw110_back.gif"); MSFPnav10h=MSFPpreload("../_derived/back_cmp_gotw110_back_a.gif"); }
// --></script><a href="060.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav10'].src=MSFPnav10h.src" onmouseout="if(MSFPhover) document['MSFPnav10'].src=MSFPnav10n.src"><img src="../_derived/back_cmp_gotw110_back.gif" width="100" height="20" border="0" alt="Prev" name="MSFPnav10"></a><br><script language="JavaScript"><!--
if(MSFPhover) { MSFPnav11n=MSFPpreload("../_derived/up_cmp_gotw110_up.gif"); MSFPnav11h=MSFPpreload("../_derived/up_cmp_gotw110_up_a.gif"); }
// --></script><a href="index.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav11'].src=MSFPnav11h.src" onmouseout="if(MSFPhover) document['MSFPnav11'].src=MSFPnav11n.src"><img src="../_derived/up_cmp_gotw110_up.gif" width="100" height="20" border="0" alt="Up" name="MSFPnav11"></a><br><script language="JavaScript"><!--
if(MSFPhover) { MSFPnav12n=MSFPpreload("../_derived/next_cmp_gotw110_next.gif"); MSFPnav12h=MSFPpreload("../_derived/next_cmp_gotw110_next_a.gif"); }
// --></script><a href="062.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav12'].src=MSFPnav12h.src" onmouseout="if(MSFPhover) document['MSFPnav12'].src=MSFPnav12n.src"><img src="../_derived/next_cmp_gotw110_next.gif" width="100" height="20" border="0" alt="Next" name="MSFPnav12"></a><!--mstheme--></font></td>
  </tr>
  <tr>
    <td height="5" background="../images/bar.gif" colspan="2"><!--mstheme--><font face="Arial, Arial, Helvetica">&nbsp;<!--mstheme--></font></td>
  </tr>
</table><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font></td></tr><!--msnavigation--></table><!--msnavigation--><table dir="ltr" border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td valign="top" width="1%"><!--mstheme--><font face="Arial, Arial, Helvetica">

<!--mstheme--></font><table border="0" cellspacing="0" bgcolor="#000000" cellpadding="0">
  <tr>
    <td><!--mstheme--><font face="Arial, Arial, Helvetica">
    <!--mstheme--></font><table border="0" cellpadding="2" cellspacing="1" width="100%" height="483">
        <tr>
          <td align="center" bgcolor="#000000" colspan="2" height="16"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin-top: 0; margin-bottom: 0"><a href="../news.htm"><b><font color="#FFFF00">News</font></b></a><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="center" bgcolor="#CCCCCC" bordercolor="#CCCCCC" rowspan="3"><!--mstheme--><font face="Arial, Arial, Helvetica">
          <font size="1" color="#0000FF">J<br>
          U<br>
          L<br>
          Y</font><!--mstheme--></font></td>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin-left: 3; margin-right: 3; margin-top: 0" align="center"><font size="1" color="#0000FF">
            Print articles newly available online</font><!--mstheme--></font><table border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%" id="AutoNumber1" bgcolor="#FFFFCC" bordercolordark="#006666" bordercolorlight="#99CCCC">
              <tr>
                <td width="100%" bordercolor="#808000"><!--mstheme--><font face="Arial, Arial, Helvetica">
                <p style="margin: 3"><font size="1" color="#0000FF">
                <a href="../publications/mill20.htm"><b><i>
                <font color="#0000FF">Sutter's Mill</font></i></b><font color="#0000FF"> 
                column, &quot;Toward a Standard C++ Library, Part 1&quot;</font></a></font><!--mstheme--></font></td>
              </tr>
              <tr>
                <td width="100%" bordercolor="#808000" bgcolor="#FFFFCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
                <p style="margin: 3"><font size="1" color="#0000FF">
                <a href="../publications/mxc++-item-4.htm">
                <font color="#0000FF">Excerpt from MXC++, &quot;Extensible Templates: 
                Via Inheritance or Traits?&quot;</font></a></font><!--mstheme--></font></td>
              </tr>
              <tr>
                <td width="100%" bordercolor="#808000"><!--mstheme--><font face="Arial, Arial, Helvetica">
                <p style="margin: 3"><font size="1" color="#0000FF">
                <a href="../publications/mcd_review.htm"><font color="#0000FF">
                Book Review: Modern C++ Design</font></a></font><!--mstheme--></font></td>
              </tr>
              <tr>
                <td width="100%" bordercolor="#808000"><!--mstheme--><font face="Arial, Arial, Helvetica">
                <p style="margin: 3"><font size="1" color="#0000FF">
                <a href="../publications/mill21.htm"><b><i>
                <font color="#0000FF">Sutter's Mill</font></i></b><font color="#0000FF"> 
                column, &quot;Toward a Standard C++ Library, Part 2: Namespaceops and 
                Library Versioning&quot;</font></a></font><!--mstheme--></font></td>
              </tr>
            </table><!--mstheme--><font face="Arial, Arial, Helvetica">
          <!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin: 0 3"><font size="1" color="#0000FF"><b><i>Sutter's 
            Mill</i></b> column,
            &quot;A Pragmatic Look at Exception Specifications&quot;<br>
            </font><font size="1" color="#000080">The usefulness, or lack 
            thereof, of exception specifications, and how results can vary 
            across real-world compilers</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin: 0 3">
            <a target="_blank" href="http://www.cuj.com/experts/2007/hyslop.htm"><font size="1" color="#0000FF"><i><b>Conversations</b></i> column,
            &quot;Getting to the Point&quot;</font></a><font color="#0000FF" size="1"><br>
            </font><font size="1" color="#000080">The Boost library has five 
            smart pointers that provide a rich array [sic] of useful behaviors.</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="center" bgcolor="#CCCCCC" bordercolor="#CCCCCC" rowspan="2"><!--mstheme--><font face="Arial, Arial, Helvetica"><font color="#0000FF" size="1">A<br>
            U<br>
          G<br>
          U<br>
          S<br>
          T</font><!--mstheme--></font></td>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin:0 3; ">
            <a target="_blank" href="http://www.cuj.com/experts/2008/sutter.htm"><i><b><font size="1" color="#0000FF">The New C++</font></b></i> <font size="1" color="#0000FF">
            column, &quot;Smart(er) Pointers&quot;</font></a><font size="1" color="#000080"><br>
            A closer look at one of the proposed new standard C++ library 
            features -- smart pointers, particularly those in Boost and Loki, 
            and a sneak peek at the usefulness of the proposed typedef templates</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
          <p style="margin:0 3; ">
          <a target="_blank" href="http://www.cuj.com/experts/2008/hyslop.htm"><font size="1" color="#0000FF"><i><b>Conversations</b></i> column,
            &quot;A Midsummer Night's Madness&quot;</font></a><font color="#0000FF" size="1"><br>
            </font><font size="1" color="#000080">A brew that mixes pointers, 
          typedefs, and const</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="center" bgcolor="#CCCCCC" bordercolor="#CCCCCC" rowspan="3"><!--mstheme--><font face="Arial, Arial, Helvetica">
          <p style="margin-top: 0; margin-bottom: 0">
          <font size="1" color="#0000FF">S<br>
          E<br>
          P<br>
          T<br>
          E<br>
          M<br>
          B<br>
          E<br>
          R</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin: 0 3">
            <font size="1" color="#0000FF">&quot;Standard C++ Meets Managed C++&quot;<br>
            </font><font size="1" color="#000080">A survey of the main (in)compatibilities 
            between Standard C++ and Microsoft’s managed extensions for C++, and 
            how the two could converge</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin: 0 3"><font size="1" color="#0000FF"><b><i>Sutter's 
            Mill</i></b> column,
            &quot;Export Restrictions, Part 1&quot;<br>
            </font><font size="1" color="#000080">The scoop on export -- what 
            some people think it does, what it actually does, and why it’s the 
            most widely-ignored feature in the C++ standard</font><!--mstheme--></font></td>
        </tr>
      </table><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font></td>
  </tr>
</table><!--mstheme--><font face="Arial, Arial, Helvetica">
<p style="margin-top: 0; margin-bottom: 0">
<img border="0" src="../images/140.gif" width="140" height="1"></p>

<!--mstheme--></font></td><td valign="top" width="24"></td><!--msnavigation--><td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <h2><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">CHALLENGE EDITION: ACID Programming&nbsp;<font size="3"><br>
      Difficulty: 10 / 10</font><!--mstheme--></font></h2>
<p><i>What are the similarities and differences in reasoning about exception
safety in particular, and program safety in general? Is it possible to
generalize an approach that encompasses general program correctness analysis,
both in C++ and in other languages? And what guidelines can we extrapolate that
will help improve our day-to-day programming? For answers, see this first-ever
&quot;10/10 difficult&quot; issue of GotW.</i></p>
<p align="center"><img border="0" src="../images/h-line.gif" width="248" height="2"></p>

<h3><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Problem<!--mstheme--></font></h3>

<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Preface<!--mstheme--></font></h4>
<p>In this issue of GotW, I want to suggest a new approach to program
correctness analysis that covers both &quot;normal&quot; correctness (i.e., in
the absence of exceptions) and exception safety analysis in C++ and other
languages. Hopefully it is useful, and if so then it will doubtless be subject
to refinement; no one ever bothers to refine unuseful ideas.</p>
<p>The purpose of this GotW is to define a taxonomy to better describe exception
safety, and to see whether it can provide us with new ways of reasoning about
program correctness. If successful, the method should meet the following goals:</p>
<!--mstheme--></font><!--msthemelist--><table border="0" cellpadding="0" cellspacing="0" width="100%">
  <!--msthemelist--><tr><td valign="baseline" width="42"><img src="../_themes/gotw/aglabul1.gif" width="15" height="15" hspace="13" alt="bullet"></td><td valign="top" width="100%"><!--mstheme--><font face="Arial, Arial, Helvetica">
    <p style="margin-top: 0; margin-bottom: 6">It should be inclusive of
    existing work, covering existing exception safety analysis methods.<!--mstheme--></font><!--msthemelist--></td></tr>
  <!--msthemelist--><tr><td valign="baseline" width="42"><img src="../_themes/gotw/aglabul1.gif" width="15" height="15" hspace="13" alt="bullet"></td><td valign="top" width="100%"><!--mstheme--><font face="Arial, Arial, Helvetica">
    <p style="margin-top: 0; margin-bottom: 6">It should help to fill holes in
    existing methods, such as a situation where given sample code was known to
    support some exception-safety guarantee but that guarantee could not be
    adequately described using the existing models alone.<!--mstheme--></font><!--msthemelist--></td></tr>
  <!--msthemelist--><tr><td valign="baseline" width="42"><img src="../_themes/gotw/aglabul1.gif" width="15" height="15" hspace="13" alt="bullet"></td><td valign="top" width="100%"><!--mstheme--><font face="Arial, Arial, Helvetica">
    <p style="margin-top: 0; margin-bottom: 6">It should help us reason about
    and analyze the safety of code, making it less a craft and more a methodical
    engineering task.<!--mstheme--></font><!--msthemelist--></td></tr>
<!--msthemelist--></table><!--mstheme--><font face="Arial, Arial, Helvetica">
<p>This brings us to the GotW questions:</p>

<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">JG Questions<!--mstheme--></font></h4>
<p><b><font size="4">1.</font></b>   Consider again the Abrahams exception
safety guarantees, as frequently described in GotW, and any others that you may
know of. Then, review the technique described in <a href="059.htm"> GotW #59</a> (Question #4 and
Conclusion #2). Which Abrahams (or other) guarantee does that technique provide?
Discuss.</p>
<p><b><font size="4">2.</font></b>   In the context of databases, what do the
following terms mean:</p>
<blockquote>
  <p>a) transaction</p>
  <p>b) ACID</p>
</blockquote>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Guru Questions<!--mstheme--></font></h4>
<p><b><font size="4">3.</font></b>   The key insight is to notice that ACID
transactional analysis can be applied to program correctness, including C++
exception safety. Demonstrate a parallel between the two by showing a
programming analog for each aspect of ACID.</p>
<p><b><font size="4">4.</font></b>   Treat the analysis from Question #3 as a
taxonomy and use it to describe the Abrahams and other prior guarantees.
Discuss.</p>
<p><b><font size="4">5.</font></b> Does the answer from Question #4 equip us to
give a better answer to Question #1? Explain.</p>
<p align="center"><img border="0" src="../images/h-line.gif" width="248" height="2"></p>
<h3><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666"><a name="Solution"></a>Solution<!--mstheme--></font></h3>

<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">INTRODUCTION<!--mstheme--></font></h4>

<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Exception Safety Recap<!--mstheme--></font></h4>

<p>&nbsp;</p>

<p><font color="#999933"><b><font size="4">1.</font></b>   Consider again the
Abrahams exception safety guarantees, as frequently described in GotW, and any
others that you may know of.</font></p>
<p>Recapping from <a href="059.htm"> GotW #59</a>, Dave Abrahams' guarantees are usually stated as
follows.</p>
<blockquote>
  <p><b>A1.</b> Basic Guarantee: If an exception is thrown, no resources are
  leaked, and objects remain in a destructible and usable -- but not necessarily
  predictable -- state. This is considered by many to be the weakest usable
  exception safety guarantee, and is appropriate where client code can cope with
  failed operations that have already made changes to objects' state.</p>
</blockquote>
<p>A point I want to make here is that this essentially means &quot;there are no
bugs.&quot; It's not much different from saying: &quot;If an error occurs, no
resources are leaked, and objects remain in a destructible and usable -- not not
necessarily predictable -- state.&quot;</p>
<p>For example, consider a Container::AppendElements() operation that appends
multiple elements onto the end of an existing container. If called to append 10
elements, and it successfully adds 6 elements before encountering an error and
stopping, then the operation provides only the basic guarantee: The container is
still in a consistent state (it still meets the Container invariants, and
further operations on the container will work fine), but the state is not
necessarily predictable (the caller probably has no way to know in advance what
the final state will be if an error is encountered; it may or may not be the
initial state).</p>
<blockquote>
  <p><b>A2.</b> Strong Guarantee: If an exception is thrown, program state
  remains unchanged. This guarantee always implies global commit-or-rollback
  semantics, including that no references or iterators into a container be
  invalidated if an operation fails.</p>
</blockquote>
<p>Note that here we are already heading toward transactional semantics.</p>
<p>In addition, certain functions must provide an even stricter guarantee in
order to make the above exception safety guarantees possible in higher
functions:</p>
<blockquote>
  <p><b>A3.</b> Nothrow Guarantee: The function will not emit an exception under
  any circumstances. It turns out that it is sometimes impossible to implement
  the strong or even the basic guarantee unless certain functions are guaranteed
  not to throw (e.g., destructors, deallocation functions). For example, an
  important feature of the standard auto_ptr is that no auto_ptr operation will
  throw.</p>
</blockquote>
<p>Other experts have also proposed exception safety guarantees. Building on
earlier work by Harald Mueller<b><a href="#2"><sup>[2]</sup></a></b>, Jack
Reeves<b><a href="#3"><sup>[3]</sup></a></b> suggested three guarantees
regarding the state of an object after an exception had occurred:</p>
<blockquote>
  <p><b>R1.</b> Good: The object meets its invariants.</p>
  <p><b>R2.</b> Bad: The object has been corrupted in that it no longer meets
  its invariants, and the only thing that you are guaranteed to be able to
  safely do with it is destroy it.</p>
  <p><b>R3.</b> Undefined: The object is throughly corrupted and cannot be
  safely used or even destroyed.</p>
</blockquote>
<p>Over the years, other possible guarantees have been suggested, notably the
&quot;destructible guarantee,&quot; which is another way of saying that if an
exception occurs then an object is in Reeves' &quot;Bad&quot; state.</p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Analyzing a Motivating Example<!--mstheme--></font></h4>
<p><font color="#999933">Then, review the technique described in <a href="059.htm"> GotW #59</a>
(Question #4 and Conclusion #2). Which Abrahams (or other) guarantee does that
technique provide? Discuss.</font></p>

<p>In <a href="059.htm"> GotW #59</a>, the main technique presented was that a class contain its member
objects by auto_ptr&lt;Pimpl&gt; rather than directly by value:</p>

<blockquote>
  <p><font face="Courier New">// The general solution to<br>
  // Cargill's Widget Example<br>
  //<br>
  class Widget<br>
  {<br>
  &nbsp; // ...<br>
  private:<br>
  &nbsp; class Impl;<br>
  &nbsp; auto_ptr&lt;Impl&gt; pimpl_;<br>
  &nbsp; // ... provide destruction, copy construction<br>
  &nbsp; // and assignment that work correctly, or<br>
  &nbsp; // suppress them ...<br>
  };<br>
  <br>
  class Widget::Impl<br>
  {<br>
  public:<br>
  &nbsp; // ...<br>
  &nbsp; T1 t1_;<br>
  &nbsp; T2 t2_;<br>
  };<br>
  <br>
  void Widget::Swap( Widget&amp; other ) throw()<br>
  {<br>
  &nbsp; auto_ptr&lt;Impl&gt; temp( pimpl_ );<br>
  &nbsp; pimpl_ = other.pimpl_;<br>
  &nbsp; other.pimpl_ = temp;<br>
  }<br>
  <br>
  Widget&amp; Widget::operator=( const Widget&amp; other )<br>
  {<br>
  &nbsp; Widget temp( other ); // do all work off to the side<br>
  <br>
  &nbsp; Swap( temp ); // then &quot;commit&quot; the work using<br>
  &nbsp; return *this; // nonthrowing operations only<br>
  }</font></p>
</blockquote>
<p>See <a href="059.htm"> GotW #59</a> for further details.</p>
<p>Now we get to the crux of the matter: That GotW then made the claim that the
above Widget::operator=() provides the strong guarantee without any
exception-safety requirements on T1 and T2. As Dave Abrahams has pointed out,
this isn't quite true: For example, if constructing a T1 or T2 object causes
side effects (such as changing a global variable or launching a rocket) and then
throws an exception, and that side effect is not cancelled by the corresponding
T1 or T2 destructor, then Widget::operator=() has caused a side effect and so
doesn't fully meet the requirements of the strong guarantee. (It does fully meet
the requirements of the strong guarantee in all other ways besides the
possibility of side effects.)</p>
<p>So here's the rub: The above solution to Cargill's Widget Example is an
important technique, it does provide a safety guarantee, and that guarantee
appears to be a fundamental concept -- it is the strongest exception safety
guarantee one can make for assignment without requiring any assumptions at all
about the used type (more on this below). Better still, it is a useful guarantee
to be able to make; for example, it is useful to know that upon failure a change
to a container object will produce no local effects on the container, even
though it might invalidate existing iterators into the container. More on this
in the final section.</p>
<p>So, since it is a guarantee, what guarantee is it? It doesn't meet the
requirements of the Abrahams strong or nothrow guarantees, but at the same time
it seems to give more than just the Abrahams basic guarantee or the Reeves Good
guarantee.</p>
<p>There's got to be a name for a concept as useful and as fundamental as
&quot;the strongest guarantee you can make without requiring assumptions about
the used type&quot; -- and that's not a name, that's just an explanation. It
bothered me greatly that we had no succinct name for it.</p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">TOWARD TRANSACTIONAL PROGRAMMING&nbsp;<!--mstheme--></font></h4>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Ideas From the Database World<!--mstheme--></font></h4>
<p>Could another area of computer science yield any insights that would help? To
introduce the answer, let's take a quick trip into the database world and its
existing methods of analyzing program correctness with respect to database
manipulation:</p>
<p><font color="#999933"><b><font size="4">2.</font></b>   In the context of
databases, what do the following terms mean:</font></p>
<blockquote>
  <p><font color="#999933">a) transaction</font></p>
</blockquote>

<p>A transaction is a unit of work. That is, it accomplishes some task
(typically involving multiple database changes) in such a way that it meets the
ACID requirements to a specified degree appropriate for its particular task:</p>

<blockquote>
  <p><font color="#999933">b) ACID</font></p>
</blockquote>
<p>ACID is an acronym for a set of four requirements:</p>

<div align="center">
  <center>
  <!--mstheme--></font><table border="0" cellpadding="6" cellspacing="0">
    <tr>
      <td bgcolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica"><b><font color="#FFFFCC">Requirement</font></b><!--mstheme--></font></td>
      <td bgcolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica"><font color="#FFFFCC"><b>Description (Databases)</b></font><!--mstheme--></font></td>
    </tr>
    <tr>
      <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
        <p style="margin-top: 6; margin-bottom: 0"><b>Atomicity</b><!--mstheme--></font></td>
      <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
        <p style="margin-top: 6; margin-bottom: 0">The operation is indivisible,
        all-or- nothing. A transaction can be &quot;committed&quot; or
        &quot;rolled back&quot;; if it is committed all of its effects must
        complete fully, otherwise if it is rolled back it must have no effect.<!--mstheme--></font></td>
    </tr>
    <tr>
      <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
        <p style="margin-top: 6; margin-bottom: 0"><b>Consistency</b><!--mstheme--></font></td>
      <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
        <p style="margin-top: 6; margin-bottom: 0">The transaction transforms
        the database from one consistent state to another consistent state. Here
        &quot;consistent&quot; implies obeying not just relational integrity
        constraints but also business rules and semantics, such as that a given
        Customer record's Address and ZIP fields must not specify inconsistent
        information (e.g., an address in New York and a ZIP code in Alabama).<!--mstheme--></font></td>
    </tr>
    <tr>
      <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
        <p style="margin-top: 6; margin-bottom: 0"><b>Isolation</b><!--mstheme--></font></td>
      <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
        <p style="margin-top: 6; margin-bottom: 0">Two transactions are fully
        isolated if they can be started simultaneously and the result is
        guaranteed to be the same as though one was run entirely before the
        other (&quot;Serializable&quot;). In practice, databases support various
        levels of isolation, each of which trades off better isolation at the
        expense of concurrency or vice versa. Some typical isolation levels, in
        order from best to worst concurrency, are: Read Uncommitted (a.k.a.
        Dirty Read), Read Committed, Repeatable Read, and Serializable (highest
        isolation), and describe what kinds of intermediate states of other
        transactions might be visible.<!--mstheme--></font></td>
    </tr>
    <tr>
      <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
        <p style="margin-top: 6; margin-bottom: 0"><b>Durability</b><!--mstheme--></font></td>
      <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
        <p style="margin-top: 6; margin-bottom: 0">If a transaction is
        committed, its effects are not lost even if there is a subsequent system
        crash. This requirement is usually implemented using a transaction log
        which is used to &quot;roll forward&quot; the state of the database on
        system restart.<!--mstheme--></font></td>
    </tr>
  </table><!--mstheme--><font face="Arial, Arial, Helvetica">
  </center>
</div>
<p>Note 1: Two transactions operating on nonoverlapping parts of the database
are by definition always fully isolated.</p>
<p>The following notes show why isolation is disproportionately important:</p>
<p>Note 2: Isolation interacts with atomicity. For example, consider three
transactions T1, T2, and T3 that run concurrently. All three are atomic. T1 and
T2 run at Serializable isolation and do not interact with each other; that is,
because of their isolation levels, T1 and T2 are also guaranteed to be atomic
with respect to each other. T3, however, runs at Read Uncommitted isolation, and
it is possible for T3 to see some but not all of the changes made by T1 and T2
before those other transactions commit; that is, because of its isomation level,
T1 and T2 are NOT atomic as seen by T3.</p>
<p>Note 3: Because isolation interacts with atomicity, it also transitively
interacts with consistency. This is because lower isolation levels may permit
states to be seen by other transactions that would not otherwise be visible, and
relying carelessly on such intermediate states can create inconsistencies in the
database. For example, consider what could happen if transaction T4 observes
some intermediate state of transaction T5, makes a change based on that observed
state, but T5 is subsequently rolled back. Now T4 has made further changes based
on phantom data that, as it turns out, never really existed.</p>
<p>For more information, see a standard database text like Date's <i>An
Introduction to Database Systems.</i><b><a href="#4"><sup>[4]</sup></a></b></p>
<p>In the database world, atomicity, consistency, and durability are always
fully required in most real-world database systems. It is the isolation aspect
that offers tradeoffs for concurrency (and, as noted, the tradeoffs can
indirectly affect atomicity and consistency too). In practice, running at
anything less than Serializable isolation opens windows wherein the database
could get into a state that violates business rules (and hence the consistency
requirement), but it's done all the time. In short, we live with this quite
happily today, even in some financial database systems with stringent integrity
requirements, because we can measure the exposure and we accept the tradeoff in
order to achieve better concurrency. Nearly all production databases in the
world run at less than the strongest isolation levels at least some of the time.</p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Mapping ACID Concepts to Non-SQL Programming<!--mstheme--></font></h4>
<p>Note that in the following discussion, for an operation to &quot;fail&quot;
can mean fail in any way, so that the analysis is the same whether the failure
is reported by an error return code or by an exception.</p>
<p><font color="#999933"><b><font size="4">3.</font></b>   The key insight is to
notice that ACID transactional analysis can be applied to program correctness,
including C++ exception safety. Demonstrate a parallel between the two by
showing a programming analog for each aspect of ACID.</font></p>
<p>The elements of ACID were developed to describe requirements in database
environments, but each has analogs that make sense in programming environments.
Note that these analogs apply to reasoning about program correctness in general,
both with and without exceptions and including exception support in other
languages, not just to C++ exception handling.</p>
<p>The following analysis distinguishes between local effects and side effects:</p>
<blockquote>
  <p>1. <b>Local effects </b>include all effects on the visible state of the
  immediate object(s) being manipulated. Here the visible state is defined as
  the state visible through member functions as well as free functions (e.g.,
  operator&lt;&lt;()) that form part of the interface. For more on what
  constitutes the interface of a type, see the Interface Principle as described
  in my original IP article<b><a href="#5"><sup>[5]</sup></a></b> and in Items
  31-34 of <i><a href="../publications/xc++.htm">Exceptional C++</a></i><b><a href="#6"><sup>[6]</sup></a></b>.</p>
  <p>2. <b>Side effects </b>include all other changes, specifically changes to
  other program states and structures as well as any changes caused outside the
  program (such as invalidating an iterator into a manipulated container,
  writing to a disk file, or launching a rocket), that affect the system's
  business rules, as they are expressed in object and system invariants. So, for
  example, a counter of the number of times a certain function is called would
  normally not be considered a side effect on the state of the system if the
  counter is simply a debugging aid; it would be a side effect on the state of
  the system if it recorded something like the number of transactions made in a
  bank account, because that affects business rules or program invariants. Note:
  In this article I use the terms &quot;business rules&quot; and
  &quot;invariants&quot; interchangeably.</p>
</blockquote>
<p>Of course, if an effect is visible as a side effect but also through the
manipulated object's interface (such as via ReadByte() or WasLaunched()
functions), it is both a local effect and a side effect.</p>
<p>I propose that the following descriptions of the ACID requirements may be
suitable for describing program correctness in general and exception safety in
particular. They form four fundamental axes of ACID exception safety analysis:</p>
<!--mstheme--></font><table border="0" cellpadding="6" cellspacing="0">
  <tr>
    <td bgcolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica"><b><font color="#FFFFCC">Requirement</font></b><!--mstheme--></font></td>
    <td bgcolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica"><font color="#FFFFCC"><b>Description (Programming)</b></font><!--mstheme--></font></td>
  </tr>
  <tr>
    <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 6; margin-bottom: 0"><b>Atomicity</b><!--mstheme--></font></td>
    <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 6; margin-bottom: 0">The operation is indivisible,
      all-or- nothing, with respect to local effects.<!--mstheme--></font></td>
  </tr>
  <tr>
    <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 6; margin-bottom: 0"><b>Consistency</b><!--mstheme--></font></td>
    <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 6; margin-bottom: 0">The operation transforms system
      from one consistent state to another consistent state. Here
      &quot;consistent&quot; implies obeying not just object integrity
      constraints (i.e., objects continue to fulfill their invariants) but also
      wider system invariants. Note &quot;no [memory or resource] leaks&quot; is
      usually a required program invariant.<!--mstheme--></font></td>
  </tr>
</table><!--mstheme--><font face="Arial, Arial, Helvetica">
<p>Before tackling Isolation, a note: In the database world, isolation is often
all about concurrency -- that is, access and manipulation of the same data
elements by different transactions operating concurrently. The same concepts we
use to describe database transaction isolation map directly onto multithreaded
and multiprocess access and manipulation of shared resources; the same issues
apply -- read locks, write locks, read/write locks, deadlocks, livelocks, and
similar issues.</p>
<p>There is a difference, however, between relational databases and programs.
Standard relational database systems provide direct support in the database
engine to enforce isolation options such as &quot;Read Committed&quot; by
automatically creating, maintaining, and freeing locks on individual data
objects. They can do this because the engine &quot;owns,&quot; or acts as an
arbiter and access point for, all the data. No such support exists in most
programming languages (including C++ and Java; Java has some thread safety
primitives, but they are not very useful and do not actually solve the thread
safety problem even in simple cases). In languages like C++ and Java, if you
want locking you have to do it yourself in an application-specific way by
manually writing calls to acquire and release locks on program resources like
shared variables.</p>
<!--mstheme--></font><table border="0" cellpadding="6" cellspacing="0">
  <tr>
    <td bgcolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica"><b><font color="#FFFFCC">Requirement</font></b><!--mstheme--></font></td>
    <td bgcolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica"><font color="#FFFFCC"><b>Description (Programming)</b></font><!--mstheme--></font></td>
  </tr>
  <tr>
    <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 6; margin-bottom: 0"><b>Isolation</b><!--mstheme--></font></td>
    <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 6; margin-bottom: 0">Two operations are fully
      isolated if they can be started simultaneously and the result is
      guaranteed to be the same as though one was run entirely before the other
      (&quot;Serializable&quot;). In practice, programs implement various levels
      of isolation, each of which trades off better isolation at the expense of
      concurrency or vice versa. Some typical isolation levels, in order from
      best to worst concurrency, are: Read Uncommitted (a.k.a. Dirty Read), Read
      Committed, Repeatable Read, and Serializable (highest isolation), and
      describe what kinds of intermediate states of other operations might be
      visible.<!--mstheme--></font></td>
  </tr>
</table><!--mstheme--><font face="Arial, Arial, Helvetica">
<p>Interestingly, however, note that concurrency isolation issues only arise
between transactions manipulating the same data; so, as already noted earlier,
isolation is fundamentally concerned with not only concurrency, but interaction
of side effects. As Note 1 above stated: two transactions operating on
nonoverlapping parts of the database are by definition always fully isolated.</p>
<p>In the interests of space, this article does not pursue concurrency issues in
depth (which would be a lengthy discussion beyond the immediate scope of the
article), except to note the following: The ACID program analysis method
proposed in this article can be directly extended to address concurrency issues
in the same way that those issues are addressed in database environments, with
the caveat that most programming languages do not provide the same native
support provided inherently by relational database management systems for basic
concurrency control and that these must therefore be implemented by the
application. A later article will expand on this wider aspect of isolation.</p>
<p>This article then focuses specifically on the aspects of isolation of
interest in a nonshared/serialized environment, namely the interaction of side
effects:</p>
<!--mstheme--></font><table border="0" cellpadding="6" cellspacing="0">
  <tr>
    <td bgcolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica"><b><font color="#FFFFCC">Requirement</font></b><!--mstheme--></font></td>
    <td bgcolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica"><font color="#FFFFCC"><b>Description (Programming)</b></font><!--mstheme--></font></td>
  </tr>
  <tr>
    <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 6; margin-bottom: 0"><b>Isolation (continued)</b><!--mstheme--></font></td>
    <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 6; margin-bottom: 0">Regardless of threading and
      other (continued) concurrency issues, an operation on one or more objects
      is fully isolated if it does not cause side effects (i.e., only causes
      local effects on those objects).<!--mstheme--></font></td>
  </tr>
  <tr>
    <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 6; margin-bottom: 0"><b>Durability</b><!--mstheme--></font></td>
    <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 6; margin-bottom: 0">If an operation completes
      successfully, all its effects are preserved even if there is a subsequent
      system crash. For example, a rocket once fired stays in flight even if the
      launching software in the submarine crashes afterwards.<!--mstheme--></font></td>
  </tr>
</table><!--mstheme--><font face="Arial, Arial, Helvetica">
<p>Here's a difference: In the database world, atomicity, consistency, and
durability are always fully required and it is usually isolation that is traded
off (with some indirect effects on atomicity and consistency). In the
programming world, atomicity is normally assumed (but if there are asynchronous
interrupts or exceptions, atomicity has to be explicity programmed for),
consistency in terms of maintain invariants is also normally assumed, and
durability is not often considered except in database-like applications, where
the durability is made the responsibility of an underlying database or file
system.</p>
<p>Really, it looks like what we are building up to is a transactional approach
to program correctness, including C++ exception safety, arrived at by adapting
concepts that are already well-understood in another area of computer science.</p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">A Notation for Safety Guarantees<!--mstheme--></font></h4>
<p>Next, let's analyze the possible statements we can make about each axis. For
each axis, we can make one of three statements:</p>
<blockquote>
  <p>a) that there is no guarantee at all (designated by a dash, '-', or simply
  omitting mention of the guarantee);</p>
  <p>b) a statement about effects if an operation may fail (designated by a
  lowercase letter, such as 'i'); or</p>
  <p>c) in addition to b), a statement about effects if an operation does not or
  cannot fail (designated by an uppercase letter, such as 'I').</p>
</blockquote>
<p>Note that these are true &quot;levels&quot; in that each subsumes the one
before it. I omit a fourth possible case (&quot;a statement about effects if an
operation succeeds [but with no statement about what happens on failure]&quot;)
because it is no better than a) for analyzing failure cases.</p>
<p>Here's what we get:</p>
<!--mstheme--></font><table border="0" cellpadding="6" cellspacing="0">
  <tr>
    <td bgcolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica"><b><font color="#FFFFCC">Level</font></b><!--mstheme--></font></td>
    <td bgcolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica"><font color="#FFFFCC"><b>Description</b></font><!--mstheme--></font></td>
  </tr>
  <tr>
    <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 6; margin-bottom: 0"><b>Atomicity</b><!--mstheme--></font></td>
    <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 6; margin-bottom: 0"><!--mstheme--></font></td>
  </tr>
  <tr>
    <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 6; margin-bottom: 0"><b>-</b><!--mstheme--></font></td>
    <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 6; margin-bottom: 0">No guarantee.<!--mstheme--></font></td>
  </tr>
  <tr>
    <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 6; margin-bottom: 0"><b>a</b><!--mstheme--></font></td>
    <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 6; margin-bottom: 0">If the operation fails, the
      manipulated object(s) are in their initial state, otherwise the
      manipulated object(s) are in their final state.<!--mstheme--></font></td>
  </tr>
  <tr>
    <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 6; margin-bottom: 0"><b>A</b><!--mstheme--></font></td>
    <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 6; margin-bottom: 0">The operation is guaranteed to
      succeed and the manipulated object(s) are in their final state. (For
      exception- related failures, this is spelled &quot;throw()&quot; in C++;
      but an operation could still fail in ways other than throwing an
      exception.)<!--mstheme--></font></td>
  </tr>
  <tr>
    <td valign="top" colspan="2"><!--mstheme--><font face="Arial, Arial, Helvetica">

<p>Note that atomicity as defined here concerns itself only with local effects,
that is, with the state of a directly manipulated object.</p>

    <!--mstheme--></font></td>
  </tr>
  <tr>
    <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 6; margin-bottom: 0"><b>Consistency</b><!--mstheme--></font></td>
    <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 6; margin-bottom: 0"><!--mstheme--></font></td>
  </tr>
  <tr>
    <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 6; margin-bottom: 0"><b>-</b><!--mstheme--></font></td>
    <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 6; margin-bottom: 0">No guarantee.<!--mstheme--></font></td>
  </tr>
  <tr>
    <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 6; margin-bottom: 0"><b>c</b><!--mstheme--></font></td>
    <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 6; margin-bottom: 0">If the operation fails, the
      system is in a consistent state. (Depending whether or not the operation
      also makes some atomicity guarantee, the consistent state may be the
      initial state, the final state, or possibly an intermediate state,
      depending on whether and how a failure occurred.)<!--mstheme--></font></td>
  </tr>
  <tr>
    <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 6; margin-bottom: 0"><b>C</b><!--mstheme--></font></td>
    <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 6; margin-bottom: 0">If the operation succeeds or
      fails, the system is in a consistent state.<!--mstheme--></font></td>
  </tr>
  <tr>
    <td valign="top" colspan="2"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 6; margin-bottom: 0">Any operation that can result
      in objects no longer meeting their invariants should be considered buggy.
      No program safety, let alone exception safety, is possible without a
      guarantee of consistency on success, so the rest of this article will
      generally rely on C. Further, we require that at the beginning of the
      operation the system is in a consistent state, else no reasoning about
      consistency is possible or useful.<!--mstheme--></font></td>
  </tr>
  <tr>
    <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 6; margin-bottom: 0"><b>Isolation</b><!--mstheme--></font></td>
    <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 6; margin-bottom: 0"><!--mstheme--></font></td>
  </tr>
  <tr>
    <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 6; margin-bottom: 0"><b>-</b><!--mstheme--></font></td>
    <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 6; margin-bottom: 0">No guarantee.<!--mstheme--></font></td>
  </tr>
  <tr>
    <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 6; margin-bottom: 0"><b>i</b><!--mstheme--></font></td>
    <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 6; margin-bottom: 0">If the operation fails, there
      will be no side effects.<!--mstheme--></font></td>
  </tr>
  <tr>
    <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 6; margin-bottom: 0"><b>I</b><!--mstheme--></font></td>
    <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 6; margin-bottom: 0">If the operation either
      succeeds or fails, there will be no side effects.<!--mstheme--></font></td>
  </tr>
  <tr>
    <td valign="top" colspan="2"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 6; margin-bottom: 0">Note that isolation as defined
      here concerns itself only with side effects. In many ways it is a mirror
      of atomicity.</p>
      <p>Note that 'a'+'i' =&gt; 'c', because we require that the objects and
      the system were initially in a consistent state.<!--mstheme--></font></td>
  </tr>
  <tr>
    <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 6; margin-bottom: 0"><b>Durability</b><!--mstheme--></font></td>
    <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 6; margin-bottom: 0"><!--mstheme--></font></td>
  </tr>
  <tr>
    <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 6; margin-bottom: 0"><b>-</b><!--mstheme--></font></td>
    <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 6; margin-bottom: 0">No guarantee.<!--mstheme--></font></td>
  </tr>
  <tr>
    <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 6; margin-bottom: 0"><b>d</b><!--mstheme--></font></td>
    <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 6; margin-bottom: 0">If the operation fails,
      whatever state was achieved will persist.<!--mstheme--></font></td>
  </tr>
  <tr>
    <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 6; margin-bottom: 0"><b>D</b><!--mstheme--></font></td>
    <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 6; margin-bottom: 0">If the operation succeeds or
      fails, the state persists.<!--mstheme--></font></td>
  </tr>
</table><!--mstheme--><font face="Arial, Arial, Helvetica">
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Interlude: FAQs and Objections<!--mstheme--></font></h4>
<p>At this point, several questions or objections arise, and it makes sense to
pause briefly and handle them now:</p>
<p>Q: &quot;I think 'c' and 'd' may not be useful, on the grounds that they seem
backward: Shouldn't operations first specify whether they produce consistent
and/or durable results if they succeed, and then optionally what they do if they
fail?&quot;</p>
<p>A: An interesting outgrowth of the above ACID view, then, is that it is
actually more important first to state what operations do if they fail, and only
then to state in addition what they do if they succeed. (I grant that
programmers who find it annoying that their companies force them to document
their functions' failure modes may also dislike the previous statement.)</p>
<p>Q: &quot;The database version of 'atomicity' includes all effects, whereas
the above doesn't. Is that right?&quot;</p>
<p>A: Yes. It is useful in programming to distinguish between local effects and
side effects, and the global atomicity guarantee still exists and is expressed
as &quot;both 'a' and 'i'.&quot;</p>
<p>This last point leads nicely into the question of combining guarantees:</p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">A Notation for Combining Guarantees<!--mstheme--></font></h4>
<p>The four axes of correctness analysis are not entirely independent; one can
affect the other, as for example above 'a'+'i' =&gt; 'c'.</p>
<p>For notational convenience I will designate each combination of guarantee
levels as a 4-tuple (such as &quot;-CID&quot; or &quot;aC-D&quot;), where each
position specifies the level of the atomicity, consistency, isolation, and
durability axis (respectively) that is guaranteed, if any. For convenience, the
'-'s could also be omitted.</p>
<p>This article focuses primarily on the first three axes, so in the following
discussion the durability guarantee level will often be shown as - or omitted.
Because the durability axis is independent of the others, this can be done
without loss of generality.</p>
<p>Note that, if the operation guarantees that it will always succeed (A), then
it is not very meaningful to make a guarantee about what happens if the
operation fails without a guarantee about what happens if the operation succeeds
(c, i, or d). So, for example, in every case where ACi is guaranteed, AC is
equivalent and should be specified instead.</p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">(RE)VIEWING EXISTING APPROACHES THROUGH THE LENS OF TRANSACTIONAL
PROGRAMMING<!--mstheme--></font></h4>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Describing Existing Guarantees as ACID Guarantees<!--mstheme--></font></h4>
<p>The first goal of this taxonomy was that &quot;[i]t should be inclusive of
existing work, covering existing exception safety analysis methods.&quot;</p>

<p>Hence Question #4:</p>

<p><font color="#999933"><b><font size="4">4.</font></b>   Treat the analysis
from Question #3 as a taxonomy and use it to describe the Abrahams and other
prior guarantees. Discuss.</font></p>

<p>The ACID model does indeed provide a concise and explicit notation to
describe the Abrahams guarantees, Reeves' Good, Bad, and Undefined states, and
the destructible guarantee:</p>

<div align="center">
  <center>
  <!--mstheme--></font><table border="0" cellpadding="6" cellspacing="0">
    <tr>
      <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
        <p style="margin-top: 6; margin-bottom: 0"><b>----</b><!--mstheme--></font></td>
      <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
        <p style="margin-top: 6; margin-bottom: 0">Reeves Undefined state
        guarantee</p>
        <p style="margin-top: 6; margin-bottom: 0">Reeves Bad state guarantee</p>
        <p style="margin-top: 6; margin-bottom: 0">Destructible guarantee<!--mstheme--></font></td>
    </tr>
    <tr>
      <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
        <p style="margin-top: 6; margin-bottom: 0"><b>-C--</b><!--mstheme--></font></td>
      <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
        <p style="margin-top: 6; margin-bottom: 0">Abrahams basic guarantee</p>
        <p style="margin-top: 6; margin-bottom: 0">Reeves Good state guarantee<!--mstheme--></font></td>
    </tr>
    <tr>
      <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
        <p style="margin-top: 6; margin-bottom: 0"><b>aCi-</b><!--mstheme--></font></td>
      <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
        <p style="margin-top: 6; margin-bottom: 0">Abrahams strong guarantee<!--mstheme--></font></td>
    </tr>
    <tr>
      <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
        <p style="margin-top: 6; margin-bottom: 0"><b>AC--</b><!--mstheme--></font></td>
      <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
        <p style="margin-top: 6; margin-bottom: 0">Abrahams nothrow guarantee<!--mstheme--></font></td>
    </tr>
  </table><!--mstheme--><font face="Arial, Arial, Helvetica">
  </center>
</div>
<p>Note that this analysis points out at least two weaknesses in prior models:</p>
<p>First, the prior models generally ignored the issue of isolation. Note that
none of the above-listed prior guarantees included I. When using the prior
models we frequently found that we had to add amplifications like, &quot;it
meets the strong guarantee except there could be side effects.&quot;
Descriptions like that implicitly point to missing guarantees, which are now
accounted for above.</p>
<p>Second, the above ACID analysis makes it clear why Mueller's and Reeves'
&quot;Bad&quot; and &quot;Undefined&quot; states, and the sometimes-cited
&quot;destructible&quot; guarantee, are all the same thing from a program
correctness point of view.</p>
<p>I have always thought that the &quot;Bad,&quot; &quot;Undefined,&quot; and
&quot;destructible&quot; ideas had problems. There's nothing magical about
exiting a function via a C++ exception compared to returning an error value
indicating the operation failed, so consider: Say that a programmer on your team
wrote a function that could never throw and just returned a code to indicate
success or failure, and that could leave an object in a state where it no longer
met its invariants (or, even worse, couldn't even be destroyed). Would you
accept the work, or would you send the programmer back to his desk to fix his
bug? I think most of us would agree that the function just described is plainly
buggy (and so is its specification if the specification says it can render
objects invariant-breaking). So why should the answer be any different in the
case of failure reported by throwing an exception? Clearly it shouldn't, and in
fact none of the Bad, Undefined, or destructible &quot;guarantees&quot; really
gives any kind of useful program correctness or safety guarantee, because all
useful program correctness guarantees include at least the concept of preserving
object and system invariants.</p>
<p>[Aside: Consider &quot;Bad&quot; and &quot;destructible&quot; a little
further. If a function f() can leave any object t in a state wherein all you can
ever do is call t's destructor, then f() is a sink in all but name, and might as
well destroy t too.]</p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Filling Holes: ACID and GotW #59<!--mstheme--></font></h4>
<p>The second goal of this taxonomy was that &quot;[i]t should help to fill
holes in existing methods, such as a situation where given sample code was known
to support some exception-safety guarantee but that guarantee could not be
adequately described using the existing models alone.&quot;</p>
<p>This brings us to Question #5:</p>
<p><font color="#999933"><b><font size="4">5.</font></b> Does the answer from
Question #4 equip us to give a better answer to Question #1? Explain.</font></p>

<p>When we considered Question #1, I said that it seems like there ought to be a
name for a concept as fundamental as &quot;the strongest guarantee you can make
(for assignment) without requiring assumptions about the used type.&quot; In the
ACID model, it turns out that there is:</p>

<div align="center">
  <center>
  <!--mstheme--></font><table border="0" cellpadding="6" cellspacing="0">
    <tr>
      <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
        <p style="margin-top: 6; margin-bottom: 0"><b>aC--</b><!--mstheme--></font></td>
      <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
        <p style="margin-top: 6; margin-bottom: 0">The guarantee provided by the
        technique shown in <a href="059.htm"> GotW #59</a>, if T construction and destruction provide
        at least -C-- (which should be a given for correct programs).<!--mstheme--></font></td>
    </tr>
  </table><!--mstheme--><font face="Arial, Arial, Helvetica">
  </center>
</div>
<p>Without making any assumptions about the used type(s), is it possible to make
a stronger guarantee than aC for a generalized assignment operator? I believe it
is possible to show fairly rigorously that the answer is No, as follows:</p>
<p>1. Consider a simplified version of the T::operator=() code.</p>
<blockquote>
  <p><font face="Courier New">// (Simplified) solution to Cargill's Widget
  Example<br>
  //<br>
  class Widget { /*...*/ struct Impl* pimpl_; };<br>
  <br>
  class Widget::Impl { /*...*/ T1 t1_; T2 t2_; };<br>
  <br>
  Widget&amp; Widget::operator=( const Widget&amp; other )<br>
  {<br>
  &nbsp; Impl* temp = new Impl( *other.pimpl_ );<br>
  &nbsp; // construction could fail<br>
  <br>
  &nbsp; delete pimpl_;<br>
  &nbsp; pimpl_ = temp;<br>
  &nbsp; return *this;<br>
  }</font></p>
</blockquote>

<p>As before, the above code invokes the Widget::Impl constructor to create a
new object from the existing one. If the construction fails, C++'s language
rules automatically destroy any fully-constructed subobjects (such as t1_, if
the t2_ construction fails). So we could end up getting any of the following
function call sequences:</p>

<blockquote>

<p>Case 1 (Failure): T1::T1() fails</p>

<p>Case 2 (Failure): T1::T1(), T2::T2() fails, T1::~T1()</p>

<p>Case 3 (Success): T1::T1(), T2::T2()</p>

</blockquote>

<p>2. Consider the C++ language rules. The C++ language rules strictly define
the meaning of construction and destruction (in both cases we assume the
Consistency guarantee because, for example, any type's constructor does not
yield a valid object of that type is just buggy):</p>

<blockquote>
  <p><u>C++ Constructor Guarantee: aC--<br>
  </u>A constructor, if successful, must create a valid object of the indicated
  type; if it fails, it has not created anything.</p>
  <p><u>C++ Destructor Guarantee: AC--<br>
  </u>A destructor destroys a valid object of the indicated type, and so is an
  inverse of any constructor of the same type. Further, a destructor is
  guaranteed to succeed, at least in the sense that the object it operates on is
  considered fully-destroyed, or as-destroyed-as- it-can-ever-be because you
  can't re-run a failed destructor. (Further, the standard requires that any
  destructor used in the standard library may not throw; this includes the
  destructor of any type you can legally instantiate a container with.)</p>
  <p>At any rate, the above solution assumes implicitly that at least T1::~T1()
  guarantees A---, else there is no way to write a correct Widget::operator=()
  anyway. For more on these issues, see Item 16 in <i><a href="../publications/xc++.htm">Exceptional
  C++</a></i><b><a href="#6"><sup>[6]</sup></a></b>.</p>
</blockquote>
<p>3. Analyze Atomicity (i.e., local effects). In each of the two failure cases,
the only local effects are the possible construction or destruction of the t1_
and t2_ member objects, because these are the only objects being directly
manipulated.</p>
<blockquote>
  <p>Case 1 (Failure): T1::T1() fails The only attempted operation promises at
  least 'a' atomicity, so no local effects occur and the entire assignment has
  no local effects.</p>
  <p>Case 2 (Failure): T1::T1(), T2::T2() fails, T1::~T1() T2::T2() promises at
  least 'a' atomicity, so does not have any local effects. But T1::~T1() is
  guaranteed to succeed and undoes all local effects of T1::T1(), and so the
  entire assignment has no local effects.</p>
  <p>Case 3 (Success): T1::T1(), T2::T2() Success, all local effects have been
  successfully produced.</p>
</blockquote>
<p>Failure is possible, but all failure cases have no local effects. Therefore
the assignment's best possible atomicity guarantee level is 'a' -- thanks to the
guarantees inherent in the C++ language.</p>
<p>4. Analyze Consistency. Failure is possible, but in each case each
suboperation guarantees the progression from one consistent state to another
regardless of success or failure, so the entire assignment ends in a consistent
state. Therefore the assignment's best possible consistency guarantee level is
'C' -- again thanks to the guarantees inherent in the C++ language.</p>
<p>5. Analyze Isolation. No guarantee is possible here, because no suboperation
makes any guarantee about side effects. For example, in Case 1, T1::T1() may
fail in a way that has already affected global state.</p>
<p>6. Analyze Durability. No guarantee is possible here either, because no
suboperation makes any guarantee about durability. For example, in Case 1,
T1::T1() may fail in a way that does not achieve persistence of the final state.</p>
<p>So aC is the strongest exception safety guarantee one can make for assignment
without requiring any assumptions at all about the used type. That's a useful
piece of information, especially in generic programming using language
facilities like C++ templates where we cannot always assume knowledge of the
guarantees provided by arbitrary and even unknowable types.</p>
<p>Better still, we can make an even stronger statement with a little knowledge
about the types we're using:</p>
<div align="center">
  <center>
  <!--mstheme--></font><table border="0" cellpadding="6" cellspacing="0">
    <tr>
      <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
        <p style="margin-top: 6; margin-bottom: 0"><b>aCI-</b><!--mstheme--></font></td>
      <td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
        <p style="margin-top: 6; margin-bottom: 0">The guarantee provided by the
        technique shown in <a href="059.htm"> GotW #59</a>, <i>if</i> T1 and T2 construction and
        destruction provide at least -CI-.<!--mstheme--></font></td>
    </tr>
  </table><!--mstheme--><font face="Arial, Arial, Helvetica">
  </center>
</div>
<p>Interestingly, note that this guarantee (aCI-) promises more than the
Abrahams strong guarantee (aCi-).</p>
<p>In short:</p>
<p>- With no knowledge of the used types T1 and T2, it is always possible to
write an assignment operator for T that gives &quot;better than the basic
guarantee&quot; -- specifically, such an assignment operator is aC-safe.</p>
<p>- With the additional knowledge that T1 and T2 construction and destruction
are CI-safe, if is always possible to write an assignment operator for T that
gives &quot;better than the strong guarantee&quot; -- specifically, such an
assignment operator is aCI-safe.</p>
<p>Neither of these guarantees is concisely expressible using prior exception
and program safety models.</p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">TRANSACTIONAL PROGRAM CORRECTNESS ANALYSIS<!--mstheme--></font></h4>
<p>The third goal of this taxonomy was that &quot;[i]t should help us reason
about and analyze the safety of code, making it less a craft and more a
methodical engineering task.&quot;</p>
<p>Let's see how well we can do.</p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">ACID Safety Analysis<!--mstheme--></font></h4>
<p>It's important that the ACID program correctness taxonomy precisely describes
the prior Abrahams and other guarantees, but perhaps the best thing about the
ACID model is that it simplifies our analysis because the compound guarantees
are no longer the important thing at all.</p>
<p>Consider first the following principle, which is perhaps the most important
result of this article:</p>
<blockquote>
  <p><b>The Transactional Principle:<br>
  </b>All programming operations should be considered as transactions, with
  associated ACID guarantees. This applies regardless of whether exceptions are
  possible or absent.</p>
</blockquote>
<p>All programming operations are amenable to this new style of ACID
transactional analysis. After years of differing with Dave Abrahams on this
point, I can now in good conscience come around to his point of view that
&quot;exceptions are not magical&quot; -- they are simply another failure case,
albeit with complex programming semantics in C++ that come into play when you
actually use them, but conceptually no different from an error return code. The
reason I only now feel I can agree with Dave Abrahams is that, after writing
about and advancing this topic for several years, I only now think I finally
understand exception safety well enough to be able to reason about it
confidently as simply another form of &quot;early return.&quot;</p>
<p>By defining distinct and largely independent axes, the ACID model gives us a
simpler and systematic -- even mechanical -- way to analyze an operation's
correctness: Analyze it according to the individual safety guarantees, one axis
at a time, not according to aggregated &quot;compound guarantees.&quot; The way
to analyze a function, then, is to examine each axis' guarantee level in turn:</p>
<p>1. If the axis has no guarantee, do nothing.</p>
<p>2. If the axis has a guarantee about a failure case, then for each possible
EARLY return (each possible failure return, or each possible throw or interrupt
point which means each non-A-safe function call we perform as a suboperation),
ensure the guarantee is met if the early return is taken.</p>
<p>3. If the axis makes a guarantee about a success case, then for each possible
NORMAL return, ensure the guarantee is met if the return is taken.</p>
<p>Let's consider examples to show why this can make reasoning about exception
safety simpler, more systematic, more mechanical -- which is to say more like
engineering and less like craft:</p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Example: Analyzing for aCi-Safety (the Strong Guarantee)<!--mstheme--></font></h4>
<p>Say you are writing a function that must guarantee aCi-safety (the Abrahams
strong guarantee). How do you analyze whether it meets the guarantee? By
considering each axis independently as follows:</p>
<p>1. [a] For each possible EARLY return, ensure the immediate object is
returned to the initial state if the early return is taken.</p>
<p>2. [C] For each NORMAL return, ensure the immediate object's state is
consistent.</p>
<p>3. [i] For each possible EARLY return, ensure that side effects are undone if
the early return is taken.</p>
<p>Note that we didn't need to consider the c-safe aspect because ai-safe =&gt;
aci-safe since we require that the initial state of the system be consistent.</p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Another Example: Analyzing for aC-Safety<!--mstheme--></font></h4>
<p>Now say you are writing a function that must guarantee aC-safety. How do you
analyze whether it meets the guarantee? By considering each axis independently
as follows:</p>
<p>1. [a] For each possible EARLY return, ensure the immediate object is
returned to the initial state if the early return is taken.</p>
<p>2. [c] For each possible EARLY return, ensure that the system is in a
consistent state if the early return is taken.</p>
<p>3. [C] For each NORMAL return, ensure the immediate object's state is
consistent.</p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">OTHER RESULTS AND CONCLUSIONS<!--mstheme--></font></h4>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">The Importance of &quot;Big-A&quot; Atomicity<!--mstheme--></font></h4>
<p>As pointed out by Abrahams and Colvin and others, to guarantee any kind of
exception safety it is essential that certain operations -- notable destructors
and deallocation functions -- be required not to throw. That is, they must be at
least A-safe. We rely on this in all sorts of situations, notably:</p>
<p>- The &quot;do all the work off to the side, and commit using only
nonthrowing operations&quot; method is not possible if there are no suitable
nonthrowing (A-safe) operations.</p>
<p>- The related &quot;create a temporary and Swap()&quot; method, which is the
standard form of exception-safe copy assignment, is not possible without a
nonthrowing (A-safe) Swap().</p>
<p>An interesting point raised by Greg Colvin is that for this reason it does
not appear to be possible to write exception-safe code in Java. The Java
specification currently allows the JVM to throw an exception at any time at
arbitrary points in the program, for example asynchronously when stop is called
on a Thread object. In practice it isn't that bad, but it is worrisome that the
Java specification can apparently be shown to preclude writing exception-safe
code because there is no way to absolutely guarantee A-safe operations in Java.</p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Side Effects Last<!--mstheme--></font></h4>
<p>It seems best to try to perform I-safe operations last, in order to put off
side effects. That way, if a failure occurs earlier in the operation, no side
effects will have been begun. This helps to limit the scope for side effects
after failures.</p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Future Directions<!--mstheme--></font></h4>
<p>An important area for further study is a rigorous treatment of analyzing
compound operations. For example, as illustrated in one of the analysis examples
above, the consistency guarantees operate like a chain; an operation is c-safe
only if all suboperations are c-safe (any one that isn't becomes the weak link
that breaks the chain), and an operation is C-safe only if all suboperations are
C-safe. That's fine for consistency... now, is there anything we can conclude
similarly about atomicity, isolation, durability, or combinations thereof in
suboperations?</p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Summary<!--mstheme--></font></h4>
<p>When I started this taxonomy, I had in mind applying database concepts to
better analyze and describe C++ exception safety. In the process of doing so,
however, I kept on coming back to the simple terms &quot;successful
operation&quot; and &quot;failed operation,&quot; and finally realized (strongly
influenced, I am sure, by papers like Dave Abrahams' &quot;Exception Safety in
Generic Components&quot;<b><a href="#1"><sup>[1]</sup></a></b>) that the latter
applied completely and equally to ALL forms of failure -- C++ exceptions, Java
exceptions, C return codes, asynchronous interrupts, and any other imaginable
failure mode and reporting mechanism. That made me realize that what I was
developing might not really be just a taxonomy for analyzing C++ exception
safety at all, but rather something much more general: A taxonomy for describing
program correctness in all its aspects in all languages. Further use, critique,
and development will show whether this approach is indeed that widely applicable
or not.</p>
<p>Finally, consider two fundamental implications:</p>
<p>1. The Transactional Principle: All programming operations should be
considered as transactions, with associated guarantees, and are amenable to this
new style of ACID transactional analysis. This applies regardless of whether
exceptions are possible or absent.</p>
<p>2. As pointed out by Dave Abrahams in his &quot;Exception-Safety in Generic
Components&quot; paper<b><a href="#1"><sup>[1]</sup></a></b> and other places,
&quot;exception safety&quot; is a bit of a misnomer, and the ACID model bears
this out by not distinguishing between different kinds of &quot;early
returns,&quot; whether they be through error codes, through exceptions, or
through some other method. Exception-related &quot;safety&quot; is not some
magical entity or unknowable phantom; &quot;safety&quot; is just another name
for &quot;correctness.&quot; When we want to talk about &quot;exception
safety,&quot; we should instead just talk about &quot;program correctness&quot;
without arbitrarily highlighting one form of correctness. Unfortunately, this
only underscores that languages that have exceptions but do not allow
exception-safe programming (such as by not supporting the strongest no-failure
atomicity guarantee, or A-safety) actually have a worse problem, namely
insufficient support for general program correctness.</p>
<p>If this taxonomy and its related analysis methods are at all useful, they
will be subject to refinement. I invite readers to analyze and expand upon these
ideas.</p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Acknowledgments<!--mstheme--></font></h4>
<p>Thanks to Dave Abrahams, Greg Colvin, and Scott Meyers for incisive reviews
of this article, along with much other fun and productive discussion of C++
topics over the years.</p>
<p>&nbsp;</p>

<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Notes<!--mstheme--></font></h4>
<p><a name="1"></a>1. D. Abrahams. <b>&quot;Exception-Safety in Generic
Components,&quot;</b> in <b>Generic Programming: Proceedings of a Dagstuhl
Seminar</b>, M. Jazayeri, R. Loos, and D. Musser, eds. (Springer Verlag, 1999).</p>
<p><a name="2"></a>2. H. Mueller. <b>&quot;10 Rules for Handling Exception
Handling Successfully&quot;</b> (<i>C++ Report</i>, 8(1), January 1996).</p>
<p><a name="3"></a>3. J. Reeves. <b><a href="http://www.awlonline.com/cseng/meyerscddemo/DEMO/MAGAZINE/RE_FRAME.HTM" target="_blank">&quot;Coping
with Exceptions&quot;</a></b> (<i>C++ Report</i>, 8(3), March 1996).</p>
<p><a name="4"></a>4. C.J. Date. <b>An Introduction to Database Systems, 7th
Edition</b> (Addison-Wesley, 1999).</p>
<p><a name="5"></a>5. H. Sutter. <b><a href="../publications/mill08.htm">&quot;Namespaces and the Interface
Principle&quot;</a></b> (<i>C++ Report</i>, 11(3), March 1999).</p>
<p><a name="6"></a>6. H. Sutter. <b><a href="../publications/xc++.htm">Exceptional
C++</a></b> (Addison-Wesley, 2000).</p>
<!--mstheme--></font><!--msnavigation--></td></tr><!--msnavigation--></table><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td><!--mstheme--><font face="Arial, Arial, Helvetica"><h4 align="right"><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666"><a href="../copyright.htm"><font size="2">Copyright ©
2002 Herb Sutter</font></a><!--mstheme--></font></h4>

<!--mstheme--></font></td></tr><!--msnavigation--></table></body>
</html>

