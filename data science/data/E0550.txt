ID=E0550
URL=http://www.bcbdev.com/faqs/faq30.htm
SIZE=15172
DATE=12/07/02
TIME=19:22:09
DATASET=C
HTML=<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
   <TITLE>BCBDEV.COM: FAQs</TITLE>
   <META NAME="Author" CONTENT="Harold Howe">
</HEAD>
<BODY BGCOLOR="WHITE">

<CENTER>
<TABLE  BORDER=0 CELLPADDING=0 CELLSPACING=0 WIDTH="640">
<TR>
<TD WIDTH="240" NOWRAP ROWSPAN=2 VALIGN="CENTER">
<IMG SRC="../images/faq.gif" BORDER=0 ALIGN="CENTER" HSPACE="0">
</TD>
<TD WIDTH="400" NOWRAP COLSPAN=6 VALIGN="BOTTOM">
<IMG SRC="../images/bcbdev.gif" BORDER=0 ALIGN="CENTER" HSPACE="0">
</TD>
</TR>
<TR>
<TD WIDTH="70" VALIGN="TOP"><A href="http://www.bcbdev.com"> <IMG SRC="../images/home.gif"     ALT="Home"      BORDER=0 HSPACE="0" ALIGN="CENTER" VALIGN="TOP"></A></TD>
<TD WIDTH="75" VALIGN="TOP"><A href="../articles.htm">       <IMG SRC="../images/articles.gif" ALT="Articles"  BORDER=0 HSPACE="0" ALIGN="CENTER" VALIGN="TOP"></A></TD>
<TD WIDTH="55" VALIGN="TOP"><A href="../books.htm">          <IMG SRC="../images/books.gif"    ALT="Books"     BORDER=0 HSPACE="0" ALIGN="CENTER" VALIGN="TOP"></A></TD>
<TD WIDTH="90" VALIGN="TOP"><A href="../download.htm">       <IMG SRC="../images/download.gif" ALT="Downloads" BORDER=0 HSPACE="0" ALIGN="CENTER" VALIGN="TOP"></A></TD>
<TD WIDTH="55" VALIGN="TOP"><A href="../faqs.htm">           <IMG SRC="../images/faqs.gif"     ALT="FAQs"      BORDER=0 HSPACE="0" ALIGN="CENTER" VALIGN="TOP"></A></TD>
<TD WIDTH="55" VALIGN="TOP"><A href="../idetips.htm">        <IMG SRC="../images/tips.gif"     ALT="Tips"      BORDER=0 HSPACE="0" ALIGN="CENTER" VALIGN="TOP"></A></TD>
</TR>
<TR>
<TD COLSPAN=7>
<HR>



<H3>
Q: Port I/O from BCB apps
</H3>
<H3>
Answer:
</H3>
<P>You can't. Well sort of, you can't do port I/O from a BCB apps
that are running on Windows NT, unless you buy third party software or write a
kernel mode driver. You can do port I/O from BCB if your program is running on
Windows 95 or Windows 98.
</P>
<H3>Explanation:</H3>
<P>Intel protected mode processors provide four different
privilege levels called ring 0, ring 1, ring 2, and ring 3. Ring 0 is the
highest privilege level, and ring 3 is the lowest. Code that executes at ring 0
can call any assembly instruction and can access any I/O address. Code that runs
at ring 3 is restricted.
</P>
<P>
In Windows, only portions of operating system and device drivers run at
ring 0. In order to keep programs from screwing up the system, Windows runs all
user programs in ring 3. The Window's operating system doesn't utilize ring 1
or ring 2. Applications written with C++Builder, or any other compiler, will
have ring 3 access rights, which means that their ability to do port I/O will
be limited.
</P>
<P>
In order to keep ring 3 programs from doing port I/O, the i386 and subsequent
processors maintain a bitmapped field for each program. Each bit in the bitmap
corresponds to a port address. If a ring 3 program attempts to execute an <TT>IN</TT> or
and <TT>OUT</TT> assembly instruction, the processor checks the bitmap to determine if
the program can access that address. The processor generates an exception if
it determines that a ring 3 program should not be accessing a port address. When
the OS catches the exception that is generated by the processor, it's up to the
OS to decide what should be done.</P>
<P>
If a ring 3 program attempts to access a hardware port, Windows 95 and Windows NT
will react differently. Windows 95 responds by granting the ring 3 program
access rights to the hardware by altering the bitmap field. It then executes the
original port instruction that caused the exception to occur. The processor will
not generate another exception if the ring 3 program tries to access the same
port again. Windows NT is more strict, primarily because of security and robustness
issues. If a hardware access exception is detected, Windows NT simply boots the offending ring 3
program off the system. The port instruction is not executed.
</P>
<H3>The port I/O dilemma</H3>
<P>
Because Windows 95 allows port I/O, while Windows NT forbids it, the programmers
at Borland were faced with an interesting challenge: what to do with the library
functions <TT>inp</TT>, <TT>outp</TT>, <TT>inportb</TT>, <TT>outportb</TT>, etc.
These functions are part of the C runtime library. The C run time library is built
from source code that is written by Borland. Borland could have left the port functions in,
but programs that call them would crash on windows NT. Conversely, removing the
functions from the C run time library solves the crashing problem, but at the
expense of preventing programmers from using the functions on Windows 95.
<P>
Borland decided to remove the port functions from the 32 bit version of their
run time libraries. Perhaps they decided that removing the functions adhered
better with win32 programming practices. Perhaps they were planning for the
future (since Windows NT will eventually be the only OS offered by Microsoft).
Perhaps they didn't realize that Windows 95 and Windows 98 would prevent hardware access, only
to grant hardware access as soon as someone broke the rules (you must admit that
Windows is someone half-baked in this regard). For whatever reason, Borland removed
the port I/O functions from the C run time library, which means that you can't call
<TT>inp</TT> and <TT>outp</TT> from your BCB programs.
</P>
<P>
<B>Note:</B> For the record, I must state that I agree with Borland's decision,
but for a slightly different reason. In his book "Effective C++", Scott Meyers
explains why programmers should prefer compile and link time errors to run time
errors. A windows program that calls <TT>inp</TT> or <TT>outp</TT> will bomb out
on Windows NT; hence, a run time error. Additionally, accessing the wrong port
in Windows 95 could make the system unstable (more run time problems). Removing
the functions may cause compile time headaches, but it also forces you to seek a
more robust, run time stable solution.
</P>
<H3>Enough babble, how do I do port I/O from BCB?</H3>
<P>
You have essentially three choices: either write a device driver, use someone
elses device driver or find a replacement for <TT>inp</TT> and <TT>outp</TT>. If
you don't need to run your program on Windows NT, then the easiest, and cheapest
solution is to find a replacement for <TT>inp</TT> and <TT>outp</TT>. However,
using a device driver is probably more robust, and it's the only way to run the
program on NT.
</P>
<P>
<B>Finding a replacement for <TT>inp</TT> and <TT>outp</TT></B>
</P>
<P>
With this strategy, your ring 3 program will simply call the assembly <TT>IN</TT> and <TT>OUT</TT>
instructions. The processor will generate an exception, afterwhich, Windows 95
will alter your access rights. There are three ways to replace <TT>inp</TT> and <TT>outp</TT>:
you can use the relatively unknown <TT>__emit__</TT> macro, you can write your own version of <TT>inp</TT> and
<TT>outp</TT>, or you can use my compiled version of <TT>inp</TT> and <TT>outp</TT>.
</P>
<P>
The <TT>__emit__</TT> macro allows you to place raw bytes into your executable. With this
strategy, you use <TT>__emit__</TT> to manually insert the opcodes for the
assembly <TT>IN</TT> and <TT>OUT</TT> instructions.
</P>
<pre>
    <font color="green">#include &lt;dos.h></font>

    <b>unsigned</b> <b>short</b> inportw<b>(</b><b>unsigned</b> <b>short</b> port<b>)</b>
    <b>{</b>
        _DX <b>=</b> port<b>;</b>
       __emit__<b>(</b><font color="blue">0x66</font><b>,</b> <font color="blue">0xED</font><b>)</b><b>;</b>  <font color="navy">// 66ED = opcode for in ax,dx</font>
       <b>return</b> _AX<b>;</b>
    <b>}</b>

    <b>void</b> outportw<b>(</b><b>unsigned</b> <b>short</b> port<b>,</b> <b>unsigned</b> <b>short</b> value<b>)</b>
    <b>{</b>
        _DX <b>=</b> port<b>;</b>
        _AX <b>=</b> value<b>;</b>
        __emit__<b>(</b><font color="blue">0x66</font><b>,</b> <font color="blue">0xEF</font><b>)</b><b>;</b>  <font color="navy">// 66EF = opcode for out dx,ax</font>
    <b>}</b>
</pre>
<P>
If you have TASM, Delphi, or C++Builder 3, you can write your own versions
of <TT>inp</TT> and <TT>outp</TT>. They are very simple. Here are two samples to get you started.
<TT>outp</TT> simply moves the port address into the <TT>DX</TT> register, moves the output value into
<TT>AL</TT> or <TT>AX</TT>, and then calls the assembly <TT>OUT</TT> instruction. <TT>inp</TT> moves the
address into <TT>DX</TT>, and then calls the <TT>IN </TT>instruction. The <TT>AL</TT> or <TT>AX</TT> register
contains the return value. The port I/O package from the
<A HREF="../download.htm" >download page</A> contains the source code for the
port I/O routines that are not listed here.
</P>
<pre>
    <font color="green">#include &lt;dos.h></font>

    <b>unsigned</b> <b>short</b> inportw<b>(</b><b>unsigned</b> <b>short</b> port<b>)</b>
    <b>{</b>
        <b>asm</b>     mov     dx<b>,</b>port
        <b>asm</b>     in      ax<b>,</b>dx
        <b>return</b> _AX<b>;</b>
    <b>}</b>

    <b>void</b> outportw<b>(</b><b>unsigned</b> <b>short</b> port<b>,</b> <b>unsigned</b> <b>short</b> val<b>)</b>
    <b>{</b>
        <b>asm</b>     mov     dx<b>,</b> port
        <b>asm</b>     mov     ax<b>,</b> val
        <b>asm</b>     out     dx<b>,</b> ax
    <b>}</b>

</pre>
<P>
The last way to replace <TT>inp</TT> and <TT>outp</TT> is to use a compiled
module from someone else. This strategy really applies only to C++Builder 1. The
<A HREF="../download.htm" >downloads page</A>
contains a compiled OBJ that you can download and add to your BCB1 projects. The
OBJ contains 32-bit versions of <TT>inp</TT> and <TT>outp</TT> that I produced
with BC++ 5 and TASM 4. Simply add this OBJ to your project and you will be
able to use <TT>inp</TT> and <TT>outp</TT> to your heart's delight.
</P>
<P>
<B>Note:</B> BCB 1.0 does not come with TASM, and without TASM it cannot process inline assembly
in a C++ file. However, the pascal compiler can process inline assembly. This means that you can create a pascal
unit that contains the inline assembly for the <TT>inp</TT> and <TT>outp</TT> functions. One common technique is
to create a component in pascal that handles the port I/O. You can then add this component to a form and execute
port I/O from your C++ code. If you still use C++Builder 1.0 and the thought of pascal leaves a bad taste in your
mouth, then your only options are to write the routines using the <TT>__emit</TT> macro or use the compiled OBJ from
the <A HREF="../download.htm" >download page</A>.
</P>
<P>
<B>Note:</B> The ports download on the <A HREF="../download.htm" >download page</A>
contains a 32-bit OBJ for use with C++Builder 1.0. The download contains an OBJ because C++Builder 1.0 can't compile
the inline assembly needed within the port I/O routines. The download also contains a C file that has the source
code for the inline assembly I/O routines. If you have C++Builder 3, add this source file to your project. If you have
C++Builder 1, add the OBJ file to your project. The OBJ file is not compatible with C++Builder 3.
</P>
<P>
<B>Using someone elses driver</B>
</P>
<P>
This strategy provides several benefits. First, without a driver, the very first
I/O access from a ring 3 program will be delayed as Windows 95 alters the
access bitmap. Secondly, the provider of the driver will hopefully provide a
solution for both Windows 95, Windows NT, and future versions of Windows.
</P>
<P>
<A HREF="http://www.bluewatersystems.com">BlueWater Systems</A> has developed a
product call WinRT that allows port access on both Windows 95 and Windows NT
(if you purchase the correct options). WinRT provides port access routines that
sit on top of device drivers. On Windows 95, the driver is a VxD. On Windows NT,
the driver is a kernel mode driver.
</P>
<P>
<A HREF="http://www.tetradyne.com">Tetradyne Software</A> also produce a port I/O solution
for both Windows 95/98 and Windows NT. The product is called DriverX. One nice feature of
DriverX is that it allows you to hook interrupts from your ring 3 program.
</p>
<P>
There is another solution called
<A HREF="http://www.strongsoftware.net/tvicport/">TVicHW32</A>. This
product claims to work on both NT and Windows 95. It is cheaper than WinRT and DriverX. If
you're looking for a free ride, you could give Keithley/MetraByte's
<A HREF="ftp://ftp.keithley.com/pub/metrabyte/unsupport/port95nt.exe">DriverLINX</A>
a try. You can also try the TinyPort mini-driver or GiveIO solutions that are
presented on <A HREF="http://users.skynet.be/k-net/ParPort/index.html">
Samuel Grimee's website</A>.
</P>
<P>
<B>Writing your own driver</B>
</P>
<P>
I put this option last for a good reason: it's a bad option in most situations.
Writing your own driver is costly because you must obtain the Windows 95 and
Windows NT DDK's by subscribing to the MSDN. Then you have to learn how to write
a device driver. Unfortunately, you have to learn three different device driver
models: the VxD, the NT kernel mode driver, and the new Windows Driver Model
introduced by windows 98 and NT 5. You will have to write three drivers, not
one, and the concepts of each model are pretty much unique.
</P>
<P>
In my opinion, you should avoid this strategy unless you intend to someday make
your living writing drivers. For the average GUI programmer, device drivers are
a good item to avoid. Also keep in mind that this is a costly route to take. The
MSDN is $500 or so. It's difficult, if not impossible, to create drivers with BCB
due to the nature of the DDK (especially the NT DDK). This means you have to shell out $300 for
MSVC++ (never mind the cost, does the average BCB programmer really want to use
MSVC++ for anything?). You won't survive without at least $100 worth of device driver
books. Plus, most programmers make use of third party driver tools, such as
VToolsD and Driver::Works from VireoTools or WinDK from BlueWater Systems. You're
talking $1000 just to get started. Now add at least 50 man-hours of labor at around
$50/hr. The total cost of this option would probably exceed $3500 without much
difficulty. This is a lot of money and time to spend if you don't intend to make
writing device drivers part of your living. For most GUI programmers, writing your
own driver for $3500 doesn't compare with the $100-$500 options that allow you
to use someone elses driver. By using someone elses driver, you can avoid the headaches
of writing a driver and get on with more profitable ventures.
</P>
<BR>
<P>
<B>Reference:</B> Much of the technical information about port access in Windows 95
and Windows NT was provided by Karen Hazzah's "Port I/O Under Windows" article that
appeared in the Jun/96 issue of Windows Developer Journal.
</P>   

</TD> </TR>
<TR>  <TD COLSPAN=7>
<BR><HR>
<CENTER>
<FONT size="-1">
<I>
Copyright &copy; 1997-2000 by <A HREF="mailto:hhowe@bcbdev.com">Harold Howe</A>.<BR>
All rights reserved.
</I>
</FONT>
</CENTER>
</TD> </TR>
</TABLE>
</CENTER>
</BODY>
</HTML>

