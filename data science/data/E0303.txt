ID=E0303
URL=http://www.gotw.ca/gotw/056.htm
SIZE=37722
DATE=12/07/02
TIME=19:19:45
DATASET=C
HTML=
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta http-equiv="Content-Language" content="en-us">


<title>GotW #56: Exception-Safe Function Calls</title>
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<link rel="stylesheet" type="text/css" href="../gotw.css">
<meta name="Microsoft Theme" content="gotw 111, default">
<meta name="Microsoft Border" content="tlb, default">
</head>

<body background="../_themes/gotw/glabkgnd.jpg" bgcolor="#CCFFFF" text="#000000" link="#008080" vlink="#008080" alink="#0000FF"  ><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font><table border="0" cellspacing="0" width="100%">
  <tr>
    <td colspan="2"><!--mstheme--><font face="Arial, Arial, Helvetica"><font size="6"><strong>
    GotW #56</strong></font> <!--mstheme--></font></td>
  </tr>
  <tr>
    <td valign="middle"><!--mstheme--><font face="Arial, Arial, Helvetica">




<p align="left" style="margin-top: 0; margin-bottom: 0">

<script language="JavaScript"><!--
MSFPhover = 
  (((navigator.appName == "Netscape") && 
  (parseInt(navigator.appVersion) >= 3 )) || 
  ((navigator.appName == "Microsoft Internet Explorer") && 
  (parseInt(navigator.appVersion) >= 4 ))); 
function MSFPpreload(img) 
{
  var a=new Image(); a.src=img; return a; 
}
// --></script><script language="JavaScript"><!--
if(MSFPhover) { MSFPnav1n=MSFPpreload("../_derived/home_cmp_gotw110_hbtn.gif"); MSFPnav1h=MSFPpreload("../_derived/home_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav1'].src=MSFPnav1h.src" onmouseout="if(MSFPhover) document['MSFPnav1'].src=MSFPnav1n.src"><img src="../_derived/home_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Home" align="middle" name="MSFPnav1"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav2n=MSFPpreload("../_derived/news.htm_cmp_gotw110_hbtn.gif"); MSFPnav2h=MSFPpreload("../_derived/news.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../news.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav2'].src=MSFPnav2h.src" onmouseout="if(MSFPhover) document['MSFPnav2'].src=MSFPnav2n.src"><img src="../_derived/news.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="News &amp; Events" align="middle" name="MSFPnav2"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav3n=MSFPpreload("../resources/_derived/index.htm_cmp_gotw110_hbtn.gif"); MSFPnav3h=MSFPpreload("../resources/_derived/index.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../resources/index.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav3'].src=MSFPnav3h.src" onmouseout="if(MSFPhover) document['MSFPnav3'].src=MSFPnav3n.src"><img src="../resources/_derived/index.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Community Resources" align="middle" name="MSFPnav3"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav4n=MSFPpreload("../_derived/consulting.htm_cmp_gotw110_hbtn.gif"); MSFPnav4h=MSFPpreload("../_derived/consulting.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../consulting.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav4'].src=MSFPnav4h.src" onmouseout="if(MSFPhover) document['MSFPnav4'].src=MSFPnav4n.src"><img src="../_derived/consulting.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Consulting Services" align="middle" name="MSFPnav4"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav5n=MSFPpreload("../_derived/presentations.htm_cmp_gotw110_hbtn.gif"); MSFPnav5h=MSFPpreload("../_derived/presentations.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../presentations.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav5'].src=MSFPnav5h.src" onmouseout="if(MSFPhover) document['MSFPnav5'].src=MSFPnav5n.src"><img src="../_derived/presentations.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Presentations" align="middle" name="MSFPnav5"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav6n=MSFPpreload("../publications/_derived/index.htm_cmp_gotw110_hbtn.gif"); MSFPnav6h=MSFPpreload("../publications/_derived/index.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../publications/index.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav6'].src=MSFPnav6h.src" onmouseout="if(MSFPhover) document['MSFPnav6'].src=MSFPnav6n.src"><img src="../publications/_derived/index.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Publications" align="middle" name="MSFPnav6"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav7n=MSFPpreload("_derived/index.htm_cmp_gotw110_hbtn.gif"); MSFPnav7h=MSFPpreload("_derived/index.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="index.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav7'].src=MSFPnav7h.src" onmouseout="if(MSFPhover) document['MSFPnav7'].src=MSFPnav7n.src"><img src="_derived/index.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Guru of the Week" align="middle" name="MSFPnav7"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav8n=MSFPpreload("../conv/_derived/index.htm_cmp_gotw110_hbtn.gif"); MSFPnav8h=MSFPpreload("../conv/_derived/index.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../conv/index.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav8'].src=MSFPnav8h.src" onmouseout="if(MSFPhover) document['MSFPnav8'].src=MSFPnav8n.src"><img src="../conv/_derived/index.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Conversations" align="middle" name="MSFPnav8"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav9n=MSFPpreload("../_derived/search.htm_cmp_gotw110_hbtn.gif"); MSFPnav9h=MSFPpreload("../_derived/search.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../search.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav9'].src=MSFPnav9h.src" onmouseout="if(MSFPhover) document['MSFPnav9'].src=MSFPnav9n.src"><img src="../_derived/search.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Search GotW.ca" align="middle" name="MSFPnav9"></a>
</p>




    <!--mstheme--></font></td>
    <td valign="middle"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 0; margin-bottom: 0">
      <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav10n=MSFPpreload("../_derived/back_cmp_gotw110_back.gif"); MSFPnav10h=MSFPpreload("../_derived/back_cmp_gotw110_back_a.gif"); }
// --></script><a href="055.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav10'].src=MSFPnav10h.src" onmouseout="if(MSFPhover) document['MSFPnav10'].src=MSFPnav10n.src"><img src="../_derived/back_cmp_gotw110_back.gif" width="100" height="20" border="0" alt="Prev" name="MSFPnav10"></a><br><script language="JavaScript"><!--
if(MSFPhover) { MSFPnav11n=MSFPpreload("../_derived/up_cmp_gotw110_up.gif"); MSFPnav11h=MSFPpreload("../_derived/up_cmp_gotw110_up_a.gif"); }
// --></script><a href="index.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav11'].src=MSFPnav11h.src" onmouseout="if(MSFPhover) document['MSFPnav11'].src=MSFPnav11n.src"><img src="../_derived/up_cmp_gotw110_up.gif" width="100" height="20" border="0" alt="Up" name="MSFPnav11"></a><br><script language="JavaScript"><!--
if(MSFPhover) { MSFPnav12n=MSFPpreload("../_derived/next_cmp_gotw110_next.gif"); MSFPnav12h=MSFPpreload("../_derived/next_cmp_gotw110_next_a.gif"); }
// --></script><a href="057.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav12'].src=MSFPnav12h.src" onmouseout="if(MSFPhover) document['MSFPnav12'].src=MSFPnav12n.src"><img src="../_derived/next_cmp_gotw110_next.gif" width="100" height="20" border="0" alt="Next" name="MSFPnav12"></a><!--mstheme--></font></td>
  </tr>
  <tr>
    <td height="5" background="../images/bar.gif" colspan="2"><!--mstheme--><font face="Arial, Arial, Helvetica">&nbsp;<!--mstheme--></font></td>
  </tr>
</table><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font></td></tr><!--msnavigation--></table><!--msnavigation--><table dir="ltr" border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td valign="top" width="1%"><!--mstheme--><font face="Arial, Arial, Helvetica">

<!--mstheme--></font><table border="0" cellspacing="0" bgcolor="#000000" cellpadding="0">
  <tr>
    <td><!--mstheme--><font face="Arial, Arial, Helvetica">
    <!--mstheme--></font><table border="0" cellpadding="2" cellspacing="1" width="100%" height="483">
        <tr>
          <td align="center" bgcolor="#000000" colspan="2" height="16"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin-top: 0; margin-bottom: 0"><a href="../news.htm"><b><font color="#FFFF00">News</font></b></a><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="center" bgcolor="#CCCCCC" bordercolor="#CCCCCC" rowspan="3"><!--mstheme--><font face="Arial, Arial, Helvetica">
          <font size="1" color="#0000FF">J<br>
          U<br>
          L<br>
          Y</font><!--mstheme--></font></td>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin-left: 3; margin-right: 3; margin-top: 0" align="center"><font size="1" color="#0000FF">
            Print articles newly available online</font><!--mstheme--></font><table border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%" id="AutoNumber1" bgcolor="#FFFFCC" bordercolordark="#006666" bordercolorlight="#99CCCC">
              <tr>
                <td width="100%" bordercolor="#808000"><!--mstheme--><font face="Arial, Arial, Helvetica">
                <p style="margin: 3"><font size="1" color="#0000FF">
                <a href="../publications/mill20.htm"><b><i>
                <font color="#0000FF">Sutter's Mill</font></i></b><font color="#0000FF"> 
                column, &quot;Toward a Standard C++ Library, Part 1&quot;</font></a></font><!--mstheme--></font></td>
              </tr>
              <tr>
                <td width="100%" bordercolor="#808000" bgcolor="#FFFFCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
                <p style="margin: 3"><font size="1" color="#0000FF">
                <a href="../publications/mxc++-item-4.htm">
                <font color="#0000FF">Excerpt from MXC++, &quot;Extensible Templates: 
                Via Inheritance or Traits?&quot;</font></a></font><!--mstheme--></font></td>
              </tr>
              <tr>
                <td width="100%" bordercolor="#808000"><!--mstheme--><font face="Arial, Arial, Helvetica">
                <p style="margin: 3"><font size="1" color="#0000FF">
                <a href="../publications/mcd_review.htm"><font color="#0000FF">
                Book Review: Modern C++ Design</font></a></font><!--mstheme--></font></td>
              </tr>
              <tr>
                <td width="100%" bordercolor="#808000"><!--mstheme--><font face="Arial, Arial, Helvetica">
                <p style="margin: 3"><font size="1" color="#0000FF">
                <a href="../publications/mill21.htm"><b><i>
                <font color="#0000FF">Sutter's Mill</font></i></b><font color="#0000FF"> 
                column, &quot;Toward a Standard C++ Library, Part 2: Namespaceops and 
                Library Versioning&quot;</font></a></font><!--mstheme--></font></td>
              </tr>
            </table><!--mstheme--><font face="Arial, Arial, Helvetica">
          <!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin: 0 3"><font size="1" color="#0000FF"><b><i>Sutter's 
            Mill</i></b> column,
            &quot;A Pragmatic Look at Exception Specifications&quot;<br>
            </font><font size="1" color="#000080">The usefulness, or lack 
            thereof, of exception specifications, and how results can vary 
            across real-world compilers</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin: 0 3">
            <a target="_blank" href="http://www.cuj.com/experts/2007/hyslop.htm"><font size="1" color="#0000FF"><i><b>Conversations</b></i> column,
            &quot;Getting to the Point&quot;</font></a><font color="#0000FF" size="1"><br>
            </font><font size="1" color="#000080">The Boost library has five 
            smart pointers that provide a rich array [sic] of useful behaviors.</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="center" bgcolor="#CCCCCC" bordercolor="#CCCCCC" rowspan="2"><!--mstheme--><font face="Arial, Arial, Helvetica"><font color="#0000FF" size="1">A<br>
            U<br>
          G<br>
          U<br>
          S<br>
          T</font><!--mstheme--></font></td>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin:0 3; ">
            <a target="_blank" href="http://www.cuj.com/experts/2008/sutter.htm"><i><b><font size="1" color="#0000FF">The New C++</font></b></i> <font size="1" color="#0000FF">
            column, &quot;Smart(er) Pointers&quot;</font></a><font size="1" color="#000080"><br>
            A closer look at one of the proposed new standard C++ library 
            features -- smart pointers, particularly those in Boost and Loki, 
            and a sneak peek at the usefulness of the proposed typedef templates</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
          <p style="margin:0 3; ">
          <a target="_blank" href="http://www.cuj.com/experts/2008/hyslop.htm"><font size="1" color="#0000FF"><i><b>Conversations</b></i> column,
            &quot;A Midsummer Night's Madness&quot;</font></a><font color="#0000FF" size="1"><br>
            </font><font size="1" color="#000080">A brew that mixes pointers, 
          typedefs, and const</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="center" bgcolor="#CCCCCC" bordercolor="#CCCCCC" rowspan="3"><!--mstheme--><font face="Arial, Arial, Helvetica">
          <p style="margin-top: 0; margin-bottom: 0">
          <font size="1" color="#0000FF">S<br>
          E<br>
          P<br>
          T<br>
          E<br>
          M<br>
          B<br>
          E<br>
          R</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin: 0 3">
            <font size="1" color="#0000FF">&quot;Standard C++ Meets Managed C++&quot;<br>
            </font><font size="1" color="#000080">A survey of the main (in)compatibilities 
            between Standard C++ and Microsoft’s managed extensions for C++, and 
            how the two could converge</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin: 0 3"><font size="1" color="#0000FF"><b><i>Sutter's 
            Mill</i></b> column,
            &quot;Export Restrictions, Part 1&quot;<br>
            </font><font size="1" color="#000080">The scoop on export -- what 
            some people think it does, what it actually does, and why it’s the 
            most widely-ignored feature in the C++ standard</font><!--mstheme--></font></td>
        </tr>
      </table><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font></td>
  </tr>
</table><!--mstheme--><font face="Arial, Arial, Helvetica">
<p style="margin-top: 0; margin-bottom: 0">
<img border="0" src="../images/140.gif" width="140" height="1"></p>

<!--mstheme--></font></td><td valign="top" width="24"></td><!--msnavigation--><td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
<!--mstheme--></font><table border="1" cellpadding="6" cellspacing="0" width="100%" bgcolor="#CCCCFF" bordercolordark="#006666" bordercolorlight="#99CCCC">
  <tr>
    <td width="100%"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p align="center">This is the original GotW problem and solution
      substantially as posted to Usenet. See the book <i><a href="../publications/mxc++.htm"><b>More
      Exceptional C++</b></a></i> (Addison-Wesley, 2002) for the most current
      solution to this GotW issue. The solutions in the book have been revised
      and expanded since their initial appearance in GotW. The book versions
      also incorporate corrections, new material, and conformance to the final
      ANSI/ISO C++ standard.</p>
    <!--mstheme--></font></td>
  </tr>
</table><!--mstheme--><font face="Arial, Arial, Helvetica">
      <h2><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Exception-Safe Function Calls&nbsp;<font size="3"><br>
      Difficulty: 8 / 10</font><!--mstheme--></font></h2>
<p><i>Regular readers of GotW know that exception safety is anything but
trivial. This puzzle points out an exception safety problem that was discovered
only weeks before posting, and shows how best to avoid it in your own code.</i></p>
<p align="center"><img border="0" src="../images/h-line.gif" width="248" height="2"></p>

<h3><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Problem<!--mstheme--></font></h3>

<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">JG Question<!--mstheme--></font></h4>
<p><b><font size="4">1.</font></b>   In each of the following statements, what
can you say about the order of evaluation of the functions f, g, and h and the
expressions expr1 and expr2? Assume that expr1 and expr2 do not contain more
function calls.</p>
<!--mstheme--></font><pre>    //  Example 1(a)
    //
    f( expr1, expr2 );</pre><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font><pre>    //  Example 1(b)
    //
    f( g( expr1 ), h( expr2 ) );</pre><!--mstheme--><font face="Arial, Arial, Helvetica">
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Guru Questions<!--mstheme--></font></h4>
<p><b><font size="4">2.</font></b>   In your travels through the dusty corners
of your company's code archives, you find the following code fragment:</p>
<!--mstheme--></font><pre>    //  Example 2
    //</pre><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font><pre>    //  In some header file:
    void f( T1*, T2* );</pre><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font><pre>    //  In some implementation file:
    f( new T1, new T2 );</pre><!--mstheme--><font face="Arial, Arial, Helvetica">
<p>Does this code have any potential exception safety problems? Explain.</p>
<p><b><font size="4">3.</font></b>   As you continue to root through the
archives, you see that someone must not have liked Example 2 because later
versions of the files in question were changed as follows:</p>
<!--mstheme--></font><pre>    //  Example 3
    //</pre><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font><pre>    //  In some header file:
    void f( auto_ptr&lt;T1&gt;, auto_ptr&lt;T2&gt; );</pre><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font><pre>    //  In some implementation file:
    f( auto_ptr&lt;T1&gt;( new T1 ), auto_ptr&lt;T2&gt;( new T2 ) );</pre><!--mstheme--><font face="Arial, Arial, Helvetica">
<p>What improvements does this version offer over Example 2, if any? Do any
exception safety problems remain? Explain.</p>
<p><b><font size="4">4.</font></b>   Demonstrate how to write an auto_ptr_new
facility that solves the safety problems in Question 3 and can be invoked as
follows:</p>
<!--mstheme--></font><pre>    //  Example 4
    //</pre><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font><pre>    //  In some header file (same as in Example 2b):
    void f( auto_ptr&lt;T1&gt;, auto_ptr&lt;T2&gt; );</pre><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font><pre>    //  In some implementation file:
    f( auto_ptr_new&lt;T1&gt;(), auto_ptr_new&lt;T2&gt;() );</pre><!--mstheme--><font face="Arial, Arial, Helvetica">
<p align="center"><img border="0" src="../images/h-line.gif" width="248" height="2"></p>
<h3><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666"><a name="Solution"></a>Solution<!--mstheme--></font></h3>

<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Recap: Evaluation Orders and Disorders<!--mstheme--></font></h4>
<p><font color="#999933"><b><font size="4">1.</font></b>   In each of the
following statements, what can you say about the order of evaluation of the
functions f, g, and h and the expressions expr1 and expr2? Assume that expr1 and
expr2 do not contain more function calls.</font></p>
<p>Ignoring threads (which are beyond the scope of the C++ Standard), the answer
to the first question hinges on these basic rules:</p>
<p>1. All of a function's arguments must be fully evaluated before the function
is called. This includes the completion of any side effects of expressions used
as function arguments.</p>
<p>2. Once the execution of a function begins, no expressions from the calling
function begin, or continue, to be evaluated until execution of the called
function has completed. Function executions never interleave with each other.</p>
<p>3. Expressions used as function arguments may generally be evaluated in any
order, including interleaved, except as otherwise restricted by the other rules.</p>
<p>Given those rules, let's see what happens in our opening examples:</p>
<!--mstheme--></font><pre><font color="#999933">    //  Example 1(a)
    //
    f( expr1, expr2 );</font></pre><!--mstheme--><font face="Arial, Arial, Helvetica">
<p>All we can say is: Both expr1 and expr2 must be evaluated before f() is
called.</p>
<p>That's it. The compiler may choose to perform the evaluation of expr1 before,
after, or interleaved with the evaluation of expr2. There are enough people who
find this surprising that it comes up as a regular question on the newsgroups,
but it's just a direct result of the C and C++ rules about sequence points.</p>
<!--mstheme--></font><pre><font color="#999933">    //  Example 1(b)
    //
    f( g( expr1 ), h( expr2 ) );</font></pre><!--mstheme--><font face="Arial, Arial, Helvetica">
<p>The functions and expressions may be evaluated in any order that respects the
following rules:</p>
<p>- expr1 must be evaluated before g() is called.</p>
<p>- expr2 must be evaluated before h() is called.</p>
<p>- both g() and h() must complete before f() is called.</p>
<p>- The evaluations of expr1 and expr2 may be interleaved with each other, but
nothing may be interleaved with any of the function calls. For example, no part
of the evaluation of expr2 nor the execution of h() may occur from the time g()
begins until it ends.</p>
<p>That's it. For example, this means that any one or more of the following are
possible:</p>
<p>- Either g() or h() could be called first.</p>
<p>- Evaluation of expr1 could begin, then be interrupted by h() being called,
then complete. (Likewise for expr2 and g().)</p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Some Function Call Exception Safety Problems<!--mstheme--></font></h4>
<p><font color="#999933"><b><font size="4">2.</font></b>   In your travels
through the dusty corners of your company's code archives, you find the
following code fragment:</font></p>
<!--mstheme--></font><pre><font color="#999933">    //  Example 2
    //</font></pre><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font><pre><font color="#999933">    //  In some header file:
    void f( T1*, T2* );</font></pre><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font><pre><font color="#999933">    //  In some implementation file:
    f( new T1, new T2 );</font></pre><!--mstheme--><font face="Arial, Arial, Helvetica">
<p><font color="#999933">Does this code have any potential exception safety
problems? Explain.</font></p>
<p>Yes, there are several potential exception safety problems.</p>
<p>Brief recap: An expression like &quot;new T1&quot; is called, simply enough,
a new-expression. Recall what a new-expression really does (I'll ignore
placement and array forms for simplicity, since they're not very relevant here):</p>
<blockquote>
  <p>- it allocates memory</p>
  <p>- it constructs a new object in that memory</p>
  <blockquote>
    <p>- if the construction fails because of an exception the allocated memory
    is freed</p>
  </blockquote>
</blockquote>
<p>So each new-expression is essentially a series of two function calls: one
call to operator new() (either the global one, or one provided by the type of
the object being created), and then a call to the constructor.</p>
<p>For Example 1, consider what happens if the compiler decides to generate code
as follows:</p>

<p>1: allocate memory for T1<br>
2: construct T1<br>
3: allocate memory for T2<br>
4: construct T2<br>
5: call f()</p>

<p>The problem is this: If either step 3 or step 4 fails because of an
exception, the C++ standard does not require that the T1 object be destroyed and
its memory deallocated. This is a classic memory leak, and clearly not a Good
Thing.</p>
<p>Another possible sequence of events is this:</p>

<p>1: allocate memory for T1<br>
2: allocate memory for T2<br>
3: construct T1<br>
4: construct T2<br>
5: call f()</p>

<p>This sequence has, not one, but two different exception safety problems with
different effects:</p>
<p>a) If step 3 fails because of an exception, then the memory allocated for T1
is automatically deallocated (step 1 is undone), but the standard does not
require that the memory allocated for the T2 object be deallocated. The memory
is leaked.</p>
<p>b) If step 4 fails because of an exception, then the T1 object has been
allocated and fully constructed, but the standard does not require that it be
destroyed and its memory deallocated. The T1 object is leaked.</p>
<p>&quot;Hmm,&quot; you might wonder, &quot;then why does this exception safety
loophole exist at all? Why doesn't the standard just prevent the problem by
requiring compilers to Do The Right Thing when it comes to cleanup?&quot;</p>
<p>The basic answer is that it wasn't noticed, and even now that it has been
noticed it might not be desirable to fix it. The C++ standard allows the
compiler some latitude with the order of evaluation of expressions because this
allows the compiler to perform optimizations that might not otherwise be
possible. To permit this, the expression evaluation rules are specified in a way
that is not exception-safe, and so if you want to write exception-safe code you
need to know about, and avoid, these cases. (See below for how best to do this.)</p>
<p>Remember that C++ exception safety in general has not been well understood
until fairly recently (namely the summer of 1997, just months before the
standard was completed). Even so, the committee managed to add exception safety
guarantees to the standard library, albeit necessarily at the eleventh hour in
the last two meetings before the standard was cast in stone; many of the
guarantees were added literally days before the concrete set. The problem with
new-expressions has now been noticed, but for the reasons above the committee
will have to decide whether the hole should be &quot;fixed&quot; or whether it
should continue to be allowed in the name of compiler optimization flexibility.</p>
<p><font color="#999933"><b><font size="4">3.</font></b>   As you continue to
root through the archives, you see that someone must not have liked Example 2
because later versions of the files in question were changed as follows:</font></p>
<!--mstheme--></font><pre><font color="#999933">    //  Example 3
    //</font></pre><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font><pre><font color="#999933">    //  In some header file:
    void f( auto_ptr&lt;T1&gt;, auto_ptr&lt;T2&gt; );</font></pre><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font><pre><font color="#999933">    //  In some implementation file:
    f( auto_ptr&lt;T1&gt;( new T1 ), auto_ptr&lt;T2&gt;( new T2 ) );</font></pre><!--mstheme--><font face="Arial, Arial, Helvetica">
<p><font color="#999933">What improvements does this version offer over Example
2, if any? Do any exception safety problems remain? Explain.</font></p>
<p>This code attempts to &quot;throw auto_ptr at the problem.&quot; Many people
believe that a smart pointer like auto_ptr is an exception safety panacea.</p>
<p>It is not. Nothing has changed. Example 3 is still not exception-safe, for
exactly the same reasons as before.</p>
<p>Specifically, the problem is that the resources are safe only if they make it
into a managing auto_ptr, but the same problems already noted above can still
occur here before either auto_ptr constructor is ever reached. This is because
both of the two problematic execution orders mentioned above are still possible,
just with the auto_ptr constructors tacked onto the end before f(). For one
example:</p>

<p>1: allocate memory for T1<br>
2: construct T1<br>
3: allocate memory for T2<br>
4: construct T2<br>
5: construct auto_ptr&lt;T1&gt;<br>
6: construct auto_ptr&lt;T2&gt;<br>
7: call f()</p>

<p>In the above case, the same problems as before are still present if either of
steps 3 or 4 throws. Similarly:</p>

<p>1: allocate memory for T1<br>
2: allocate memory for T2<br>
3: construct T1<br>
4: construct T2<br>
5: construct auto_ptr&lt;T1&gt;<br>
6: construct auto_ptr&lt;T2&gt;<br>
7: call f()</p>

<p>Again, the same problems as before are still present if either of steps 3 or
4 throws.</p>
<p>Fortunately, though, this is not a problem with auto_ptr; auto_ptr is just
being used the wrong way, that's all. In a moment, we'll see several ways to use
it better.</p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Aside: A Non-Solution<!--mstheme--></font></h4>
<p>Note that the following is not a solution:</p>
<!--mstheme--></font><pre>  //  In some header file:
  void f( auto_ptr&lt;T1&gt; = auto_ptr&lt;T1&gt;( new T1 ),
          auto_ptr&lt;T2&gt; = auto_ptr&lt;T1&gt;( new T2 ) );</pre><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font><pre>  //  In some implementation file:
  f();</pre><!--mstheme--><font face="Arial, Arial, Helvetica">
<p>Why is this code not a solution? Because it's identical to Example 3 in terms
of expression evaluation. Default arguments are considered to be created in the
function call expression, even though they're actually written somewhere else
entirely (namely, in the function declaration).</p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">A Limited Solution<!--mstheme--></font></h4>
<p><font color="#999933"><b><font size="4">4.</font></b>   Demonstrate how to
write an auto_ptr_new facility that solves the safety problems in Question 3 and
can be invoked as follows:</font></p>
<!--mstheme--></font><pre><font color="#999933">    //  Example 4
    //</font></pre><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font><pre><font color="#999933">    //  In some header file (same as in Example 2b):
    void f( auto_ptr&lt;T1&gt;, auto_ptr&lt;T2&gt; );</font></pre><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font><pre><font color="#999933">    //  In some implementation file:
    f( auto_ptr_new&lt;T1&gt;(), auto_ptr_new&lt;T2&gt;() );</font></pre><!--mstheme--><font face="Arial, Arial, Helvetica">

<p>The simplest solution is to provide a function template like the following:</p>

<!--mstheme--></font><pre>  //  Example 4(a): Partial solution
  //
  template&lt;class T&gt;
  auto_ptr&lt;T&gt; auto_ptr_new()
  {
    return auto_ptr&lt;T&gt;( new T );
  }</pre><!--mstheme--><font face="Arial, Arial, Helvetica">

<p>This solves the exception safety problems with Examples 2 through 4. No
sequence of generated code can cause resources to be leaked, because now all we
have is two functions, and we know that one must be executed entirely before the
other. Consider the following evaluation order:</p>

<p>1: call auto_ptr_new&lt;T1&gt;()<br>
2: call auto_ptr_new&lt;T2&gt;()</p>

<p>If step 1 throws, there are no leaks because the auto_ptr_new() template is
itself strongly exception-safe.</p>
<p>If step 2 throws, then is the temporary auto_ptr&lt;T1&gt; created by step 1
guaranteed to be cleaned up? The answer is: Yes, it is. Now, one might wonder,
isn't this pretty much the same as the &quot;new T1&quot; object being created
in the corresponding case in Example 2, which isn't correctly cleaned up? No,
this time it's not quite the same, because here the auto_ptr&lt;T1&gt; is
actually a temporary object, and cleanup of temporary objects is correctly
specified in the Standard. From the Standard, in 12.2/3:</p>
<blockquote>
  <p><i>Temporary objects are destroyed as the last step in evaluating the
  full-expression (_intro.execution_) that (lexically) contains the point where
  they were created. This is true even if that evaluation ends in throwing an
  exception.</i></p>
</blockquote>
<p>But Example 4(a) is only a limited solution: It only works with a default
constructor, which breaks if a given type T doesn't have a default constructor,
or if you don't want to use it. A more general solution is still needed.</p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Generalizing the auto_ptr_new() Solution<!--mstheme--></font></h4>

<p>As pointed out by Dave Abrahams, we can extend the solution to support
non-default constructors by providing a family of overloaded function templates:</p>

<!--mstheme--></font><pre>  //  Example 4(b): Improved solution
  //
  template&lt;class T&gt;
  auto_ptr&lt;T&gt; auto_ptr_new()
  {
    return auto_ptr&lt;T&gt;( new T );
  }</pre><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font><pre>  template&lt;class T, class Arg1&gt;
  auto_ptr&lt;T&gt; auto_ptr_new( const Arg1&amp; arg1 )
  {
    return auto_ptr&lt;T&gt;( new T( arg1 ) );
  }</pre><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font><pre>  template&lt;class T, class Arg1, class Arg2&gt;
  auto_ptr&lt;T&gt; auto_ptr_new( const Arg1&amp; arg1,
                            const Arg2&amp; arg2 )
  {
    return auto_ptr&lt;T&gt;( new T( arg1, arg2 ) );
  }</pre><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font><pre>  // etc.</pre><!--mstheme--><font face="Arial, Arial, Helvetica">
<p>Now auto_ptr_new() fully and naturally supports non-default construction.</p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">A Better Solution<!--mstheme--></font></h4>
<p>Although auto_ptr_new() is nice, is there any way we could have avoided all
of the exception safety problems without writing such helper functions? Could we
have avoided the problems with better coding standards? The answer is yes, and
here is one possible standard that would have eliminated the problem:</p>
<blockquote>
  <p>POSSIBLE GUIDELINE (Alternative #1):</p>
  <p>Never allocate resources (e.g., via new) in the same expression as any
  other code that could throw an exception. This applies even if the new
  resource will immediately be managed (e.g., passed to an auto_ptr constructor)
  in the same expression.</p>
</blockquote>
<p>In the Example 3 code, the way to satisfy this guideline is to move one of
the temporary auto_ptrs into a separate named variable:</p>
<!--mstheme--></font><pre>  //  Example 3(a): A solution
  //</pre><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font><pre>  //  In some header file:
  void f( auto_ptr&lt;T1&gt;, auto_ptr&lt;T2&gt; );</pre><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font><pre>  //  In some implementation file:
  {
    auto_ptr&lt;T1&gt; t1( new T1 );
    f( t1, auto_ptr&lt;T2&gt;( new T2 ) );
  }</pre><!--mstheme--><font face="Arial, Arial, Helvetica">

<p>This satisfies Guideline #1 because, although we are still allocating a
resource, it can't be leaked due to an exception because it's not being created
in the same expression as any other code that could throw.<b><sup><a href="#1">[1]</a></sup></b></p>

<p>Here is another possible coding standard, which is even simpler and easier to
get right (and easier to catch in code reviews):</p>
<blockquote>
  <p>POSSIBLE GUIDELINE (Alternative #2):</p>
  <p>Perform every resource allocation (e.g., new) in its own code statement
  which immediately gives the new resource to a manager object (e.g., auto_ptr).</p>
</blockquote>
<p>In Example 3, the way to satisfy this guideline is to move both of the
temporary auto_ptrs into separate named variables:</p>
<!--mstheme--></font><pre>  //  Example 3(b): A simpler solution
  //</pre><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font><pre>  //  In some header file:
  void f( auto_ptr&lt;T1&gt;, auto_ptr&lt;T2&gt; );</pre><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font><pre>  //  In some implementation file:
  {
    auto_ptr&lt;T1&gt; t1( new T1 );
    auto_ptr&lt;T2&gt; t2( new T2 );
    f( t1, t2 );
  }</pre><!--mstheme--><font face="Arial, Arial, Helvetica">

<p>This satisfies Guideline #2, and it required a lot less thought to get it
right. Each new resource is created in its own expression and is immediately
given to a managing object.</p>

<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Summary<!--mstheme--></font></h4>
<p>My recommendation is:</p>
<blockquote>
  <p><b>GUIDELINE:</b></p>
  <p><b>Perform every resource allocation (e.g., new) in its own code statement
  which immediately gives the new resource to a manager object (e.g., auto_ptr).</b></p>
</blockquote>
<p>This guideline is easy to understand and remember, it neatly avoids all of
the exception safety problems in the original problem, and by mandating the use
of manager objects it helps to avoid many other exception safety problems as
well. This guideline is a good candidate for inclusion in your team's coding
standards.</p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Acknowledgments<!--mstheme--></font></h4>
<p>This GotW was prompted by a discussion thread on comp.lang.c++.moderated.
This solution draws on observations presented by gurus James Kanze, Steve
Clamage, and Dave Abrahams in that and other threads, and in private
correspondence.</p>

<p>&nbsp;</p>

<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Notes<!--mstheme--></font></h4>
<p><a name="1"></a>1. Yes, I'm being a little fuzzy, because I know that the
body of f() is included in the expression evaluation and we don't care whether
or not it throws.</p>
<!--mstheme--></font><!--msnavigation--></td></tr><!--msnavigation--></table><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td><!--mstheme--><font face="Arial, Arial, Helvetica"><h4 align="right"><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666"><a href="../copyright.htm"><font size="2">Copyright ©
2002 Herb Sutter</font></a><!--mstheme--></font></h4>

<!--mstheme--></font></td></tr><!--msnavigation--></table></body>
</html>

