ID=D0082
URL=http://www.jchq.net/tutorial/01_02Tut.htm
SIZE=42932
DATE=16/07/02
TIME=14:36:48
DATASET=Java
HTML=<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
	<TITLE>1.2) Declarations and access control</TITLE>
	<META NAME="GENERATOR" CONTENT="StarOffice/5.2 (Linux)">
	<META NAME="CREATED" CONTENT="20010408;9051300">
	<META NAME="CHANGEDBY" CONTENT="Marcus Green">

<link rel="stylesheet" href="tutor.css"></HEAD>

<BODY BGCOLOR="#ffffff">

<TABLE WIDTH=95% BORDER=0 CELLPADDING=2 CELLSPACING=0 STYLE="page-break-before: always">
	<COL WIDTH=147*>
	<COL WIDTH=109*>
	<TR>
		<TD WIDTH=57% HEIGHT=104>
			<P><A HREF="introj2.htm"><IMG SRC="images/btnIndex.jpg" NAME="Graphic1" ALT="Return to Tutorial Index" ALIGN=BOTTOM WIDTH=55 HEIGHT=39 BORDER=0></A><A HREF="introj2.htm"><BR><BR></A><A HREF="../index.htm"><IMG SRC="images/btnHome.jpg" NAME="Graphic2" ALT="Back to the home page of this site" ALIGN=BOTTOM WIDTH=55 HEIGHT=39 BORDER=0></A>
						</P>
		</TD>
		<TD WIDTH=43%>

<script language="JavaScript" src="/ads/adjs.php?what=%&withText=true"></script>
		</TD>
	</TR>
	<TR>
		<TD WIDTH=57% HEIGHT=11>
			<H1 ALIGN=LEFT>Java2 Certification <BR>Tutorial 
			</H1>
		</TD>
		<TD WIDTH=43% BGCOLOR="#ff9900">
			<P>&nbsp;</P>
		</TD>
	</TR>
</TABLE>
<P>You can discuss this topic with others at
<A HREF="http://www.jchq.net/discus">http://www.jchq.net/discus</A><BR>Read
reviews and buy a Java Certification book at
<A HREF="http://www.jchq.net/bookreviews/jcertbooks.htm">http://www.jchq.net/bookreviews/jcertbooks.htm</A>
</P>
<HR SIZE=5 noshade>
<H1><B>1) Declarations and Access Control</B> 
</H1>
<H2>Objective 2</H2>
<P><FONT FACE="Arial, Helvetica">Declare classes, inner classes,
methods, instance variables static, variables and automatic (method
local) variables, making appropriate use of all permitted modifiers
(such as public final static abstract and so forth). State the
significance of each of these modifiers both singly and in
combination and state the effect of package relationships on declared
items qualified by these modifiers.</FONT></P>
<H3><I>Comment on the objective</I></H3>
<P>I find it a little disturbing that the objective uses the words
<I>&quot;and so forth&quot;.</I><BR>I suspect this means you should
also be aware of</P>
<UL>
	<LI><ALIGN=LEFT>native</li> 
	<LI><ALIGN=LEFT>transient </li>
	<LI><ALIGN=LEFT>synchronized </li>
	<LI><ALIGN=LEFT>volatile </li>
</UL>
<H3>Comparing C++/VB classes with Java 
</H3>
<P>Because Java was designed to be easy for C++ programmers to learn
there are many similarities between the way the two languages deal
with classes. Both C++ and Java have inheritance, polymorphism, and
data hiding using visibility modifiers. Some of the ways in which
they differ are to do with making Java an easier language to learn
and use.<BR><BR>The C++ language implements multiple inheritance and
thus a class can have more than one parent (or base) class. Java
allows only single inheritance and thus can only ever have a single
parent. To overcome this limitation Java has a feature called
interfaces. The language designers decided that interfaces would give
some of the benefits of multiple inheritance without the drawbacks.
All Java classes are descendants of the great ancestor class called
<I>Object</I>.<BR><BR>Objects in Visual Basic are somewhat of a bolt
on afterthought to the language. Visual Basic is sometimes called an
Object Based language rather than Object Oriented. It is almost as if
the language designers decided that classes are cool and with VB
version 4 decided that they would create a new type of module, call
it a class and use the dot notation to make it more like C++. The
crucial element missing from the VB concept of class is that of
inheritance. With VB5 Microsoft delivered the concept of interfaces
which acts similarly to the Java concept of an interface. Some of the
main similarities between VB classes and Java classes is the use of
references and the keyword <I>new</I> word.</P>
<H3>The role of classes in Java</H3>
<P>Classes are the heart of Java, all Java code occurs within a
class. There is no concept of free standing code and even the most
simple HelloWorld application involves the creation of a class. To
indicate that a class is a descendent of another class the <I>extends</I>
keyword is used. If the <I>extends</I> keyword is not used the class
will be a descended of the base class Object, which gives it some
basic functionality including the ability to print out its name and
some of the capability required in threads.</P>
<H3>The simplest of class</H3>
<P>The minimum requirements to define a class are the keyword <I>class</I>,
the class name and the opening and closing braces. Thus</P>
<PRE STYLE="margin-bottom: 0.2in">class classname {}</PRE><P>
is a syntactically correct, if not particularly useful class
(surprisingly I have found myself defining classes like this, when
creating examples to illustrate inheritance).</P>
<P>Normally a class will also include an access specifier before the
keyword class and of course, a body between the braces. Thus this is
a more sensible template for a class.</P>
<PRE STYLE="margin-bottom: 0.2in">public class classname{
//Class body goes here
}</PRE><H3>
Creating a simple <I>HelloWorld</I> class 
</H3>
<P>Here is a simple HelloWorld program that will output the string
&quot;hello world&quot; to the console.</P>
<PRE>public class HelloWorld{
public static void main(String argv[]){
        System.out.println(&quot;Hello world&quot;);
        }

}//End class definition</PRE><P>
The keyword <I>public</I> is a visibility modifier that indicates
this class should be visible to any other class. Only one outer class
per file can be declared public. Inner classes will be covered
elsewhere. If you declare more than one class in a file to be public,
a compile time error will occur. Note that Java is case sensitive in
every respect. The file that contains this class must be called
HelloWorld.Java. Of course this is somewhat of an anomaly on
Microsoft platforms that preserve, yet ignore the case of letters in
a file name.</P>
<P>The keyword <I>class</I> indicates that a class is about to be
defined and <I>HelloWorld</I> is the name of that class. The curly
braces indicate the start of the class. Note that the closing brace
that ends the class definition does not involve any closing semi
colon. The comment</P>
<PRE STYLE="margin-bottom: 0.2in">//End class definition </PRE><P>
uses the style of single line comments that is available in C/C++.
Java also understands the multi-line /* */ form of comments.</P>
<H3>The magic of the <I>main</I> name 
</H3>
<P>Giving a method the following signature has a certain significance
(or magic) as it indicates to Java that this is where the program
should begin its run, (similar to <I>main</I> in the C language).</P>
<PRE STYLE="margin-bottom: 0.2in">public static void main(String argv[]){</PRE><P>
This line indicates that a method called <I>main</I> is being defined
that takes arguments (or parameters) of an array of Strings. This
method is public, i.e. visible from anywhere that can see this class.
The <I>static </I>keyword indicates that this method can be run
without creating an instance of the class. If that means nothing to
you, don't worry about it for the moment as <I>static</I> methods
will be covered at length elsewhere. The keyword <I>void</I>
indicates the data type returned from this method when it is called.
The use of <I>void</I> indicates that no value will be returned.<BR><BR>The
parameters of the <I>main</I> method</P>
<PRE STYLE="margin-bottom: 0.2in">String argv[] </PRE><P>
Indicate that the method takes an array of type <I>String</I>. The
square brackets indicate an array. Note that the data type <I>String</I>
starts with an upper case S. This is important as Java is thoroughly
case sensitive. Without this exact signature the Java Virtual Machine
will not recognise the method as the place to start execution of the
program.</P>
<H3>Creating an instance of a class 
</H3>
<P>The <I>HelloWorld</I> application as described above is handy to
illustrate the most basic of applications that you can create, but it
misses out on one of the most crucial elements of using classes, the
use of the key word</P>
<P><BR><I>new</I></P>
<P>Which indicates the creation of a new instance of a class. In the
<I>HelloWorld</I> application this was not necessary as the only
method that was called was <I>System.out.println</I>, which is a
static method and does not require the creation of a class using the
new keyword. Static methods can only access static variables, of
which only one instance can exist per class. The <I>HelloWorld</I>
application can be slightly modified to illustrate the creation of a
new instance of a class.</P>
<PRE>public class HelloWorld2{
        public static void main(String argv[]){        
                HelloWorld2 hw = new HelloWorld2();
                hw.amethod();
        }
       
        public void amethod(){        
                System.out.println(&quot;Hello world&quot;);
        }

}</PRE><P>
This code creates a new instance of itself with the line</P>
<PRE STYLE="margin-bottom: 0.2in">                HelloWorld2 hw = new HelloWorld2();</PRE><P>
This syntax of creating a new instance of a class is basic to the use
of classes. Note how the name of the class appears twice. The first
time indicates the data type of the reference to the class. This need
not be the same as the actual type of the class as indicated after
the use of the <I>new</I> keyword. The name of this instance of the
class is <I>hw</I>. This is simply a name chosen for a variable.
There is a naming convention that an instance of a class starts with
a lower case letter, whereas the definition of a class starts with an
upper case letter.</P>
<P>The empty parenthesis for the name of the class <I>HelloWorld()</I>
indicate that the class is being created without any parameters to
its constructor. If you were creating an instance of a class that was
initialized with a value or a string such as the label of a button
the parenthesis would contain one or more initializing values.</P>
<H3>Creating Methods 
</H3>
<P>As illustrated in the last example <I>HelloWorld2</I>, a method in
Java is similar to a function in C/C++ and a function or sub in
Visual Basic. The method called <I>amethod</I> in that example is the
method called <I>amethod</I> in this example is declared as</P>
<P><I>public</I></P>
<P>To indicate it can be accessed from anywhere. It has a return type
of</P>
<P><BR><I>void</I></P>
<P>indicating no value will be returned. And it has empty
parenthesis, indicating that it takes no parameters.</P>
<P><BR>The same method might have been defined in these alternative
ways</P>
<PRE>private void amethod(String s)

private void amethod(int i, String s)

protected void amethod(int i)</PRE><P>
These examples are to illustrate some other typical signatures of
methods. The use of the keywords <I>private</I> and <I>protected</I>
will be covered elsewhere.</P>
<P>The difference between Java methods and methods in a non OO
language such as C is that the methods belong to a class. This means
they are called using the dot notation indicating the instance of the
class that the code belongs to. (Static methods are an exception to
this but don't worry about that at the moment).</P>
<P>Thus in HelloWorld2 amethod was called thus</P>
<PRE>                HelloWorld hw = new HelloWorld()
                hw.amethod();</PRE><P>
If other instances of the <I>HelloWorld</I> class had been created
the method could have been called from each instance of the class.
Each instance of the class would have access to its own variables.
Thus the following would involve calling the amethod code from
different instances of the class.</P>
<PRE>HelloWorld hw = new HelloWorld();
HelloWorld hw2 = new HelloWorld();
hw.amethod();
hw2.amethod();</PRE><P>
The two instances of the class <I>hw</I> and <I>hw2</I> might have
access to different variables.</P>
<H3>Automatic variables 
</H3>
<P>Automatic variables are method variables. They come into scope
when the method code starts to execute and cease to exist once the
method goes out of scope. As they are only visible within the method
they are typically useful for temporary manipulation of data. If you
want a value to persist between calls to a method then a variable
needs to be created at class level.</P>
<P>An automatic variable will &quot;shadow&quot; a class level
variable.</P>
<P><BR>Thus the following code will print out 99 and not 10.</P>
<PRE>public class Shad{
public int iShad=10;
public static void main(String argv[]){
                Shad s = new Shad();
                s.amethod();
        }//End of main
        public void amethod(){
                int iShad=99;
                System.out.println(iShad);
        }//End of amethod
}</PRE><H3>
Modifiers and encapsulation 
</H3>
<table width=100% border=0 cellpadding=2 cellspacing=0>
  <col width=33*> <col width=223*> 
  <tr> 
    <td width=13%> 
      <h1><img src="images/key2.gif" name="Graphic4" align=BOTTOM width=106 height=73 border=0></h1>
    </td>
    <td width=87%> 
      <h4><font color="#ff0000">The visibility modifiers are part of the encapsulation 
        mechanism for Java. Encapsulation allows separation of the interface from 
        the implementation of methods.</font></h4>
    </td>
  </tr>
</table>
<P>The visibility modifiers are a key part of the encapsulation
mechanism for java. Encapsulation allows separation of the interface
from the implementation of methods. The benefit of this is that the
details of the code inside a class can be changed without it
affecting other objects that use it. This is a key concept of the
Object Oriented paradaigm (had to use that word somewhere
eventually).</P>
<P>Encapsulation generally takes form of methods to retrieve and
update the values of <I>private</I> class variables. These methods
are known as a <I>accessor</I> and <I>mutator</I> methods. The
accessor (or get) method retrieves the value and the mutator changes
(or sets) the value. The naming convention for these methods are
<I>setFoo</I> to change a variable and <I>getFoo</I> to obtain the
contents of a variable. An aside note: the use of <I>get</I> and <I>set</I>
in the naming of these methods is more significant than just
programmer convenience and is an important part of the Javabeans
system. Javabeans are not covered in the programmer exam however.</P>
<P>Take the example where you had a variable used to store the age of
a student.</P>
<P>You might store it simply with a public integer variable 
</P>
<P><I>int iAge;</I></P>
<P>later when your application is delivered you find that some of
your students have a recorded age of more than 200 years and some
have an age of less than zero. You are asked to put in code to check
for these error conditions. So wherever your programs change the age
value, you write if statements that check for the range. 
</P>
<PRE>if(iAge &gt; 70){
        //do something
        }
if (iAge &lt;3){
        //do something
}</PRE><P>
In the process of doing this you miss some code that used the iAge
variable and you get called back because you have a 19 year old
student who is on your records has being 190 years old.</P>
<P>The Object Oriented approach to this problem using encapsulation,
is to create methods that access a private field containing the age
value, with names like setAge and getAge. The setAge method might
take an integer paramete and update the private value for Age and the
getAge method would take no parameter but return the value from the
private age field.</P>
<PRE>public void setAge(int iStudentAge){
        iAge = iStudentAge;
}

public int getAge(){
        return iAge;
}</PRE><P>
At first this seems a little pointless as the code seems to be a long
way around something that could be done with simple variable
manipulation. However when they come back to you with the requirement
to do more and more validation on the iAge field you can do it all in
these methods without affecting existing code that uses this
information. 
</P>
<P>By this approach the implementation of code, (the actual lines of
program code), can be changed whilst the way it looks to the outside
world (the interface) remains the same.</P>
<P>&nbsp; 
</P>
<H3>Private</H3>
<P>Private variables are only visible from within the same class as
they are created.in. This means they are NOT visible within sub
classes. This allows a variable to be insulated from being modified
by any methods except those in the current class. As described in
modifiers and encapsulation, this is useful in separating the
interface from the implementation.</P>
<PRE>class Base{
private int iEnc=10;
public void setEnc(int iEncVal){
     if(iEncVal &lt; 1000){
         iEnc=iEncVal;
          }else
          System.out.println(&quot;Enc value must be less than 1000&quot;);
         //Or Perhaps thow an exception
        }//End if
}

public class Enc{
public static void main(String argv[]){
                Base b = new Base();
                b.setEnc(1001);
        }//End of main
}</PRE><H3>
Public 
</H3>
<P>The <I>public</I> modifier can be applied to a variable (field) or
a class. It is the first modifier you are likely to come across in
learning Java. If you recall the code for the <I>HelloWorld</I>.Java
program the class was declared as</P>
<PRE STYLE="margin-bottom: 0.2in">public class HelloWorld</PRE><P>
This is because the Java Virtual Machine only looks in a class
declared as public for the magic<I> main</I> startup method</P>
<PRE STYLE="margin-bottom: 0.2in">public static void main(String argv[])</PRE><P>
A public class has global scope, and an instance can be created from
anywhere within or outside of a program. Only one non inner class in
any file can be defined with the <I>public</I> keyword. If you define
more than one non inner class in a file with the keyword public the
compiler will generate an error.</P>
<P>Using the public modifier with a variable makes it available from
anywhere. It is used as follows,</P>
<PRE STYLE="margin-bottom: 0.2in">public int myint =10;</PRE><P>
If you want to create a variable that can be modified from anywhere
you can declare it as public. You can then access it using the dot
notation similar to that used when calling a method.</P>
<PRE>class Base {
        public int iNoEnc=77;
}
public class NoEnc{
public static void main(String argv[]){
                Base b = new Base();
                b.iNoEnc=2;
                System.out.println(b.iNoEnc);
        }//End of main
}</PRE><P>
Note that this is not the generally suggested way as it allows no
separation between the interface and implementation of code. If you
decided to change the data type of <I>iNoEnc,</I> you would have to
change the implementation of every part of the external code that
modifies it.</P>
<H3>Protected 
</H3>
<P>The <I>protected</I> modifier is a slight oddity. A <I>protected</I>
variable is visible within a class, and in sub classes, the same
package but not elsewhere. The qualification that it is visible from
the same package can give more visibility than you might suspect. Any
class in the same directory is considered to be in the default
package, and thus protected classes will be visible. This means that
a protected variable is more visible than a variable defined with no
access modifier. <BR><BR>A variable defined with no access modifier
is said to have default visibility. Default visibility means a
variable can be seen within the class, and from elsewhere within the
same package, but not from sub-classes that are not in the same
package.</P>
<H3>Static</H3>
<P><I>Static</I> is not directly a visibility modifier, although in
practice it does have this effect. The modifier <I>static</I> can be
applied to an inner class, a method and a variable. Marking a
variable as <I>static</I> indicates that only one copy will exist per
class. This is in contrast with normal items where for instance with
an integer variable a copy belongs to each instance of a class. Thus
in the following example of a non <I>static</I> <I>integer</I> three
instances of the <I>integer</I> iMyVal will exist and each instance
can contain a different value.</P>
<PRE>class MyClass{
        public int iMyVal=0;
}
public class NonStat{
public static void main(String argv[]){
        MyClass m1 = new MyClass();
        m1.iMyVal=1;
        MyClass m2 = new MyClass();
        m2.iMyVal=2;
        MyClass m3 = new MyClass();
        m3.iMyVal=99;
        //This will output 1 as each instance of the class
        //has its own copy of the value iMyVal
        System.out.println(m1.iMyVal);
        }//End of main

}</PRE><P>
<BR>The following example shows what happens when you have multiple
instances of a class containing a static integer.</P>
<PRE>class MyClass{
        public static  int iMyVal=0;

}//End of MyClass
public class Stat{
public static void main(String argv[]){
           MyClass m1 = new MyClass();
           m1.iMyVal=0;
           MyClass m2 = new MyClass();
           m2.iMyVal=1;
           MyClass m3 = new MyClass();
           m2.iMyVal=99;
           //Because iMyVal is static, there is only one 
           //copy of it no matter how many instances 
           //of the class are created /This code  will 
           //output a value of 99
           System.out.println(m1.iMyVal);
        }//End of main

}</PRE><P>
Bear in mind that you cannot access non static variables from within
a static method. Thus the following will cause a compile time error</P>
<PRE>public class St{
int i;
public static void main(String argv[]){
        i = i + 2;//Will cause compile time error
        }
}</PRE>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=16%>
			<P><IMG SRC="images/key2.gif" NAME="Graphic5" ALT="Key Concept" ALIGN=BOTTOM WIDTH=106 HEIGHT=73 BORDER=0></P>
		</TD>
		<TD WIDTH=84%>
			<H4><FONT COLOR="#ff0000">A static method cannot be overriden to
			be non static in a child class</FONT></H4>
		</TD>
	</TR>
</TABLE>
<P>A static method cannot be overriden to be non static in a child
class. Also a non static (normal)  method cannot be overriden to be 
static in a child class. There is no similar rule with reference to
overloading. The following code will cause an error as it attempts to
override the class amethod to be non-static.</P>
<PRE>class Base{
        public static void amethod(){
        }
}

public class Grimley extends Base{
        public void amethod(){}//Causes a compile time error
}</PRE><P>
The IBM Jikes compiler produces the following error</P>
<PRE>Found 1 semantic error compiling &quot;Grimley.java&quot;:

     6.         public void amethod(){}

                            &lt;-------&gt;

*** Error: The instance method &quot;void amethod();&quot; 

cannot override the static method &quot;void amethod();&quot; 

declared in type &quot;Base&quot;</PRE><H3>
Native</H3>
<P>The native modifier is used only for methods and indicates that
the body of the code is written in a language other than Java such as
C and C++. Native methods are often written for platform specific
purposes such as accessing some item of hardware that the Java
Virtual Machine is not aware of. Another reason is where greater
performance is required.<BR><BR>A native method ends with a semicolon
rather than a code block. Thus the following would call an external
routine, written perhaps in C++</P>
<PRE STYLE="margin-bottom: 0.2in">public native fastcalc();</PRE><H3>
Abstract 
</H3>
<P>It is easy to overlook the <I>abstract</I> modifier and miss out
on some of its implications. It is the sort of modifier that the
examiners like to ask tricky questions about.<BR><BR>The <I>abstract</I>
modifier can be applied to classes and methods. When applied to a
method it indicates that it will have no body (ie no curly brace
part) and the code can only be run when implemented in a child class.
However there are some restrictions on when and where you can have
<I>abstract</I> methods and rules on classes that contain them. A
class must be declared as abstract if it has one or more abstract
methods or if it inherits abstract methods for which it does not
provide an implementation. The other circumstance when a class must
be declared abstract is if it implements an interface but does not
provide implementations for every method of the interface. This is a
fairly unusual circumstance however.</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=17%>
			<P><IMG SRC="images/becareful.gif" NAME="Graphic6" ALIGN=BOTTOM WIDTH=76 HEIGHT=88 BORDER=0></P>
		</TD>
		<TD WIDTH=83%>
			<H4><FONT COLOR="#ff0000">If a class has any abstract methods it
			must be declared abstract itself.</FONT></H4>
		</TD>
	</TR>
</TABLE>
<P>Do not be distracted into thinking that an <I>abstract</I> class
cannot have non <I>abstract</I> methods. Any class that descends from
an <I>abstract</I> class must implement the <I>abstract</I> methods
of the base class or declare them as <I>abstract</I> itself. These
rules tend to beg the question why would you want to create <I>abstract</I>
methods?<BR><BR>Abstract methods are mainly of benefit to class
designers. They offer a class designer a way to create a prototype
for methods that ought to be implemented, but the actual
implementation is left to people who use the classes later on. Here
is an example of an <I>abstract</I> a class with an abstract method.
Again note that the class itself is declared <I>abstract</I>,
otherwise a compile time error would have occurred.</P>
<P>The following class is abstract and will compile correctly and
print out the string</P>
<PRE>public abstract class abstr{
public static void main(String argv[]){
        System.out.println(&quot;hello in the abstract&quot;);
        }
        public abstract int amethod();
}

 </PRE><H3>
Final</H3>
<P>The final modifier can be applied to classes, methods and
variables. It has similar meanings related to inheritance that make
it fairly easy to remember. A final class may never be subclassed.
Another way to think of this is that a <I>final</I> class cannot be a
parent class. Any methods in a <I>final</I> class are automatically
<I>final</I>. This can be useful if you do not want other programmers
to &quot;mess with your code&quot;. Another benefit is that of
efficiency as the compiler has less work to do with a final method.
This is covered well in Volume 1 of Core Java.</P>
<P>The <I>final</I> modifier indicates that a method cannot be
overriden. Thus if you create a method in a sub class with exactly
the same signature you will get a compile time error.</P>
<P>The following code illustrates the use of the <I>final</I>
modifier with a class. This code will print out the string &quot;amethod&quot;</P>
<PRE>final class Base{

public void amethod(){
        System.out.println(&quot;amethod&quot;);
        }
}

public class Fin{
public static void main(String argv[]){
        Base b = new Base();
        b.amethod();
        }
}</PRE><P>
A final variable cannot have it's value changed and must be set at
creation time. This is similar to the idea of a constant in other
languages.</P>
<H3>Synchronized 
</H3>
<P>The <I>synchronized</I> keyword is used to prevent more than one
thread from accessing a block of code at a time. See section 7 on
threads to understand more on how this works.</P>
<H3>Transient</H3>
<P>The <I>transient</I> keyword is one of the less frequently used
modifiers. It indicates that a variable should not be written out
when a class is serialized.</P>
<H3>Volatile</H3>
<P>You probably will not get a question on the <I>volatile</I>
keyword. The worst you will get it is recognising that it actually is
a Java keyword. According to Barry Boone <BR><BR><I>&quot;it tells
the compiler a variable may change asynchronously due to
threads&quot;</I><BR><BR>Accept that it is part of the language and
then get on worrying about something else</P>
<H3>Using modifiers in combination</H3>
<P>The visibility modifiers cannot be used in combination, thus a
variable cannot be both <I>private</I> and <I>public</I>, <I>public</I>
and <I>protected</I> or <I>protected</I> and <I>private</I>. You can
of course have combinations of the visibility modifiers and the
modifiers mentioned in my <I>so forth</I> list</P>
<UL>
	<LI><ALIGN=LEFT>native </LI>
	<LI><ALIGN=LEFT>transient </LI>
	<LI><ALIGN=LEFT>synchronized </LI>
	<LI><ALIGN=LEFT>volatile </LI>
	
</UL>
<P>Thus you can have a public static native method.</P>
<P ALIGN=CENTER STYLE="margin-bottom: 0in"><B>Where modifiers can be
used</B> 
</P>
<CENTER>
	<TABLE WIDTH=48% BORDER=1 CELLPADDING=2 CELLSPACING=2 BGCOLOR="#ffcccc">
		<TR>
			<TD WIDTH=18%>
				<P><B>Modifier</B></P>
			</TD>
			<TD WIDTH=8%>
				<P><B>Method</B></P>
			</TD>
			<TD WIDTH=9%>
				<P><B>Variable</B></P>
			</TD>
			<TD WIDTH=65%>
				<P><B>class</B></P>
			</TD>
		</TR>
		<TR>
			<TD WIDTH=18%>
				<P>public</P>
			</TD>
			<TD WIDTH=8%>
				<P>yes</P>
			</TD>
			<TD WIDTH=9%>
				<P>yes</P>
			</TD>
			<TD WIDTH=65%>
				<P>yes</P>
			</TD>
		</TR>
		<TR>
			<TD WIDTH=18%>
				<P>private</P>
			</TD>
			<TD WIDTH=8%>
				<P>yes</P>
			</TD>
			<TD WIDTH=9%>
				<P>yes</P>
			</TD>
			<TD WIDTH=65%>
				<P>yes (nested)</P>
			</TD>
		</TR>
		<TR>
			<TD WIDTH=18%>
				<P>protected</P>
			</TD>
			<TD WIDTH=8%>
				<P>yes</P>
			</TD>
			<TD WIDTH=9%>
				<P>yes</P>
			</TD>
			<TD WIDTH=65%>
				<P>yes(nested)</P>
			</TD>
		</TR>
		<TR>
			<TD WIDTH=18%>
				<P>abstract</P>
			</TD>
			<TD WIDTH=8%>
				<P>yes</P>
			</TD>
			<TD WIDTH=9%>
				<P>no</P>
			</TD>
			<TD WIDTH=65%>
				<P>yes</P>
			</TD>
		</TR>
		<TR>
			<TD WIDTH=18%>
				<P>final</P>
			</TD>
			<TD WIDTH=8%>
				<P>yes</P>
			</TD>
			<TD WIDTH=9%>
				<P>yes</P>
			</TD>
			<TD WIDTH=65%>
				<P>yes</P>
			</TD>
		</TR>
		<TR>
			<TD WIDTH=18%>
				<P>transient</P>
			</TD>
			<TD WIDTH=8%>
				<P>no</P>
			</TD>
			<TD WIDTH=9%>
				<P>yes</P>
			</TD>
			<TD WIDTH=65%>
				<P>no</P>
			</TD>
		</TR>
		<TR>
			<TD WIDTH=18%>
				<P>native</P>
			</TD>
			<TD WIDTH=8%>
				<P>yes</P>
			</TD>
			<TD WIDTH=9%>
				<P>no</P>
			</TD>
			<TD WIDTH=65%>
				<P>no</P>
			</TD>
		</TR>
		<TR>
			<TD WIDTH=18%>
				<P>volatile</P>
			</TD>
			<TD WIDTH=8%>
				<P>no</P>
			</TD>
			<TD WIDTH=9%>
				<P>yes</P>
			</TD>
			<TD WIDTH=65%>
				<P>no</P>
			</TD>
		</TR>
	</TABLE>
</CENTER>
<HR>
<H3>Exercise 1)</H3>
<P>Create a file called Whitley.java. In this file define a class
called Base with an abstract method called lamprey with an int return
type. In this file create a class called Whitley that extends the
base class. Give the Whitley class a method called lamprey and code
that prints out the string &quot;lamprey&quot;.. 
</P>
<P>Create a native method for the class called mynative. Now compile
and run the code.</P>
<H3>Exercise 2) 
</H3>
<P>Create a public class called Malvern. Create a private inner class
called Great that has a public void method called show. Make this
method print out the string &quot;Show&quot;. Give the class Malvern
a public method called go that creates an instance of Great and calls
its show method.. In the main method of Malvern create an instance of
itself. Make the instance of itself call its go method. Compile and
run the code.</P>
<HR>
<H3>Suggested solution to Exercise 1) 
</H3>
<PRE>abstract class Base{
abstract int lamprey();
}

public class Whitley extends Base{
public static void main(String argv[]){
        
        }

public int lamprey(){
        System.out.println(&quot;lamprey&quot;);
        return 99;
        }
native public void mynative();
}</PRE><H3>
Suggested solution to Exercise 2)</H3>
<PRE>public class Malvern{
public static void main(String argv[]){
        Malvern m = new Malvern();
        m.go();
        }
        public void go(){
        Great g = new Great();
        g.show();
        }

        private class Great{
                public void show(){
                        System.out.println(&quot;Show&quot;);     
                }
        }
}</PRE>
<HR>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=11%>
			<P><IMG SRC="images/Quiz.gif" NAME="Graphic7" ALIGN=BOTTOM WIDTH=99 HEIGHT=101 BORDER=0>
						</P>
		</TD>
		<TD WIDTH=89%>
			<P>&nbsp;</P>
		</TD>
	</TR>
</TABLE>
<HR>
<H1>Questions</H1>
<H4><B>Question 1)</B></H4>
<P>What will happen when you attempt to compile and run this code?</P>
<PRE>abstract class Base{
        abstract public void myfunc();
        public void another(){
        System.out.println(&quot;Another method&quot;);
        }
}

public class Abs extends Base{
        public static void main(String argv[]){
        Abs a = new Abs();
        a.amethod();
        }
        public void myfunc(){
                System.out.println(&quot;My func&quot;);
                } 

        public void amethod(){
        myfunc();
         }
}</PRE><P>
1) The code will compile and run, printing out the words &quot;My
Func&quot;<BR>2) The compiler will complain that the Base class has
non abstract methods<BR>3) The code will compile but complain at run
time that the Base class has non abstract methods<BR>4) The compiler
will complain that the method myfunc in the base class has no body,
nobody at all to looove it</P>
<P><BR><BR>
</P>
<HR>
<H4>Question 2)</H4>
<P>What will happen when you attempt to compile and run this code?</P>
<PRE>public class MyMain{
public static void main(String argv){
        System.out.println(&quot;Hello cruel world&quot;);
        }
}</PRE><P>
1) The compiler will complain that main is a reserved word and cannot
be used for a class<BR>2) The code will compile and when run will
print out &quot;Hello cruel world&quot;<BR>3) The code will compile
but will complain at run time that no constructor is defined<BR>4)
The code will compile but will complain at run time that main is not
correctly defined</P>
<P><BR><BR>
</P>
<HR>
<H4><B>Question 3)</B></H4>
<P>Which of the following are Java modifiers?<BR><BR>1) public<BR>2)
private<BR>3) friendly<BR>4) transient</P>
<HR>
<H4>Question 4)</H4>
<P>What will happen when you attempt to compile and run this code?</P>
<PRE>class Base{
        abstract public void myfunc();
        public void another(){
        System.out.println(&quot;Another method&quot;);
        }
}

public class Abs extends Base{
        public static void main(String argv[]){
        Abs a = new Abs();
        a.amethod();
        }
        public void myfunc(){
                System.out.println(&quot;My func&quot;);
                } 
        public void amethod(){
        myfunc();
        }

}</PRE><P>
1) The code will compile and run, printing out the words &quot;My
Func&quot;<BR>2) The compiler will complain that the Base class is
not declared as abstract.<BR>3) The code will compile but complain at
run time that the Base class has non abstract methods<BR>4) The
compiler will complain that the method myfunc in the base class has
no body, nobody at all to looove it</P>
<HR>
<H4>Question 5)</H4>
<P>Why might you define a method as native?</P>
<P>1) To get to access hardware that Java does not know about<BR>2)
To define a new data type such as an unsigned integer<BR>3) To write
optimised code for performance in a language such as C/C++<BR>4) To
overcome the limitation of the private scope of a method</P>
<P><BR><BR>
</P>
<HR>
<H4>Question 6)</H4>
<P>What will happen when you attempt to compile and run this code?</P>
<PRE>class Base{
public final void amethod(){
        System.out.println(&quot;amethod&quot;);
        }
}

public class Fin extends Base{
public static void main(String argv[]){
        Base b = new Base();
        b.amethod();
        }
}</PRE><P>
1) Compile time errror indicating that a class with any final methods
must be declared final itself<BR>2) Compile time error indicating
that you cannot inherit from a class with final methods<BR>3) Run
time error indicating that Base is not defined as final<BR>4) Success
in compilation and output of &quot;amethod&quot; at run time.</P>
<P><BR><BR>
</P>
<HR>
<H4>Question 7)</H4>
<P>What will happen when you attempt to compile and run this code?</P>
<PRE>public class Mod{
public static void main(String argv[]){
}
        public static native void amethod();
}</PRE><P>
1) Error at compilation: native method cannot be static<BR>2) Error
at compilation native method must return value<BR>3) Compilation but
error at run time unless you have made code containing native amethod
available<BR>4) Compilation and execution without error</P>
<P><BR><BR>
</P>
<HR>
<H4><BR><B>Question 8)</B></H4>
<P>What will happen when you attempt to compile and run this code?</P>
<PRE STYLE="margin-bottom: 0.2in">private class Base{}
public class Vis{
transient int  iVal;
public static void main(String elephant[]){
        }
}</PRE><P>
1) Compile time error: Base cannot be private<BR>2) Compile time
error indicating that an integer cannot be transient<BR>3) Compile
time error transient not a data type<BR>4) Compile time error
malformed main method</P>
<P><BR><BR>
</P>
<HR>
<H4><B>Question 9)</B></H4>
<P>What happens when you attempt to compile and run these two files
in the same directory?</P>
<PRE STYLE="margin-bottom: 0.2in">//File P1.java
package MyPackage;
class P1{
void afancymethod(){
        System.out.println(&quot;What a fancy method&quot;);
        }
}
//File P2.java
public class P2 extends P1{
afancymethod();
}</PRE><P>
1) Both compile and P2 outputs &quot;What a fancy method&quot; when
run<BR>2) Neither will compile<BR>3) Both compile but P2 has an error
at run time<BR>4) P1 compiles cleanly but P2 has an error at compile
time</P>
<H4><BR><B>Question 10)</B></H4>
<P>Which of the following are legal declarations?</P>
<P>1) public protected amethod(int i)<BR>2) public void amethod(int
i)<BR>3) public void amethod(void)<BR>4) void public amethod(int i)</P>
<HR>
<H2>Answers</H2>
<H4><B>Answer 1)</B></H4>
<P>1) The code will compile and run, printing out the words &quot;My
Func&quot;<BR><BR>An abstract class can have non abstract methods,
but any class that extends it must implement all of the abstract
methods.</P>
<H4><B>Answer 2)</B></H4>
<P>4) The code will compile but will complain at run time that main
is not correctly defined<BR><BR>The signature of main has a parameter
of String rather than string array</P>
<H4><BR><B>Answer 3)</B></H4>
<P>1) public<BR>2) private<BR>4) transient<BR><BR>Although some texts
use the word friendly when referring to visibility it is not a Java
reserved word. Note that the exam will almost certainly contain
questions that ask you to identify Java keywords from a list</P>
<H4><B>Answer 4)</B></H4>
<P>2) The compiler will complain that the Base class is not declared
as abstract.<BR><BR>The actual error message using my JDK 1.1
compiler was 
</P>
<PRE>Abs.java:1: class Base must be declared abstract. 

It does not define void myfunc

() from class Base.

class Base{

^

1 error</PRE><H4>
<B>Answer 5)</B></H4>
<P>1) To get to access hardware that Java does not know about<BR>3)
To write optimised code for performance in a language such as
C/C++<BR><BR>Although the creation of &quot;Pure Java&quot; code is
highly desirable, particularly to allow for platform independence, it
should not be a religion, and there are times when native code is
required.</P>
<H4><B>Answer 6)</B></H4>
<P>4) Success in compilation and output of &quot;amethod&quot; at run
time.<BR><BR>This code calls the version of amethod in the Base
class. If you were to attempt to implement an overriden version of
amethod in Fin you would get a compile time error.</P>
<H4><B>Answer 7)</B></H4>
<P>4) Compilation and execution without error<BR><BR>There is no call
to the native method and so no error occurs at run time</P>
<H4><B>Answer 8)</B> 
</H4>
<P>1) Compile time error: Base cannot be private</P>
<P>A top level class such as base cannot be declared to be private.</P>
<H4><B>Answer 9)</B></H4>
<P>4) P1 compiles cleanly but P2 has an error at compile time<BR><BR>Even
though P2 is in the same directory as P1, because P1 was declared
with the package statement it is not visible from P2</P>
<H4><BR><B>Answer 10)</B></H4>
<P>2) public void amethod(int i)</P>
<P>If you thought that option 3 was legal with a parameter argument
of <I>void</I> you may have to empty some of the C/C++ out of your
head.<BR>Option 4) is not legal because method return type must come
immediatly before the method name.</P>
<HR>
<P ALIGN=CENTER STYLE="margin-bottom: 0in"><B>Other sources on this
topic</B> 
</P>
<TABLE WIDTH=100% BORDER=1 CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD>
			<P><B>This topic is covered in the Sun Tutorial at</B><BR><B>Class
			modifiers</B><BR><A HREF="http://java.sun.com/docs/books/tutorial/reflect/class/getModifiers.html">http://java.sun.com/docs/books/tutorial/reflect/class/getModifiers.html</A><BR><B>Controlling
			access to members of a
			class</B><BR><A HREF="http://java.sun.com/docs/books/tutorial/java/javaOO/accesscontrol.html">http://java.sun.com/docs/books/tutorial/java/javaOO/accesscontrol.html<BR><BR></A><B>Richard
			Baldwin Covers this topic
			at</B><BR><A HREF="http://www.Geocities.com/Athens/Acropolis/3797/Java040.htm">http://www.Geocities.com/Athens/Acropolis/3797/Java040.htm<BR><BR></A><B>Jyothi
			Krishnan on this topic at
			<BR></B><A HREF="http://www.geocities.com/SiliconValley/Network/3693/obj_sec1.html#obj2">http://www.geocities.com/SiliconValley/Network/3693/obj_sec1.html#obj2<BR><BR></A><B>Bruce
			Eckel Thinking in
			Java<BR></B><A HREF="http://codeguru.earthweb.com/java/tij/tij0056.shtml">http://codeguru.earthweb.com/java/tij/tij0056.shtml</A></P>
		</TD>
	</TR>
</TABLE>
<P>Last updated<BR>30 October 2001<BR>copyright &copy; Marcus Green
2001<BR>most recent copy at http://www.jchq.net 
</P>
<p> End of document </p>
</BODY>
</HTML>

