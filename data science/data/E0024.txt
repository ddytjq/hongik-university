ID=E0024
URL=http://www.linuxdoc.org/HOWTO/C++Programming-HOWTO-17.html
SIZE=44544
DATE=12/07/02
TIME=19:16:29
DATASET=C
HTML=<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>C++ Programming HOW-TO: STL References </TITLE>
 <LINK HREF="C++Programming-HOWTO-18.html" REL=next>
 <LINK HREF="C++Programming-HOWTO-16.html" REL=previous>
 <LINK HREF="C++Programming-HOWTO.html#toc17" REL=contents>
</HEAD>
<BODY>
<A HREF="C++Programming-HOWTO-18.html">Next</A>
<A HREF="C++Programming-HOWTO-16.html">Previous</A>
<A HREF="C++Programming-HOWTO.html#toc17">Contents</A>
<HR>
<H2><A NAME="stlref"></A> <A NAME="s17">17. STL References </A></H2>

<P>Please visit the following sites for STL:
<UL>
<LI> Very good introduction to iterators
<A HREF="http://www.cs.trinity.edu/~joldham/1321/lectures/iterators/">http://www.cs.trinity.edu/~joldham/1321/lectures/iterators/</A></LI>
<LI> Introduction to STL SGI
<A HREF="http://www.sgi.com/tech/stl/stl_introduction.html">http://www.sgi.com/tech/stl/stl_introduction.html</A></LI>
<LI> Mumits STL Newbie guide (a bit outdated)
<A HREF="http://www.xraylith.wisc.edu/~khan/software/stl/STL.newbie.html">http://www.xraylith.wisc.edu/~khan/software/stl/STL.newbie.html</A></LI>
<LI> ObjectSpace examples: ObjectSpace has contributed over 300 examples to the public domain and these are a very good start for beginners. 
<A HREF="ftp://butler.hpl.hp.com/stl/examples.zip">ftp://butler.hpl.hp.com/stl/examples.zip</A></LI>
<LI> Joseph Y. Laurino's STL page. 
<A HREF="http://weber.u.washington.edu/~bytewave/bytewave_stl.html">http://weber.u.washington.edu/~bytewave/bytewave_stl.html</A></LI>
<LI> Marian Corcoran's STL FAQ. 
<A HREF="ftp://butler.hpl.hp.com/stl/stl.faq">ftp://butler.hpl.hp.com/stl/stl.faq</A></LI>
</UL>
<P>STL tutorials:
<UL>
<LI> Phil Ottewell's STL Tutorial - 
<A HREF="http://www.yrl.co.uk/~phil/stl/stl.htmlx">http://www.yrl.co.uk/~phil/stl/stl.htmlx</A></LI>
<LI> Good, but outdated doc - 
<A HREF="http://www.decompile.com/html/tut.html">http://www.decompile.com/html/tut.html</A>
Mirror: 
<A HREF="http://mip.ups-tlse.fr/~grundman/stl-tutorial/tutorial.html">http://mip.ups-tlse.fr/~grundman/stl-tutorial/tutorial.html</A></LI>
<LI> The Code Project, introduction to C++/STL/MFC 
<A HREF="http://www.codeproject.com/cpp/stlintroduction.asp">http://www.codeproject.com/cpp/stlintroduction.asp</A></LI>
<LI> C++ Standard Template Library, another great tutorial, by Mark Sebern
<A HREF="http://www.msoe.edu/eecs/cese/resources/stl/index.htm">http://www.msoe.edu/eecs/cese/resources/stl/index.htm</A></LI>
<LI> Technical University Vienna by Johannes Weidl 
<A HREF="http://dnaugler.cs.semo.edu/tutorials/stl">http://dnaugler.cs.semo.edu/tutorials/stl</A>
mirror 
<A HREF="http://www.infosys.tuwien.ac.at/Research/Component/tutorial/prwmain.htm">http://www.infosys.tuwien.ac.at/Research/Component/tutorial/prwmain.htm</A></LI>
</UL>
<P>Main STL sites:
<UL>
<LI>C++ STL from SGI 
<A HREF="http://www.sgi.com/tech/stl">http://www.sgi.com/tech/stl</A></LI>
<LI>C++ STL from RPI univ 
<A HREF="http://www.cs.rpi.edu/projects/STL/htdocs/stl.html">http://www.cs.rpi.edu/projects/STL/htdocs/stl.html</A></LI>
<LI>C++ STL site 
<A HREF="http://dmoz.org/Computers/Programming/Languages/C++/Class_Libraries/STL">ODP for STL</A>
and the
<A HREF="http://dir.lycos.com/Computers/Programming/Languages/C%2B%2B/Class_Libraries/STL">mirrorsite</A></LI>
<LI>STL for C++ Programmers 
<A HREF="http://userwww.econ.hvu.nl/~ammeraal/stlcpp.html">http://userwww.econ.hvu.nl/~ammeraal/stlcpp.html</A></LI>
<LI>C++ STL from halper 
<A HREF="http://www.halpernwightsoftware.com/stdlib-scratch/quickref.html">http://www.halpernwightsoftware.com/stdlib-scratch/quickref.html</A></LI>
</UL>
<P>
<P>
<H2><A NAME="ss17.1">17.1 Overview of the STL </A>
</H2>

<P>The STL offers the programmer a number of useful data structures and
algorithms. It is made up by the following components. 
<P>
<UL>
<LI>      Containers. There are two types: 
<UL>
<LI> Sequential. This group comprises the vector, list and deque types. </LI>
<LI> Sorted Associative. This group comprises the set, map, multiset and multimap types. </LI>
</UL>

<P>
</LI>
<LI> Iterators. These are pointer like objects that allow the user to step through the contents of a container. 
<P>
</LI>
<LI> Generic Algorithms. The STL provides a wide range of efficently implemented standard algorithms (for example find, sort
and merge) that work with the container types. (Some of the containers have special purpose implementations of these
algorithms as member functions.) 
<P>
</LI>
<LI> Function Objects. A function object is an instance of a class that provides a definition of operator(). This means that you can
use such an object like a function. 
<P>
</LI>
<LI> Adaptors. The STL provides 
<UL>
<LI> Container adaptors that allow the user to use, say, a vector as the basis of a stack. </LI>
<LI> Function adaptors that allow the user to construct new function objects from existing function objects. </LI>
</UL>

<P>
</LI>
<LI> Allocators. Every STL container class uses an Allocator class to hold information about the memory model the program is
using. I shall totally ignore this aspect of the STL. </LI>
</UL>
<P>I will be considering the use of the vector, list, set and map containers.
To make use of these containers you have to be able to use iterators so I
shall have something to say about STL iterators. Using the set and map
containers can mean having to supply a simple function object to the
instantiation so I shall also have something to say about function objects.
I will only briefly mention the algorithms supplied by the STL. I will not
mention adaptors at all. 
<P>I have taken liberty with some of the types of function arguments -- for
example most of the integer arguments referred to in what follows actually
have type size_type which is typedef'ed to an appropriate basic type
depending on the allocation model being used. If you want to see the true
signatures of the various functions discussed have a look at the Working
Paper or the header files. 
<P>There are a number of utility classes supplied with the STL. The only one of
importance to us is the pair class. This has the following definition: 
<P>
<HR>
<PRE>
template&lt;class T1, class T2>
class pair {
public:
    T1 first;
    T2 second;
    pair(const T1&amp; a, const T2&amp; b) : first(a), second(b) {}

};
</PRE>
<HR>
<P>and there is a convenient function make_pair with signature: 
<P>
<HR>
<PRE>
pair&lt;T1,T2> make_pair(const T1&amp; f, const T2&amp;,s)
</PRE>
<HR>
<P>as well as implementations of operator== and operator &lt; . There is nothing
complicated about this template class and you should be able to use it
without further guidance. To use it #include the header file
&lt;utility&gt;. It crops up in a number of places but particularly when
using the set and map classes.
<H2><A NAME="ss17.2">17.2 Header Files</A>
</H2>

<P>To use the various bits of the STL you have to #include the appropriate
header files. If your compiler is not standard compliant, this may differ,
but a standard compliant compiler (like g++), would have these:
<P>
<UL>
<LI> &lt;<I>vector</I>&gt; for the vector type. </LI>
<LI> &lt;<I>list</I>&gt; for the list type. </LI>
<LI> &lt;<I>set</I>&gt; for the set type. </LI>
<LI> &lt;<I>map</I>&gt; for the map type. </LI>
<LI> &lt;<I>algorithm</I>&gt; for access to the generic algorithms. </LI>
</UL>
<P>Note that headers in the Standard C++ Library are without a <B>.h</B>
suffix. If you use an old or poor compiler, the above headers might fail, if
then, you can try the version with the <B>.h</B> suffix, or better yet;
get another compiler.
<P>
<P>
<H2><A NAME="ss17.3">17.3 The Container Classes Interface </A>
</H2>

<P>The container classes have many member functions that have the same names.
These functions provide the same (or very similar) interface for each of
the classes (though, of course, the implementations will be different). The
following table lists the functions that we shall consider in more detail. A
star opposite a function name indicates that the container type heading the
column provides a member function of that name. 
<P>
<CENTER><TABLE BORDER><TR><TD>
<BR>
Operation </TD><TD>Purpose </TD><TD>vector </TD><TD>list </TD><TD>set </TD><TD>map </TD></TR><TR><TD>
== </TD><TD>comparison </TD><TD>* </TD><TD>*</TD><TD>*</TD><TD>*</TD></TR><TR><TD>
&lt;</TD><TD> comparison</TD><TD> *</TD><TD> *</TD><TD> *</TD><TD> *</TD></TR><TR><TD>
begin</TD><TD> iterator</TD><TD> *</TD><TD> *</TD><TD> *</TD><TD> *</TD><TD></TD></TR><TR><TD>
end</TD><TD> iterator</TD><TD> *</TD><TD> *</TD><TD> *</TD><TD> *</TD></TR><TR><TD>
size</TD><TD> no. of elements</TD><TD> *</TD><TD> *</TD><TD> *</TD><TD> *</TD></TR><TR><TD>
empty</TD><TD> is container empty</TD><TD> *</TD><TD> *</TD><TD> *</TD><TD> *</TD></TR><TR><TD>
front</TD><TD> first element</TD><TD> *</TD><TD> *</TD><TD>&nbsp; </TD><TD>&nbsp; </TD></TR><TR><TD>
back</TD><TD> last element</TD><TD> *</TD><TD> *</TD><TD>&nbsp; </TD><TD>&nbsp; </TD></TR><TR><TD>
[ ] </TD><TD> element access/modification</TD><TD> *</TD><TD>&nbsp; </TD><TD>&nbsp; </TD><TD>*</TD><TD></TD></TR><TR><TD>
insert</TD><TD> insert element(s)</TD><TD> *</TD><TD> *</TD><TD> *</TD><TD> *</TD></TR><TR><TD>
push_back</TD><TD> insert new last element</TD><TD> *</TD><TD> *</TD><TD>&nbsp; </TD><TD>&nbsp; </TD></TR><TR><TD>
push_front</TD><TD> insert new first element</TD><TD>&nbsp; </TD><TD>* </TD><TD>&nbsp;</TD><TD>&nbsp; </TD></TR><TR><TD>
erase</TD><TD> remove element(s)</TD><TD> *</TD><TD> *</TD><TD> *</TD><TD> *</TD></TR><TR><TD>
pop_back</TD><TD> remove last element</TD><TD> *</TD><TD> *</TD><TD>&nbsp; </TD><TD>&nbsp; </TD></TR><TR><TD>
pop_front</TD><TD> remove first element</TD><TD>&nbsp; </TD><TD>*</TD><TD>&nbsp;</TD><TD>&nbsp; </TD></TR><TR><TD>

<CAPTION><B>Container Class Interface</B></CAPTION>
</TD></TR></TABLE></CENTER>
<P>
<P>If the following discussion leaves something unclear 
(and it will) you can always write a small test program to investigate how
some function or feature behaves. 
<P>
<P>
<H2><A NAME="ss17.4">17.4 Vectors </A>
</H2>

<P>A vector is an array like container that improves on the C++ array type. In
particular it is not necessary to know how big you want the vector to be
when you declare it, you can add new elements to the end of a vector using
the <B><I>push_back</I></B> function. (In fact the
<B><I>insert</I></B> function allows you to insert new elements at any
position of the vector, but this is a very inefficient operation -- if you
need to do this often consider using a list instead). 
<P>
<P>
<H3>Constructing Vectors </H3>

<P><I>vector</I> is a class template so that when declaring a vector object you have to state the type of the objects the vector is to contain. For
example the following code fragment 
<P>
<HR>
<PRE>
vector&lt;int> v1;
vector&lt;string> v2;
vector&lt;FiniteAutomaton> v3;
</PRE>
<HR>
<P>declares that v1 is a vector that holds integers, v2 a vector that holds
strings and v3 holds objects of type FiniteAutomaton (presumably an user
defined class type). These declarations do not say anything about how large
the vectors are to be (implementations will use a default starting size) and
you can grow them to as large as you require. 
<P>You can give an initial size to a vector by using a declaration like 
<P>
<HR>
<PRE>
vector&lt;char> v4(26);
</PRE>
<HR>
<P>which says that v4 is to be vector of characters that initially has room for
26 characters. There is also a way to initialise a vector's elements. The
declaration 
<P>
<HR>
<PRE>
vector&lt;float> v5(100,1.0);
</PRE>
<HR>
<P>says that <I>v5</I> is a vector of 100 floating point numbers each of
which has been initialised to 1.0.
<P>
<P>
<H3>Checking Up on Your Vector </H3>

<P>Once you have created a vector you can find out the current number of
elements it contains by using the <I>size</I> function. This function
takes no arguments and returns an integer (strictly a value of type
<I>size_type</I>, but this gets converted to an integer) which says how
many elements there are in the vector. What will be printed out by the
following small program? 
<P>
<HR>
<PRE>
&lt;vector-size.cpp>=
#include &lt;iostream>
#include &lt;vector>

using namespace std;

int main()
{
    vector&lt;int> v1;
    vector&lt;int> v2(10);
    vector&lt;int> v3(10,7);

    cout &lt;&lt; "v1.size() returns " &lt;&lt; v1.size() &lt;&lt; endl;
    cout &lt;&lt; "v2.size() returns " &lt;&lt; v2.size() &lt;&lt; endl;
    cout &lt;&lt; "v3.size() returns " &lt;&lt; v3.size() &lt;&lt; endl;
}
</PRE>
<HR>
<P>To check on whether your vector is empty or not you can use the empty
function. This takes no arguments and returns a boolean value, true if the
vector is empty, false if it is not empty. What will be printed out by the
following small program (true prints as 1 and false prints as 0)? 
<P>
<HR>
<PRE>
&lt;vector-empty.cpp>=
#include &lt;iostream>
#include &lt;vector>

using namespace std;

int main()
{
    vector&lt;int> v1;
    vector&lt;int> v2(10);
    vector&lt;int> v3(10,7);

    cout &lt;&lt; "v1.empty() has value " &lt;&lt; v1.empty() &lt;&lt; endl;
    cout &lt;&lt; "v2.empty() has value " &lt;&lt; v2.empty() &lt;&lt; endl;
    cout &lt;&lt; "v3.empty() has value " &lt;&lt; v3.empty() &lt;&lt; endl;
}
</PRE>
<HR>
<P>
<P>
<H3>Accessing Elements of a Vector </H3>

<P>You can access a vector's elements using operator[]. Thus, if you wanted to print out all the elements in a vector you could use code
like 
<P>
<HR>
<PRE>
vector&lt;int> v;
// ...
for (int i=0; i&lt;v.size(); i++)
     cout &lt;&lt; v[i];
</PRE>
<HR>
<P>(which is very similar to what you might write for a built-in array). 
<P>You can also use operator[] to set the values of the elements of a vector. 
<P>
<HR>
<PRE>
vector&lt;int> v;
// ...
for (int i=0; i&lt;v.size(); i++)
      v[i] = 2*i;
</PRE>
<HR>
<P>The function front gives access to the first element of the vector. 
<P>
<HR>
<PRE>
vector&lt;char> v(10,'a');
// ...
char ch = v.front();
</PRE>
<HR>
<P>You can also change the first element using front. 
<P>
<HR>
<PRE>
vector&lt;char> v(10,'a');
// ...
v.front() = 'b';
</PRE>
<HR>
<P>The function back works the same as front but for the last element of the vector. 
<P>
<HR>
<PRE>
vector&lt;char> v(10,'z');
// ...
char last = v.back();
v.back() = 'a';
</PRE>
<HR>
<P>Here is a simple example of the use of []. 
<P>
<HR>
<PRE>
&lt;vector-access.cpp>=
#include &lt;vector>
#include &lt;iostream>

using namespace std;

int main()
{
    vector&lt;int> v1(5);
    int x;
    cout &lt;&lt; "Enter 5 integers (separated by spaces):" &lt;&lt; endl;
    for (int i=0; i&lt;5; i++)
          cin >> v1[i];
    cout &lt;&lt; "You entered:" &lt;&lt; endl;
    for (int i=0; i&lt;5; i++)
          cout &lt;&lt; v1[i] &lt;&lt; ' ';
    cout &lt;&lt; endl;
}
</PRE>
<HR>
<P>
<P>
<H3>Inserting and Erasing Vector Elements </H3>

<P>Along with operator[] as described above there are a number of other ways to change or access the elements in a vector. 
<P>
<UL>
<LI>push_back will add a new element to the end of a vector. </LI>
<LI>pop_back will remove the last element of a vector. </LI>
<LI>insert will insert one or more new elements, at a designated position, in the vector. </LI>
<LI>erase will remove one or more elements from a vector between designated positions. </LI>
</UL>
<P>Note that insert and erase are expensive operations on vectors. If you use them a lot then you should consider using the list data
structure for which they are more efficient. 
<P>
<HR>
<PRE>
&lt;vector-mod.cpp>=
#include &lt;iostream>
#include &lt;vector>

using namespace std;

int main()
{
    vector&lt;int> v;

    for (int i=0; i&lt;10; i++) v.push_back(i);
    cout &lt;&lt; "Vector initialised to:" &lt;&lt; endl;
    for (int i=0; i&lt;10; i++) cout &lt;&lt; v[i] &lt;&lt; ' ' ;
    cout &lt;&lt; endl;

    for (int i=0; i&lt;3; i++) v.pop_back();
    cout &lt;&lt; "Vector length now: " &lt;&lt; v.size() &lt;&lt; endl;
    cout &lt;&lt; "It contains:" &lt;&lt; endl;
    for (int i=0; i&lt;v.size(); i++) cout &lt;&lt; v[i] &lt;&lt; ' ';
    cout &lt;&lt; endl;

    int a1[5];
    for (int i=0; i&lt;5; i++) a1[i] = 100;

    v.insert(&amp; v[3], &amp; a1[0],&amp; a1[3]);
    cout &lt;&lt; "Vector now contains:" &lt;&lt; endl;
    for (int i=0; i&lt;v.size(); i++) cout &lt;&lt; v[i] &lt;&lt; ' ';
    cout &lt;&lt; endl;

    v.erase(&amp; v[4],&amp; v[7]);
    cout &lt;&lt; "Vector now contains:" &lt;&lt; endl;
    for (int i=0; i&lt;v.size(); i++) cout &lt;&lt; v[i] &lt;&lt; ' ';
    cout &lt;&lt; endl;
}
</PRE>
<HR>
<P>In the above a vector v has been declared then initialised using push_back.
Then some elements have been trimmed off it's end using pop_back. Next an
ordinary integer array has been created and then some of its elements
inserted into v using insert. Finally erase has been used to remove elements
from v. The functions used above take arguments as follows. 
<P>
<UL>
<LI>      push_back takes a single argument of the type of the elements held in the vector. </LI>
<LI>      pop_back takes no arguments. It is a mistake to use pop_back on an empty vector. </LI>
<LI>      insert has three forms: 
<UL>
<LI>insert(pos, T&amp; x) which will insert the single element x at position pos in the vector. </LI>
<LI>insert(pos, start, end) which inserts a sequence of elements from some other container at position pos in the vector. The</LI>
<LI>sequence of elements is identified as starting at the start element and continuing to, but not including, the end element. </LI>
<LI>insert(pos, int rep, T&amp; x) inserts rep copies of x at position pos in the vector. </LI>
</UL>
</LI>
</UL>

As indicated in the code above the position pos should be the address of the element to insert at, whilst the start and end
arguments are likewise also addresses. (The true story is that they are iterators -- see next subsection and following
section). 
<UL>
<LI> erase has two forms (pos, start and end have the same types as for the insert function): 
<UL>
<LI> erase(pos) which will remove the element at position pos in the vector. </LI>
<LI> insert(start,end) which will remove elements starting at position start up to, but not including, the element at position end.</LI>
</UL>
</LI>
</UL>
<P>
<P>
<P>
<H3>Vector Iterators </H3>

<P>
<P>The simple way to step through the elements of a vector v is as we have done above: 
<P>
<HR>
<PRE>
for (int i=0; i&lt;v.size(); i++) { ... v[i] ... }
</PRE>
<HR>
<P>Another way is to use iterators. An iterator can be thought of as a pointer into the container, incrementing the iterator allows you
to step through the container. For container types other than vectors iterators are the only way to step through the container. 
<P>For a vector containing elements of type T: 
<P>
<HR>
<PRE>
vector&lt;T> v;
</PRE>
<HR>
<P>an iterator is declared as follows: 
<P>
<HR>
<PRE>
vector&lt;T>::iterator i;
</PRE>
<HR>
<P>Such iterators are constructed and returned by the functions begin() and end(). You can compare two iterators (of the same type)
using == and !=, increment using ++ and dereference using *. [In fact vector iterators allow more operations on them - see next
section for more information]. 
<P>Here is an illustration of how to use iterators with vectors. 
<P>
<HR>
<PRE>
&lt;vector-iterator.cpp>=
#include &lt;iostream>
#include &lt;vector>

using namespace std;

int main()
{
    vector&lt;int> v(10);
    // first is ``less'' than the second

    int j = 1;

    vector&lt;int>::iterator i;

    // Fill the vector v with integers 1 to 10.
    i = v.begin();
    while (i != v.end())
    {
        *i = j;
        j++;
        i++;
    }

    // Square each element of v.
    for (i=v.begin(); i!=v.end(); i++) *i = (*i) * (*i);

    // Print out the vector v.
    cout &lt;&lt; "The vector v contains: ";
    for (i=v.begin(); i!=v.end(); i++) cout &lt;&lt; *i &lt;&lt; ' ';
    cout &lt;&lt; endl;

}
</PRE>
<HR>
<P>Note how *i can be used on the left-hand side of an assignment statement so as to update the element pointed at by i, and on the
right-hand side to access the current value. 
<P>
<P>
<H3>Comparing Vectors </H3>

<P>You can compare two vectors using == and &lt;. == will return true only if both vectors have the same number of elements and all
elements are equal. The &lt; functions performs a lexicographic comparison of the two vectors. This works by comparing the vectors
element by element. Suppose we are comparing v1 and v2 (that is 
v1 &lt; v2?). Set i=0. If v1[i] &lt; v2[i] then return true, if v1[i] &gt; v2[i] then
return false, otherwise increment i (that is move on to the next element). If the end of v1 is reached before v2 return true, otherwise
return false. Lexicographic order is also known as dictionary order. Some examples: 
<P>
<HR>
<PRE>
(1,2,3,4) &lt; (5,6,7,8,9,10) is true.
(1,2,3) &lt; (1,2,3,4) is true
(1,2,3,4) &lt; (1,2,3) is false
(0,1,2,3) &lt; (1,2,3) is true
</PRE>
<HR>
<P>The following code illustrates the third example above. 
<P>
<HR>
<PRE>
&lt;vector-comp.cpp>=
#include &lt;vector>
#include &lt;iostream>

using namespace std;

int main()
{
    vector&lt;int> v1;
    vector&lt;int> v2;
    for (int i=0; i&lt;4; i++) v1.push_back(i+1);
    for (int i=0; i&lt;3; i++) v2.push_back(i+1);

    cout &lt;&lt; "v1: ";
    for (int i=0; i&lt;v1.size(); i++) cout &lt;&lt; v1[i] &lt;&lt; ' ';
    cout &lt;&lt; endl;

    cout &lt;&lt; "v2: ";
    for (int i=0; i&lt;v2.size(); i++) cout &lt;&lt; v2[i] &lt;&lt; ' ';
    cout &lt;&lt; endl;

    cout &lt;&lt; "v1 &lt; v2 is: " &lt;&lt; (v1&lt;v2 ? "true" : "false") &lt;&lt; endl;
}
</PRE>
<HR>

The comparison operators &lt;= and >= also work. 
<P>
<P>
<H2><A NAME="ss17.5">17.5 Iterators and the STL</A>
</H2>

<P>See the section 
<A HREF="#stlref">STL References</A><P>
<P>
<H2><A NAME="ss17.6">17.6 Lists</A>
</H2>

<P>See the section 
<A HREF="#stlref">STL References</A><P>
<P>
<H2><A NAME="ss17.7">17.7 Sets </A>
</H2>

<P>The set container type allows an user to store and retrieve elements directly rather than through an index into the container. The set container acts as a mathematical set in that it holds
only distinct elements. However unlike a mathematical set, elements in a set
container are held in (an user-supplied) order. In practice this is only a minor restriction on treating a set
container as an implementation of the mathematical set abstract data type,
and it allows for a much more efficient implementation than an unordered approach.
<P>
<P>
<P>
<H3>Constructing Sets</H3>

<P>Two template arguments are required to construct a set container -- the type of the objects the set is to contain and a function object that can compare two elements of the given type,
that is: 
<P>
<HR>
<PRE>
set&lt;T, Compare> s;
</PRE>
<HR>
<P>(The declaration <I>set &lt; T &gt; s</I> should also be possible -- it would 
use a default template argument less &lt; T &gt; as the second argument, but
many C++ compilers (including g++) cannot as
yet cope with default template arguments.) 
<P>For simple types <B>T</B> we can use the function object <I>less &lt; T &gt; </I> (
without having to worry about what a ``function object'' is), for example all the following are legal set declarations. 
<P>
<HR>
<PRE>
set&lt;int, less&lt;int> > s1;
set&lt;double, less&lt;double> > s2;
set&lt;char, less&lt;char> > s3;
set&lt;string, less&lt;string> > s4;
</PRE>
<HR>
<P>(Note that the space between the two final >'s in the template is required - otherwise the compiler will interpret >> as the right shift operator.) In each of these cases the function
object makes use of the operator &lt; as defined for the the underlying type (that is 
<I>int, double, char</I> and <I>string</I>). 
<P>The following code declares a set of integers, then adds some integers to 
the set using the <I>insert</I> method and then prints out the set 
members by iterating through the set. You will
note that the set's contents are printed out in ascending order even though they were added in no particular order. 
<P>
<HR>
<PRE>
&lt;set-construct1.cpp>=
#include &lt;iostream>
#include &lt;set>

using namespace std;

int main()
{
    set&lt;int, less&lt;int> > s;
    set&lt;int, less&lt;int> >::iterator i;

    s.insert(4);
    s.insert(0);
    s.insert(-9);
    s.insert(7);
    s.insert(-2);
    s.insert(4);
    s.insert(2);

    cout &lt;&lt; "The set contains the elements: ";
    for (i=s.begin(); i!=s.end(); i++) cout &lt;&lt; *i &lt;&lt; ' ';
    cout &lt;&lt; endl;
}
</PRE>
<HR>
<P>Note that 4 is added twice but only turns up once on the list of elements -- which is what one expects of a set. 
<P>
<P>
<H3>What are Function Objects?</H3>

<P>
<P>One of the nifty features of C++ is the ability to overload operators, so that one can have + mean whatever one likes for your newly designed class. One of the operators C++ allows
you to overload is the function call operator () and this allows you to create classes whose instances can behave like functions in many ways. These are function objects. 
<P>Here is a simple example. 
<P>
<HR>
<PRE>
&lt;function-object.cpp>=
#include &lt;iostream>

using namespace std;

template&lt;class T>
class square {
public:
    T operator()(T x) { return x*x; }
};
// This can be used with any T for which * is defined.

int main()
{
    // Create some function objects.
    square&lt;double> f1;
    square&lt;int> f2;

    // Use them.
    cout &lt;&lt; "5.1^2 = " &lt;&lt; f1(5.1) &lt;&lt; endl;
    cout &lt;&lt; "100^2 = " &lt;&lt; f2(100) &lt;&lt; endl;

    // The following would result in a compile time error.
    // cout &lt;&lt; "100.1^2 = " &lt;&lt; f2(100.1) &lt;&lt; endl;
}
</PRE>
<HR>
<P>Function objects are used in a number of places in the STL. In particular they are used when declaring sets and maps. 
<P>The function object required for these purposes, let's suppose it is 
called <I>comp</I>, must satisfy the following requirements. 
<P>
<OL>
<LI> If comp(x,y) and comp(y,z) are true for objects x, y and z then comp(x,z) is also true. </LI>
<LI> comp(x,x) is false for every object x. </LI>
</OL>
<P>If for any particular objects x and y, both comp(x,y) and comp(y,x) are false then x and y are deemed to be equal. 
<P>This, in fact, is just the behaviour of the <I>strictly-less-than</I> 
relation (ie &lt; ) on numbers. The function object less &lt; T &gt; used above is 
defined in terms of a &lt; operator for the type T. It's
definition can be thought of as follows. 
<P>
<HR>
<PRE>
template&lt;class T>
struct less {
  bool operator()(T x, T y) { return x&lt;y; }
}
</PRE>
<HR>
<P>(The actual definition uses references, has appropriate const annotations and inherits from a template class binary_function.) 
<P>This means that if the type T has operator &lt; defined for it then you can use 
less &lt; T &gt; as the comparator when declaring sets of T. You might still want to use a special purpose
comparator if the supplied &lt; operator is not appropriate for 
your purposes. Here is another example. This defines a simple 
class with a definition of operator &lt; and a function object
that performs a different comparison. Note that the overloaded &lt; 
and () operators should be given const annotations so that the functions 
work correctly with the STL. 
<P>
<HR>
<PRE>
&lt;set-construct2.cpp>=
#include &lt;iostream>
#include &lt;set>

using namespace std;

// This class has two data members. The overloaded operator&lt; compares
// such classes on the basis of the member f1.
class myClass {
private:
    int f1;
    char f2;
public:
    myClass(int a, char b) : f1(a), f2(b) {}
    int field1() const { return f1; }
    char field2() const { return f2; }
    bool operator&lt;(myClass y) const
    { return (f1&lt;y.field1()); }
};

// This function object compares objects of type myClass on the basis
// of the data member f2.
class comp_myClass {
public:
    bool operator()(myClass c1, myClass c2) const
    { return (c1.field2() &lt; c2.field2()); }
};

int main()
{
    set&lt;myClass, less&lt;myClass> > s1;
    set&lt;myClass, less&lt;myClass> >::iterator i;
    set&lt;myClass, comp_myClass> s2;
    set&lt;myClass, comp_myClass>::iterator j;

    s1.insert(myClass(1,'a'));
    s2.insert(myClass(1,'a'));
    s1.insert(myClass(1,'b'));
    s2.insert(myClass(1,'b'));
    s1.insert(myClass(2,'a'));
    s2.insert(myClass(2,'a'));

    cout &lt;&lt; "Set s1 contains: ";
    for (i=s1.begin(); i!=s1.end(); i++)
    { 
        cout &lt;&lt; "(" &lt;&lt; (*i).field1() &lt;&lt; "," 
                &lt;&lt; (*i).field2() &lt;&lt; ")" &lt;&lt; ' ';
    }
    cout &lt;&lt; endl;

    cout &lt;&lt; "Set s2 contains: ";
    for (j=s2.begin(); j!=s2.end(); j++)
    {
        cout &lt;&lt; "(" &lt;&lt; (*j).field1() &lt;&lt; "," 
                &lt;&lt; (*j).field2() &lt;&lt; ")" &lt;&lt; ' ';
    }
    cout &lt;&lt; endl;
}
</PRE>
<HR>
<P>The set s1 contains (1,a) and (2,a) as comparison is on the data member f1, so that (1,a) and (1,b) are deemed the same element. The set s2 contains (1,a) and (1,b) as
comparison is on the data member f2, so that (1,a) and (2,a) are deemed the same element. 
<P>
<P>
<H3>A Printing Utility</H3>

<P>The way we have printed out the sets in the previous examples is a little awkward so the following header file containing a simple overloaded version 
of <I>operator&lt;&lt; </I> has been written.
It works fine for small sets with simple element types. 
<P>
<HR>
<PRE>
&lt;printset.h>=
#ifndef _PRINTSET_H
#define _PRINTSET_H

#include &lt;iostream>
#include &lt;set>

template&lt;class T, class Comp>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const std::set&lt;T,Comp>&amp; s)
{
    std::set&lt;T,Comp>::iterator iter = s.begin();
    int sz = s.size();
    int cnt = 0;

    os &lt;&lt; "{";
    while (cnt &lt; sz-1)
    {
        os &lt;&lt; *iter &lt;&lt; ",";
        iter++;
        cnt++;
    }
    if (sz != 0) os &lt;&lt; *iter;
    os &lt;&lt; "}";

    return os;
}
#endif
</PRE>
<HR>
<P>The use here of &lt;&lt; as an output routine for a set assumes that &lt;&lt; has been defined for the set elements, and uses this to print a comma delimited list of the set elements wrapped in
curly braces. It will be used without comment in the following examples. 
<P>
<P>
<H3>How Many Elements?</H3>

<P>
<P>You can determine if a set is empty or not by using the empty() method. You can find out how many elements there are in a set by using the size() method. These methods take no
arguments, empty() returns true or false and size() returns an integer. 
<P>
<HR>
<PRE>
&lt;set-size.cpp>=
#include &lt;iostream>
#include &lt;set>
#include "printset.h"

using namespace std;

int main()
{
    set&lt;int, less&lt;int> > s;

    cout &lt;&lt; "The set s is  "
            &lt;&lt; (s.empty() ? "empty." : "non-empty.") &lt;&lt; endl; 
    cout &lt;&lt; "It has " &lt;&lt; s.size() &lt;&lt; "elements." &lt;&lt; endl;

    cout &lt;&lt; "Now adding some elements... " &lt;&lt; endl;

    s.insert(1);
    s.insert(6);
    s.insert(7);
    s.insert(-7);
    s.insert(5);
    s.insert(2);
    s.insert(1);
    s.insert(6);

    cout &lt;&lt; "The set s is now  
            &lt;&lt; (s.empty() ? "empty." : "non-empty.") &lt;&lt; endl;
    cout &lt;&lt; "It has " &lt;&lt; s.size() &lt;&lt; "elements." &lt;&lt; endl;
    cout &lt;&lt; "s = " &lt;&lt; s &lt;&lt; endl;
}
</PRE>
<HR>
<P>
<P>
<H3>Checking the Equality of Sets.</H3>

<P>Two sets may be checked for equality by using ==. This equality test works by testing in order the corresponding elements of each set for equality using T::operator==. 
<P>
<HR>
<PRE>
&lt;set-equality.cpp>=
#include &lt;iostream>
#include &lt;set>
#include "printset.h"

using namespace std;

int main()
{
    set&lt;int, less&lt;int> > s1, s2 ,s3;

    for (int i=0; i&lt;10; i++)
    {
        s1.insert(i);
        s2.insert(2*i);
        s3.insert(i);
    }

    cout &lt;&lt; "s1 = " &lt;&lt; s1 &lt;&lt; endl;
    cout &lt;&lt; "s2 = " &lt;&lt; s2 &lt;&lt; endl;
    cout &lt;&lt; "s3 = " &lt;&lt; s3 &lt;&lt; endl;
    cout &lt;&lt; "s1==s2 is: " &lt;&lt; (s1==s2 ? true. : false.) &lt;&lt; endl;
    cout &lt;&lt; "s1==s3 is: " &lt;&lt; (s1==s3 ? true. : false.) &lt;&lt; endl;
}
</PRE>
<HR>
<P>It is also possible to compare two sets using &lt;. The comparison s1 &lt; s2 is true if the set s1 is lexicographically less than the set s2, otherwise it is false. 
<P>
<P>
<H3>Adding and Deleting Elements</H3>

<P>The way to add elements to a set is to use the insert method (as we have done above). The way to delete elements from a set is to use the erase method. 
<P>For a set holding elements of type T these methods come in following forms: 
<UL>
<LI> <B>pair &lt; iterator, bool> insert(T&amp; x)</B>. This is the standard insert function. The return value may be ignored or used to test if the insertion succeeded (that is the element
was not already in the set). If the insertion succeeded the boolean component will be true and the iterator will point at the just inserted element. If the element is already
present the boolean component will be false and the iterator will point at the element x already present. 
<P>
</LI>
<LI> <B>iterator insert(iterator position, T&amp; x)</B>. This version of the insert function takes, in addition to the element to insert, an iterator stating where the insert function
should begin to search. The returned iterator points at the newly inserted element, (or the already present element). 
<P>
</LI>
<LI> <B>int erase(T&amp; x)</B>. This version of the erase method takes an element to delete and returns 1 if the element was present (and removes it) or 0 if the element was not present. 
<P>
</LI>
<LI> <B>void erase(iterator position)</B>. This version takes an iterator pointing at some element in the set and removes that element. 
<P>
</LI>
<LI> <B>void erase(iterator first, iterator last)</B>. This version takes two 
iterators pointing into the set and removes all the elements in the range [ first,last ] . </LI>
</UL>
<P>The following example illustrates these various forms. 
<P>
<HR>
<PRE>
&lt;set-add-delete.cpp>=
#include &lt;iostream>
#include &lt;set>
#include "printset.h"

using namespace std;

int main()
{
    set&lt;int, less&lt;int> > s1;

    // Insert elements in the standard fashion.
    s1.insert(1);
    s1.insert(2);
    s1.insert(-2);

    // Insert elements at particular positions.
    s1.insert(s1.end(), 3);
    s1.insert(s1.begin(), -3);
    s1.insert((s1.begin()++)++, 0);

    cout &lt;&lt; "s1 = " &lt;&lt; s1 &lt;&lt; endl;

    // Check to see if an insertion has been successful.
    pair&lt;set&lt;int, less&lt;int> >::iterator,bool> x = s1.insert(4);
    cout &lt;&lt; "Insertion of 4 " &lt;&lt; (x.second ? worked. : failed.) 
            &lt;&lt; endl;
    x = s1.insert(0);
    cout &lt;&lt; "Insertion of 0 " &lt;&lt; (x.second ? worked. : failed.) 
            &lt;&lt; endl;

    // The iterator returned by insert can be used as the position
    // component of the second form of insert.
    cout &lt;&lt; "Inserting 10, 8 and 7." &lt;&lt; endl;
    s1.insert(10);
    x=s1.insert(7);
    s1.insert(x.first, 8);

    cout &lt;&lt; "s1 = " &lt;&lt; s1 &lt;&lt; endl;

    // Attempt to remove some elements.
    cout &lt;&lt; "Removal of 0 " &lt;&lt; (s1.erase(0) ? worked. : failed.)
            &lt;&lt; endl;
    cout &lt;&lt; "Removal of 5 " &lt;&lt; (s1.erase(5) ? worked. : failed.)
            &lt;&lt; endl;

    // Locate an element, then remove it. (See below for find.)
    cout &lt;&lt; "Searching for 7." &lt;&lt; endl;
    set&lt;int,less&lt;int> >::iterator e = s1.find(7);
    cout &lt;&lt; "Removing 7." &lt;&lt; endl;
    s1.erase(e);

    cout &lt;&lt; "s1 = " &lt;&lt; s1 &lt;&lt; endl;

    // Finally erase everything from the set.
    cout &lt;&lt; "Removing all elements from s1." &lt;&lt; endl;
    s1.erase(s1.begin(), s1.end());
    cout &lt;&lt; "s1 = " &lt;&lt; s1 &lt;&lt; endl;
    cout &lt;&lt; "s1 is now " &lt;&lt; (s1.empty() ? empty. : non-empty.)
            &lt;&lt; endl;
}
</PRE>
<HR>
<P>
<P>
<H3>Finding Elements</H3>

<P>
<P>We mention two member functions that can be used to test if an element is present in a set or not. 
<P>
<UL>
<LI> <B>iterator find(T&amp; x)</B>. This searches for the element x in the set. If x is found it returns an iterator pointing at x otherwise it returns end(). </LI>
<LI> <B>int count(T&amp; x)</B>. This returns 1 if it finds x in the set and 0 otherwise. (The count function for multisets returns the number of copies of the element in the set which may be
more than 1. Hence, I guess, the name of the function.) </LI>
</UL>
<P>The use of find has been illustrated above. We could use count to write a simple template based set membership function. (This should also provide a version that takes a reference
to the argument x.) 
<P>
<HR>
<PRE>
&lt;setmember.h>=
#ifndef _SETMEMBER_H
#define _SETMEMBER_H
#include &lt;set>

template&lt;class T, class Comp>
bool member(T x, std::set&lt;T,Comp>&amp; s)
{
 return (s.count(x)==1 ? true : false);
}
#endif

Which might be used as follows. 

&lt;set-membership.cpp>=
#include &lt;iostream>
#include &lt;set>
#include "printset.h"
#include "setmember.h"

using namespace std;

int main()
{
    set&lt;int, less&lt;int> > s;
    for (int i= 0; i&lt;10; i++) s.insert(i);
    cout &lt;&lt; "s = " &lt;&lt; s &lt;&lt; endl;
    cout &lt;&lt; "1 is " &lt;&lt; (member(1,s) ?  : not) &lt;&lt; " a member of s "
            &lt;&lt;  endl;
    cout &lt;&lt; "10 is " &lt;&lt; (member(10,s) ?  : not) &lt;&lt; " a member of s "
            &lt;&lt;  endl;
}
</PRE>
<HR>
<P>
<P>
<P>
<H3>Set Theoretic Operations</H3>

<P>
<P>The STL supplies as generic algorithms the set operations includes, union, intersection, difference and symmetric difference. To gain access to these functions you need to include
algo.h. (In what follows iter stands for an appropriate iterator). 
<P>
<UL>
<LI> bool includes(iter f1,iter l1,iter f2,iter l2). 
<P>This checks to see if the set represented by the range [f2,l2] is included in the set [f1,l1]. It returns true if it is and false otherwise. So to check to see if one set is
included in another you would use 
<P>
<P>includes(s1.begin(), s1.end(), s2.begin(), s2.end())
<P>The includes function checks the truth of 3#3 ( that is of 4#4). This function assumes that the sets are ordered using the comparison operator &lt;. If some other comparison
operator has been used this needs to be passed to includes as an extra (function object) argument after the other arguments. 
<P>
</LI>
<LI> iter set_union(iter f1,iter l1,iter f2,iter l2,iter result). 
<P>This forms the union of the sets represented by the ranges [f1,l1] and [f2,l2]. The argument result is an output iterator that points at the start of the set that is going to
hold the union. The return value of the function is an output iterator that points at the end of the new set. 
</LI>
</UL>
<P>The fact that the result argument is an output iterator means that you cannot use set_union in the following, natural, fashion: 
<P>
<HR>
<PRE>
      set&lt;int, less&lt;int> > s1, s2, s3;
      // Add some elements to s1 and s2 ...
      // Then form their union. (This does not work!)
      set_union(s1.begin(), s1.end(), 
                s2.begin(), s2.end(), 
                s3.begin());
</PRE>
<HR>
<P>The reason is that begin() (also end()) when used with sets (or maps) returns a (constant) input iterator. This type of iterator allows you to access elements of the set for
reading but not writing. (And this is a Good Thing since if you could assign to a dereferenced iterator (as in (*i)= ...) then you could destroy the underlying order of the
set.) 
<P>The solution is to use an insert iterator based on the set type. This, basically, converts an assignment (*i)=value (which is illegal) into a (legal) insertion
s.insert(i,value) (where s is the set object that the iterator i is pointing into). It is used as follows: 
<P>
<HR>
<PRE>
      // Typedef for convenience.
      typedef set&lt;int, less&lt;int> > intSet;  
      intSet s1, s2, s3;
      // Add some elements to s1 and s2 ...
      // Then form their union. 
      set_union(s1.begin(), s1.end(), 
                s2.begin(), s2.end(), 
                insert_iterator&lt;intSet>(s3,s3.begin()) );
</PRE>
<HR>
<P>Here is an example illustrating all these operations. 
<P>
<HR>
<PRE>
&lt;set-theory.cpp>=
#include &lt;iostream>
#include &lt;set>
#include &lt;algorithm>
#include &lt;iterator>
#include "printset.h"

using namespace std;

int main()
{
    typedef set&lt;int, less&lt;int> > intSet;

    intSet s1, s2, s3, s4;

    for (int i=0; i&lt;10; i++)
    { s1.insert(i);
        s2.insert(i+4);
    }
    for (int i=0; i&lt;5; i++) s3.insert(i);

    cout &lt;&lt; "s1 = " &lt;&lt; s1 &lt;&lt; endl;
    cout &lt;&lt; "s2 = " &lt;&lt; s2 &lt;&lt; endl;
    cout &lt;&lt; "s3 = " &lt;&lt; s3 &lt;&lt; endl;

    // Is s1 a subset of s2?
    bool test = includes(s2.begin(),s2.end(),s1.begin(),s1.end());
    cout &lt;&lt; "s1 subset of s2 is " &lt;&lt; (test ? true. : false.) &lt;&lt; endl;

    // Is s3 a subset of s1?
    test = includes(s1.begin(),s1.end(),s3.begin(),s3.end());
    cout &lt;&lt; "s3 subset of s1 is " &lt;&lt; (test ? true. : false.) &lt;&lt; endl;

    // Form the union of s1 and s2.
    set_union(s1.begin(), s1.end(), s2.begin(), s2.end(),
            insert_iterator&lt;intSet>(s4,s4.begin()) );
    cout &lt;&lt; "s1 union s2 = " &lt;&lt; s4 &lt;&lt; endl;

    // Erase s4 and form intersection of s1 and s2. (If we don't erase
    // s4 then we will get the previous contents of s4 as well).
    s4.erase(s4.begin(),s4.end());
    set_intersection(s1.begin(), s1.end(), s2.begin(), s2.end(),
            insert_iterator&lt;intSet>(s4,s4.begin()) );
    cout &lt;&lt; "s1 intersection s2 = " &lt;&lt; s4 &lt;&lt; endl;

    // Now set difference.
    s4.erase(s4.begin(),s4.end());
    set_difference(s1.begin(), s1.end(), s2.begin(), s2.end(),
            insert_iterator&lt;intSet>(s4,s4.begin()) );
    cout &lt;&lt; "s1 minus s2 = " &lt;&lt; s4 &lt;&lt; endl;

    // Set difference is not symmetric.
    s4.erase(s4.begin(),s4.end());
    set_difference(s2.begin(), s2.end(), s1.begin(), s1.end(),
            insert_iterator&lt;intSet>(s4,s4.begin()) );
    cout &lt;&lt; "s2 minus s1 = " &lt;&lt; s4 &lt;&lt; endl;

    // Finally symmetric difference.
    s4.erase(s4.begin(),s4.end());
    set_symmetric_difference(s1.begin(), s1.end(), s2.begin(), s2.end(),
            insert_iterator&lt;intSet>(s4,s4.begin()) );
    cout &lt;&lt; "s1 symmetric_difference  s2 = " &lt;&lt; s4 &lt;&lt; endl;

    // Which is symmetric!
    s4.erase(s4.begin(),s4.end());
    set_symmetric_difference(s2.begin(), s2.end(), s1.begin(), s1.end(),
            insert_iterator&lt;intSet>(s4,s4.begin()) );
    cout &lt;&lt; "s2 symmetric_difference  s1 = " &lt;&lt; s4 &lt;&lt; endl;
}
</PRE>
<HR>
<P>
<P>
<H2><A NAME="ss17.8">17.8 Maps</A>
</H2>

<P>See the section 
<A HREF="#stlref">STL References</A><P>
<P>
<H2><A NAME="ss17.9">17.9 STL Algorithms</A>
</H2>

<P>See the section 
<A HREF="#stlref">STL References</A><P>
<P>
<P>
<HR>
<A HREF="C++Programming-HOWTO-18.html">Next</A>
<A HREF="C++Programming-HOWTO-16.html">Previous</A>
<A HREF="C++Programming-HOWTO.html#toc17">Contents</A>
</BODY>
</HTML>

