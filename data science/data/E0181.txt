ID=E0181
URL=http://www.rit.edu/~jpw9607/ctut/part3.htm
SIZE=36575
DATE=12/07/02
TIME=19:18:21
DATASET=C
HTML=<html><!-- #BeginTemplate "/Templates/main.dwt" -->
<head>
<!-- #BeginEditable "doctitle" --> 
<title>C/C++ Tutorial Page 3</title>
<!-- #EndEditable --> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" href="../style.css" type="text/css">
<meta name="keywords" content="DJGPP, Allegro, programming, JetFight, Project V2143, C++, tutorials, linklist, MSVC, Microsoft Visual C++, Itana, GNE, Deathworms, MUUDPIC, Java, links, games, libraries, source, code, C, network, multiplayer">
<meta name="description" content="Gillius's Programming.  C/C++ tutorials, games, java, allegro, and libraries.">
</head>
<body bgcolor="#000000" text="#FFFFFF" link="#FFFF00" vlink="#008080" alink="#990099">
<table width="100%" border="0" cellpadding="0" cellspacing="5">
  <tr> 
    <td colspan="2" class="titleBar">Gillius's Programming</td>
  </tr>
  <tr> 
    <td width="130" height="621" valign="top"> 
      <table border="0" cellpadding="3" cellspacing="0" name="NavBar" width="130">
        <tr> 
          <td valign="top" class="leftTitle">Sections</td>
        </tr>
        <tr> 
          <td valign="top" class="leftText"><a href="../index.htm">Home / News</a><br>
            <a href="../tutorial.htm">Tutorials</a><br>
            <a href="../games.htm">Games Corner</a><br>
            <a href="../java/index.htm">Java</a><br>
            <a href="../filesandprog.htm">The Archive</a><br>
            <a href="../links.htm">Links</a> </td>
        </tr>
        <tr> 
          <td valign="top" class="leftTitle"><a href="http://boards.eesite.com/board.cgi?boardset=60999">Fourms</a></td>
        </tr>
        <tr> 
          <td valign="top" class="leftTitle">Current Projects</td>
        </tr>
        <tr> 
          <td valign="top" class="leftText"> 
            <p><a href="../gne/index.htm">GNE</a> v.49a<br>
              <span class="leftDesc">--Game Networking Engine</span></p>
            <p><a href="../itana/index.htm">Itana</a> v.71a<br>
              <span class="leftDesc">--2D multiplayer space game</span></p>
          </td>
        </tr>
        <tr> 
          <td valign="top" class="leftTitle">Complete Projects</td>
        </tr>
        <tr> 
          <td valign="top" class="leftText"><a href="../bgui2/index.htm">BGui2</a> 
            v.2.0.2<br>
            <a href="../deathworms/index.htm">Deathworms</a><br>
            <a href="../muudpic/index.htm">MUUDPIC</a></td>
        </tr>
        <tr> 
          <td valign="top" class="leftTitle"><a href="../contact.htm">Contact 
            Gillius</a></td>
        </tr>
        <tr> 
          <td valign="top" class="leftTitle"><a href="../resume.htm">Gillius's 
            Resum&eacute;</a></td>
        </tr>
        <tr> 
          <td valign="top">&nbsp;</td>
        </tr>
      </table>
      <table width="100%" border="0" cellspacing="0" cellpadding="0">
        <tr> 
          <td> 
            <form action="http://pub.alxnet.com/poll" METHOD="POST" >
              <input type="hidden" name="id" value="2061268">
              <input type="hidden" name="q" value="submit">
              <table border="1" bgcolor="#AAAAAA" cellpadding="3" cellspacing="0">
                <tr> 
                  <td bgcolor="#202020" align="middle" class="pollTitle"> Location</td>
                </tr>
                <tr> 
                  <td> 
                    <table border="0" cellpadding="0" cellspacing="0" width="100%">
                      <tr> 
                        <td class="pollQuestion">What part of the world do you 
                          live in?</td>
                      </tr>
                      <tr> 
                        <td class="pollResponses"> 
                          <input type="radio" name="rd" value="1">
                          North America</td>
                      </tr>
                      <tr> 
                        <td class="pollResponses"> 
                          <input type="radio" name="rd" value="2">
                          South America</td>
                      </tr>
                      <tr> 
                        <td class="pollResponses"> 
                          <input type="radio" name="rd" value="3">
                          Europe</td>
                      </tr>
                      <tr> 
                        <td class="pollResponses"> 
                          <input type="radio" name="rd" value="4">
                          Africa</td>
                      </tr>
                      <tr> 
                        <td class="pollResponses"> 
                          <input type="radio" name="rd" value="5">
                          West/North Asia (like Russia)</td>
                      </tr>
                      <tr> 
                        <td class="pollResponses"> 
                          <input type="radio" name="rd" value="6">
                          East/South Asia (like India and Japan)</td>
                      </tr>
                      <tr> 
                        <td class="pollResponses"> 
                          <input type="radio" name="rd" value="7">
                          Australia / Indonesia</td>
                      </tr>
                      <tr> 
                        <td class="pollResponses"> 
                          <input type="radio" name="rd" value="8">
                          Middle East</td>
                      </tr>
                      <tr> 
                        <td class="pollResponses"> 
                          <input type="radio" name="rd" value="9">
                          Other</td>
                      </tr>
                      <tr> 
                        <td align="middle">
<input type="submit" value="Vote">
                        </td>
                      </tr>
                      <tr> 
                        <td align="middle"><a href="http://pub.alxnet.com/poll?id=2061268&q=view" class="pollLink" >Current 
                          results</a></td>
                      </tr>
                    </table>
                  </td>
                </tr>
                <tr> 
                  <td align="middle"><a href="http://www.alxnet.com/services/poll/" class="pollLink">Alxnet 
                    Free Web Tools</a></td>
                </tr>
              </table>
            </form>
            <a href="../poll.htm">View old poll results</a></td>
        </tr>
        <tr> 
          <td>&nbsp;</td>
        </tr>
      </table>
      <table width="100%" border="0" cellspacing="0" cellpadding="0">
        <tr> 
          <td valign="middle" align="center" height="64"> 
            <!-- Start of TheCounter.com Code -->
            <script type="text/javascript" language="javascript">
s="na";c="na";j="na";f=""+escape(document.referrer)
</script>
            <script type="text/javascript" language="javascript1.2">
s=screen.width;v=navigator.appName
if (v != "Netscape") {c=screen.colorDepth}
else {c=screen.pixelDepth}
j=navigator.javaEnabled()
</script>
            <script type="text/javascript" language="javascript">
function pr(n) {document.write(n,"\n");}
NS2Ch=0
if (navigator.appName == "Netscape" &&
navigator.appVersion.charAt(0) == "2") {NS2Ch=1}
if (NS2Ch == 0) {
r="&size="+s+"&colors="+c+"&referer="+f+"&java="+j+""
pr("<A HREF=\"http://www.TheCounter.com\" TARGET=\"_top\"><IMG"+
" BORDER=0 SRC=\"http://c2.thecounter.com/id=1557583"+r+"\"><\/A>")}
</script>
            <noscript><a href="http://www.TheCounter.com" target="_top"><img
src="http://c2.thecounter.com/id=1557583" alt="TC" border=0></a> </noscript> 
            <!-- End of TheCounter.com Code -->
            <br>
            since 5/14/01</td>
        </tr>
      </table>
    </td>
    <td valign="top" align="left"><!-- #BeginEditable "content" --> 
      <p><a name="stringio"></a>String output and input works much the same in 
        C as for other variables. In C++, cout and cin are made to work with char 
        * parameters the way a programmer would expect them to work. Displaying 
        a string in C and C++ works exactly the same way it did in the Output 
        I lession.</p>
      <pre>#include &lt;stdio.h&gt;
#include &lt;iostream.h&gt;</pre>
      <pre>void main() {
  char MyName[] = &quot;Jason&quot;;
  printf(&quot;%s\n&quot;, MyName());
  cout &lt;&lt; MyName &lt;&lt; endl;
}</pre>
      <p>Nothing much is new or surprising in this program except 
        for the fact there was no number in the declaration. This is not a bug, 
        but since we are working with the string, we can use the exact size needed. 
        When the array is initalized, and the size is left blank, the array becomes 
        the exact size of the elements. In this case there are 5 characters in 
        the name, so the size would be 6 characters, 5 for the name, and one for 
        the NULL character at the end, which is implied when using the double 
        quotes.</p>
      <p>Input for strings looks a little funky for C and C++. 
        C and C++ can input strings like this:</p>
      <pre>char str1[500] = &quot;&quot;;
cin &gt;&gt; str1;        //C++ &quot;streams&quot; method</pre>
      <pre>scanf(&quot;%s&quot;, str1);  //C &quot;stdio&quot; method</pre>
      <p>However, the problem with this method is that only one 
        word of the string will be picked up. Remember how using a space denotes 
        multiple variable entries? The computer will think entering the string 
        &quot;My name is Jason&quot; is actually entring 4 string variables. If 
        all the data is not picked up by the cin/scanf statement, the remaning 
        data will remain in the input buffer until it is read. To read an entire 
        line until the user presses enter, use the following commands:</p>
      <pre>char str1[500] = &quot;&quot;;
char str2[500] = &quot;&quot;;
cin.getline(str1, 499, '\n');
cin.getline(str2, 499, '\n');</pre>
      <pre>scanf(&quot;%499[^\n]&quot;, str1);
scanf(&quot;\n%499[^\n]&quot;, str2);</pre>
      <p>Notice that cin remains the same statement, but scanf 
        changes to place an end-of-line character before other strings. This is 
        because when the string is read into the buffer, the end-of-line is not 
        inserted into the string, and this character stays in the buffer waiting 
        to be read. Whenever a new string needs to be read, the end-of-line needs 
        to be read. It cannot be read after the first string is read, because 
        some non-whitespace character needs to be in the buffer to read anything 
        at all.</p>
      <p>Also notice the parameters to getline function in the 
        cin class (don't worry about the dot until C++ classes are explained in 
        another tutorial) are the string, the max characters (remeber one is needed 
        for the NULL), and the character to end the line. After a getline the 
        end-of-line is read, and not left in the buffer.</p>
      <p>The brackets in scanf are the included characters, or 
        in this case, excluded characters because the list begins with a carat, 
        ^. The end-of-line character is not desired to be in the string, so this 
        character is excluded from input.</p>
      <p align="center"><a href="index.htm#TOC"><strong>Back To 
        Top</strong></a></p>
      <hr>
      <p align="center"><a name="Functions II"></a>This section 
        is C++ specific, the C equalvalent will be discussed in the pointers section.</p>
      <p>Sometimes functions need to change the variables passed 
        to them, or return more than one variable. Normally, when parameters are 
        passed to a function, they are copied, and when the function returns the 
        varaibles are unchanged. In order to change the variables, they need to 
        be passed by reference, using the &amp; in front of the variable name 
        in the function header:</p>
      <pre>void Square(float &amp;x) {
  x *= x;
}</pre>
      <p>Keep in mind that of course, this function will not work 
        for constants, for example Square(5) will not work since 5, the constant, 
        cannot be changed. Calling a function with reference parameters requires 
        no changes.</p>
      <p align="center"><a href="index.htm#TOC"><strong>Back To 
        Top</strong></a></p>
      <hr>
      <p><a name="Structures I"></a>Structures, called records 
        in other langages, are simply just a large user-created variable type. 
        As with other languages, fields need to be defined and they are accesed 
        through the dot operator. Below is a simple program that uses structures:</p>
      <pre>#include &lt;iostream.h&gt;</pre>
      <pre>struct Person {
  char Name[500];
  int age;
};</pre>
      <pre>void main() {
  Person Bob;
  cout &lt;&lt; &quot;Enter first name: &quot;;
  cin.getline(Bob.Name, 499, '\n');
  cout &lt;&lt; &quot;Enter &quot; &lt;&lt; Bob.Name &lt;&lt; &quot;'s age: &quot;
  cin &gt;&gt; Bob.age;
  cout &lt;&lt; Bob.Name &lt;&lt; &quot; is &quot; &lt;&lt; Bob.age &lt;&lt; &quot; years old.&quot; &lt;&lt; endl;
}</pre>
      <p>Note: this syntax declaration will work in C++ and probably 
        C compilers as well, but C programs will write the struct in the format 
        below. Also note that in C, the word &quot;struct&quot; must be placed 
        before the variable type to denote that it is a struct, but works the 
        same in all other ways:</p>
      <pre>typedef struct {
  char Name[500];
  int age;
} Person;</pre>
      <pre>void main() {
  struct Person Bob;
  .
  .
  .</pre>
      <p>Both these formats mean the same thing. Notice the semi-colon 
        terminating the declaration. Keep in mind that all structures in C as 
        well as other languages can be nested infinately. The next program segment 
        shows how complex this can get:</p>
      <pre>struct Arm {
  int fingers;
  float length;
};</pre>
      <pre>struct Leg {
  int toes;
  float length;
};</pre>
      <pre>struct Body {
  Arm arms[2]; //An array of structs in a struct
  Leg legs[2];
  float height;
};</pre>
      <pre>struct Person {
  char name[50];
  int age;
  Body body; //Remember C++ is case senstive so
             //&quot;body&quot; and &quot;Body&quot; are different
};</pre>
      <pre>void main() {
  Person Townspeople[1500];
  strcpy(Townspeople[50].name, &quot;Bob&quot;);
  Townspeople[50].body.arms[2].fingers = 5;
    //How much nesting is too much nesting!?
}</pre>
      <p><a name="OOP I"></a>This program shows how complex structs 
        can get. For those programming C++, remember the structure of this example, 
        since this is a good example of &quot;Object Oriented Programming&quot; 
        or OOP. This is the most widely used approach since it is probably the 
        easiest approach to understand, as each object in &quot;reality&quot; 
        is modeled, using a struct, or in C++, a class. OOP in C is accomplished 
        in C by using structures, and making functions that work on them, like:</p>
      <pre>void CutOffFinger(Person &amp;victim, int arm) {
  victim.body.arms[arm].fingers--;
}</pre>
      <p>This approach will work in C++ of course, but in a much 
        more advanced and intuitive manner using the dot operator like Person.CutOffFinger(int 
        arm) used in classes will be discussed in the C++ specific tutorial. Also, 
        notice that victim is passed by reference since the struct changes.</p>
      <p>There is also a shortcut method to initializing structs 
        that looks exactly like the array initalization. Simply initalize each 
        element in the struct in order in braces like this:</p>
      <pre>struct Person {
  char Name[500];
  int age;
}</pre>
      <pre>Person Bill = {&quot;Bill&quot;, 56};</pre>
      <p align="center"><a href="index.htm#TOC"><strong>Back To 
        Top</strong></a></p>
      <hr>
      <p><a name="Variables IV"></a>Constants can be used in place 
        of variables when their value will never change. This will allow for faster 
        execution and less memory space, and maintains flexabity for the programmer 
        in case the program needs to be changed. To declare a constant, simply 
        place the word const in front of a variable.</p>
      <pre>const int MaxPlayers = 5; //Game constant
const float PI = 3.14159; //Math constant</pre>
      <pre>struct Coorinate {
  int x, y;
}</pre>
      <pre>const Coorinate Start = {50, 60};</pre>
      <p>Good canidates for constants are shown above, and include 
        math constants, maximums and minimums, screen size and color depth -- 
        anything that the user can't change or the program modify.</p>
      <p align="center"><a href="index.htm#TOC"><strong>Back To 
        Top</strong></a></p>
      <hr>
      <p><a name="Number Systems"></a>Before moving onto the pointers 
        section, an understanding of the numbering systems used in computers will 
        be needed, and a quick review is in order. If you already understand binary, 
        decimal, and hexadecimal as well, then you may skip this section.</p>
      <p>Humans are used to counting with base 10 numbers, digits 
        0-9. To find the number of decimal numbers and any other base numbering 
        system, use this formula (the ^ means exponent):</p>
      <p>digit * (base ^ (place-1)) + . . . for each digit</p>
      <p>For example to find the value of 54321, the formula would 
        be like this:</p>
      <p>5*(10^4) + 4*(10^3) + 3*(10^2) + 2*(10^1) 
        + 1*(10^0) = 54321</p>
      <p>The binary system uses 2 digits 0-1. The formula works 
        the same way, for example the number 100 in decimal is:</p>
      <p>1*(2^2) + 0*(2^1) + 0*(2^0) = 4</p>
      <p>The quickest way to count binary numbers is to add that 
        places value to the total if the place is &quot;on&quot; or a 1. A lot 
        of times programmers seperate every 4 digits with a colon for readability. 
        The place values start at 1 and go in powers of 2: 1,2,4,8,16,32,64,128,256, 
        like this:</p>
      <pre>Value: 128 64  32  16  8   4   2   1
Number:  1  0   0   1: 1   1   0   0
Tally: 128 +0  +0 +16 +8  +4  +0  +0 = 156</pre>
      <p><a name="Variable Capacities"></a>The total number of 
        combonations (capacity) of a binary number or variable is 2^numbits-1. 
        For example a byte can hold 255 combonations, or 2^8-1. Below is a common 
        variable chart:</p>
      
        <center>
          <table border="2" bgcolor="#808080">
            <tr> 
              <td width="25%" bgcolor="#C0C0C0"><strong>Variable Names</strong></td>
              <td width="25%"><strong>Number of 
                bits</strong></td>
              <td width="25%" bgcolor="#C0C0C0"><strong>Unsigned Capacity</strong></td>
              <td width="25%"><strong>Signed Capacity</strong></td>
            </tr>
            <tr> 
              <td width="25%" bgcolor="#C0C0C0"><font color="#000000">byte, char, 
                character</font></td>
              <td width="25%"><font color="#000000">8</font></td>
              <td width="25%" bgcolor="#C0C0C0"><font color="#000000">255</font></td>
              <td width="25%"><font color="#000000">-128..127</font></td>
            </tr>
            <tr> 
              <td width="25%" bgcolor="#C0C0C0"><font color="#000000">short, word</font></td>
              <td width="25%"><font color="#000000">16</font></td>
              <td width="25%" bgcolor="#C0C0C0"><font color="#000000">65535</font></td>
              <td width="25%"><font color="#000000">-32768..32767</font></td>
            </tr>
            <tr> 
              <td width="25%" bgcolor="#C0C0C0"><font color="#000000">int, dword</font></td>
              <td width="25%"><font color="#000000">32</font></td>
              <td width="25%" bgcolor="#C0C0C0"><font color="#000000">4294967295</font></td>
              <td width="25%"><font color="#000000">-2147483648..2147483647</font></td>
            </tr>
            <tr> 
              <td width="25%" bgcolor="#C0C0C0"><font color="#000000">long long, 
                qword</font></td>
              <td width="25%"><font color="#000000">64</font></td>
              <td width="25%" bgcolor="#C0C0C0"><font color="#000000">2^64-1</font></td>
              <td width="25%"><font color="#000000">-2^63..2^63-1</font></td>
            </tr>
          </table>
        </center>
      <p>The hexadecimal system was chosen to be used in the computer 
        field because of its relation to binary. Each 2 digits in the hexadecimal 
        system corresponds with one byte, and each letter to a set of 4 bits. 
        Digits go from 0..F, where A=10. The formula shown above with the powers 
        holds true to convert to the decimal system. Converting to binary is more 
        of a memorization. The 0x in front of the numbers simply designates that 
        it is in the hexadecimal system.</p>
      <p>0xFF = 255 = 1111:1111<br>
        0xF = 15 = 1111<br>
        0x80 = 128 = 1000:0000<br>
        0x8 = 8 = 1000<br>
        0x0 = 0 = 0000</p>
      <p>As you can see you can memorize (or easily figure out) 
        the 15 combonations and place the parts together. A quicker way in Windows 
        is to use the calculator, which in scientific mode, can perform these 
        conversions.</p>
      <p align="center"><a href="index.htm#TOC"><strong>Back To 
        Top</strong></a></p>
      <hr>
      <p><a name="Pointers I"></a>Each variable in memory is stored 
        in a location in memory, and usually the variables are contingous when 
        declared together in a function. Mainpulating very large objects, arrays, 
        or dynamically allocated variables (<a href="#Dynamic Memory Allocation">section below</a>), arrays, and linklists require 
        more detailed understanding and use of how variables actually work in 
        the compiler. In C, this is the only way to change variables which need 
        to be changed in the function.</p>
      <p>A pointer varaible is denoted by an asterisk following 
        a variable type and contains a memory location pointing to a variable 
        of the type. This can be written two different ways, with the * right 
        after the type, or the * before the name. To return a pointer to a variable, 
        place an &amp; in front of its name. To reverse this operation, place 
        an * in front of the pointer.</p>
      <pre>#include &lt;iostream.h&gt;</pre>
      <pre>void main() {
  int x       = 53;
  int *intptr = &amp;x;
  int* ptr2   = intptr; //This syntax works too</pre>
      <pre>  cout &lt;&lt; &quot;The value of x is: &quot; &lt;&lt; x &lt;&lt; &quot; or &quot; &lt;&lt; *intptr &lt;&lt; endl;
  cout &lt;&lt; &quot;The memory address of x is: &quot; &lt;&lt; intptr &lt;&lt; &quot; or &quot; &lt;&lt; &amp;x &lt;&lt; endl;
}</pre>
      <p>The first cout will output the same variable twice. Keep 
        in mind that x and *intptr is the SAME data, they are NOT copied -- this 
        is the point of pointer variables is to have two names to the same data, 
        or to mark the beginning of an array. To change the data a pointer points 
        to, simply dereference it using the *, and keep in mind that x will change 
        as well:</p>
      <p>*intptr = 57; /*X becomes 57 as well 
        since intptr points to data in x*/</p>
      <p>An entire array cannot be stored under one variable, so 
        when an array is declared, a block of contingous memory is allocated, 
        and the [] operator works on the pointer. The formula for determining 
        element x in an array which is used internally by the compiler is: ArrayAddress 
        + x*sizeof(ArrayType), where ArrayAdress is a pointer to ArrayType. The 
        sizeof function is a real function which returns the number of bytes a 
        variable occupies. If an int array was declared, the sizeof(int) would 
        equal 4. While programming however, the addition works correctly on pointers 
        -- adding 1 to an int pointer will actually add 4 bytes ahead, from 0x0 
        to 0x4.</p>
      <pre>int IntArray[500];            //Assume IntArray == 0x0
cout &lt;&lt; &amp;IntArray[0] &lt;&lt; endl; //Outputs 0x0, the first element's address
cout &lt;&lt; &amp;IntArray[1] &lt;&lt; endl; //Outputs 0x4, since the second var is 4
                              // more bytes into memory.
cout &lt;&lt; IntArray &lt;&lt; endl;     //Outputs 0x0, the first element's address
cout &lt;&lt; IntArray + 200        //Outputs address of element 200, 0x320
cout &lt;&lt; &amp;IntArray[200] &lt;&lt; endl;//Same as above</pre>
      <p>Now the reason why array elements start at 0 become clear 
        -- adding 0 to the array address returns the first element. Also a <strong>very 
        important</strong> note: an array will never truely start at 0x0, which 
        is the address of the NULL pointer. This area of memory points to the 
        start of conventional memory(DOS) or to the start of your program or segment, 
        depending on processor and operating system. In any case, NULL, address 
        0, starts in something important, so writing to this address can overwrite 
        DOS or Windows's memory, and luckily, in Windows this will generate a 
        GPF, or general protection fault, and terminate the program.</p>
      <p>You can access an array entirely through pointers like 
        so:</p>
      <pre>int array[500] = {0}; //intialize all elements to 0
int *traverse = array;//To traverse the array
for (int c=0; c&lt;500; c++) //for all elements
  *(traverse++) = c;  //Set array elements. The ++ operator AFTER the pointer
                      // increments it AFTER this statment, moving to next
                      // element.  If the ++'s were before the varaible, then
                      // it would increment before the access, and would skip
                      // first element, and copy one element over its bounds.</pre>
      <p>Accessing unitialized pointers in DOS or any environment 
        that does not check for NULL dereferencing will not immediately crash 
        the program, but instead will overwrite code in the code, and the computer 
        will crash when it hits the corrupted function, or it may change variables, 
        or do nothing at all if that area is never accessed again. This bug is 
        the nastiest bug possible in any application.</p>
      <p>When your program locks up or data is being changed for 
        no reason, look at the code in the function first. If there is no other 
        explantion for the seemingly random crashes, try looking at pointers in 
        your program to make sure all are pointing correctly and none point to 
        NULL or to some other undesired address. Also check to see that arrays 
        are not overstepping their bounds. Narrow functions down to ones that 
        have executed before the crash.</p>
      <p>Because of the difficulty of debugging poitners, <strong>ALWAYS</strong> 
        initalize the pointer, preferably to the data you need it to point to, 
        or at least to NULL. Keep in mind you cannot intialize a pointer with 
        data with a constant, since constants are not supposed to be altered, 
        with the exception being strings:</p>
      <p>int *ptr = 5; //Really sets address 
        to 0x5, not data to 5.<br>
        char *name = &quot;Bob&quot;; //This is okay since &quot;&quot; returns 
        a char*</p>
      <p>Just keep in mind with name, if you assign a string with 
        more than 3 letters, it will overstep its bounds, unless you declare more 
        space:</p>
      <p>char name[50] = &quot;Bob&quot;;</p>
      <p><a name="Debugging Pointers"></a>Below is some common 
        debugging problems with pointers.</p>
      
        <center>
          <table border="2" width="100%" bgcolor="#808080">
            <tr> 
              <td width="32%"><font color="#0000FF"><strong>Problem occuring in 
                program</strong></font></td>
              <td width="33%"><font color="#0000FF"><strong>Possible Statements 
                which cause problem</strong></font></td>
              <td width="33%"><font color="#0000FF"><strong>Explanation</strong></font></td>
            </tr>
            <tr> 
              <td width="32%"><font color="#000000">Data being changed for no 
                reason</font></td>
              <td width="33%"><font color="#000000">int x[500]; x[900] = 50;<br>
                char name[5] = &quot;String Too Large&quot;;</font></td>
              <td width="33%"><font color="#000000">When an array goes out of 
                bounds, it will work correctly, except it will continue copying 
                into other variable's memory.</font></td>
            </tr>
            <tr> 
              <td width="32%"><font color="#000000">&quot;Random&quot; crashes</font></td>
              <td width="33%"><font color="#000000">int *ptr = NULL; *ptr = 50;</font></td>
              <td width="33%"><font color="#000000">Chages data at NULL, which 
                contains your .EXE or operating system code</font></td>
            </tr>
          </table>
        </center>
      <p>In C, to change the value of variables passed to a function, 
        you need to send pointers. This program shows how to achieve the same 
        thing as the above C++ reference passing. As a side note, keep in mind 
        arrays are pointers too so changing an array passed to a function also 
        changes it outside the function. These are usually passed as pointers.</p>
      <pre>void Square(int *numb) {
  *numb *= *numb; //data *= data, remember to deference to get at data
}</pre>
      <pre>void SquareArray(int *arr) {
  for (int c=0; c&lt;10; c++)
    arr[c] *= arr[c]; //can use [] on pointers since arrays are pointers too
}</pre>
      <pre>int main() {
  int x = 5;
  int intarr[10];
  Square(&amp;x); //must use &amp; to pass a pointer, unlike C++ reference
  printf(&quot;x = %i&quot;, x);
  SquareArray(intarr); //intarr is already a pointer
  return 0;
}</pre>
      <p align="center"><a href="index.htm#TOC"><strong>Back To 
        Top</strong></a></p>
      <hr>
      <p><a name="Dynamic Memory Allocation"></a>This section applies 
        only to C++ right now because of my lack of experience in malloc() and 
        other related commands in C. If you are reading this tutorial for C, you 
        can read this section to pick up on the concept, and use your compiler's 
        help file to look at how to use the C malloc() and free() commands which 
        have different format but essentially the same function, and usually the 
        help file also has examples.</p>
      <p>Whenever you declare a variable in a C/C++ program, the 
        compiler will reserve this memory for you, usually before program execution 
        in the .EXE file, in the case of a global, or may allocate memory at run-time 
        on the stack if the variable is in a small function. You can see this 
        directly -- Place a huge, several megabyte array in your source as a global 
        array. Your .EXE will increase by the array's size. Place it in a function 
        and it will not.</p>
      <p>However, there is a very serious problem placing that 
        array in a function. When data isn't already allocated in the .EXE file 
        (globally), it must go onto the stack. Now this varies greatly depending 
        on compiler an OS but can vary from 16k to 640k. No reasonably sized stack 
        could hold a variable the size of a megabyte or even half that (consider 
        that all previous function calls and variables declared within also are 
        on the stack). You can tell you have run out of stack space when your 
        program crashes miserably on you -- this is what happens if you don't 
        allow an &quot;exit&quot; for recursion (When a function calls itself, 
        much like a loop works) and you keep on calling functions until you run 
        out of stack space.</p>
      <p>The answer to this problem is called <span class="keyTerm">dynamic 
        memory allocation</span>. Whenever you specifcally &quot;ask&quot; 
        the compiler for data, it will find data not in the stack, or the .EXE, 
        but instead an area called the data segment. When a program needs more 
        memory, it must &quot;get permission&quot; from the operating system or 
        the <a href="../info.htm#DPMI">DPMI</a>. A pointer to the start of the new memory 
        will be returned.</p>
      <p>In C++ the commands to manage memory are called <span class="keyTerm">new</span> 
        and <span class="keyTerm">delete</span>. C programmers should note that there 
        is no C++ equalvalent command for the C realloc() memory reallocation 
        command. Below is an example of delcaring a new variable in the data segment:</p>
      <pre>void main() {
  int* x = new int;//Grabs a new space
  *x = 500;        //Sets the newly allocated data to 500
  delete x;        //Destroys x variable permanently
}</pre>
      <p>Note that if we never deleted x, the memory would remain 
        allocated in the program until we exited back to the operating system, 
        so ALWAYS make sure you delete variables after use. Also initalizing a 
        variable grabbed by new becomes much more important as the variable will 
        nearly always contain trash and very rarely zero, whereas reserved global 
        variables, residing in the .EXE, as usually cleared out. Also another 
        interesting fact is that if we allocated a new integer right after deleting 
        x, the value of that integer <span class="keyTerm">could</span> be 500, depending 
        on how the compiler handles dynamic memory. I say this because the data 
        from the 500 was never really &quot;destroyed&quot; upon deletion, but 
        rather simply &quot;dropped&quot; and ignored by the program, marked as 
        ready to be allocated again. This is exactly where your trash comes from 
        in new variables.</p>
      <p>Using the new command for a single variable is noteably 
        fairly useless, as a single variable will fit on the stack. However for 
        a large array, use the new command. The syntax is slightly different for 
        both commands:</p>
      <pre>void main() {
  int* x = new int[5000]; //Declares a large new int array - new returns a pointer
  x[50] = 10; x[10] = 50; //Do stuff with new array -- acts no different
  delete[] x;             //[] denotes x points to an array rather than single var
}</pre>
      <p>Since an array is really a pointer, you can use an array 
        declared with new exactly like any other array.</p>
      <p>You can only grab a one-dimentional array with new, not 
        a two dimentional. This is a drawback, but there is a way of getting around 
        this. My guess to the reason of one-dimentional arrays only is because 
        2D arrays is not directly representable in memory, instead it is a way 
        of working with memory, and the programmer is meant to program the way 
        something works, not the compiler. But if you remember a 2D array is really 
        an &quot;array of arrays&quot;:</p>
      <pre>void main() {
  int** x = NULL; //Declare pointer to a pointer, or in this case
                  // a pointer to an array of pointers
  int** x = new int*[100]; //Pointers to 100 arrays
  for (int c=0; c&lt;100; c++) {
    x[c] = new int[100];   //Creates an array for each pointer in x array
  }</pre>
      <pre>  x[1][1] = 5;    //Works like a 2D array</pre>
      <pre>  for (int c=0; c&lt;100; c++) {
    delete[] x[c];
  }
  delete[] x;
}</pre>
      <p>Doing it like this lets you realize just exactly how some 
        of the things in C++ works, and some of the minute technicalities. Remember 
        a computer takes the code literally with zero interpretation. x[c] will 
        return a pointer, and a pointer can be assigned an array with the new 
        command. When it's time to use the array, you could look at it like this: 
        ((x)[1])[1]. X is a pointer to a pointer, where the [] operator will return 
        a pointer, which is really an array, where the [] operator can work on 
        it.</p>
      <p align="center"><a href="index.htm#TOC"><strong>Back To 
        Top</strong></a></p>
      <!-- #EndEditable --></td>
  </tr>
</table>
</body>
<!-- #EndTemplate --></html>

