ID=E0206
URL=http://www.rit.edu/~jpw9607/ooptut/part3.htm
SIZE=35602
DATE=12/07/02
TIME=19:18:39
DATASET=C
HTML=<html><!-- #BeginTemplate "/Templates/main.dwt" -->
<head>
<!-- #BeginEditable "doctitle" --> 
<title>OOP Tutorial Page 3</title>
<!-- #EndEditable --> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" href="../style.css" type="text/css">
<meta name="keywords" content="DJGPP, Allegro, programming, JetFight, Project V2143, C++, tutorials, linklist, MSVC, Microsoft Visual C++, Itana, GNE, Deathworms, MUUDPIC, Java, links, games, libraries, source, code, C, network, multiplayer">
<meta name="description" content="Gillius's Programming.  C/C++ tutorials, games, java, allegro, and libraries.">
</head>
<body bgcolor="#000000" text="#FFFFFF" link="#FFFF00" vlink="#008080" alink="#990099">
<table width="100%" border="0" cellpadding="0" cellspacing="5">
  <tr> 
    <td colspan="2" class="titleBar">Gillius's Programming</td>
  </tr>
  <tr> 
    <td width="130" height="621" valign="top"> 
      <table border="0" cellpadding="3" cellspacing="0" name="NavBar" width="130">
        <tr> 
          <td valign="top" class="leftTitle">Sections</td>
        </tr>
        <tr> 
          <td valign="top" class="leftText"><a href="../index.htm">Home / News</a><br>
            <a href="../tutorial.htm">Tutorials</a><br>
            <a href="../games.htm">Games Corner</a><br>
            <a href="../java/index.htm">Java</a><br>
            <a href="../filesandprog.htm">The Archive</a><br>
            <a href="../links.htm">Links</a> </td>
        </tr>
        <tr> 
          <td valign="top" class="leftTitle"><a href="http://boards.eesite.com/board.cgi?boardset=60999">Fourms</a></td>
        </tr>
        <tr> 
          <td valign="top" class="leftTitle">Current Projects</td>
        </tr>
        <tr> 
          <td valign="top" class="leftText"> 
            <p><a href="../gne/index.htm">GNE</a> v.49a<br>
              <span class="leftDesc">--Game Networking Engine</span></p>
            <p><a href="../itana/index.htm">Itana</a> v.71a<br>
              <span class="leftDesc">--2D multiplayer space game</span></p>
          </td>
        </tr>
        <tr> 
          <td valign="top" class="leftTitle">Complete Projects</td>
        </tr>
        <tr> 
          <td valign="top" class="leftText"><a href="../bgui2/index.htm">BGui2</a> 
            v.2.0.2<br>
            <a href="../deathworms/index.htm">Deathworms</a><br>
            <a href="../muudpic/index.htm">MUUDPIC</a></td>
        </tr>
        <tr> 
          <td valign="top" class="leftTitle"><a href="../contact.htm">Contact 
            Gillius</a></td>
        </tr>
        <tr> 
          <td valign="top" class="leftTitle"><a href="../resume.htm">Gillius's 
            Resum&eacute;</a></td>
        </tr>
        <tr> 
          <td valign="top">&nbsp;</td>
        </tr>
      </table>
      <table width="100%" border="0" cellspacing="0" cellpadding="0">
        <tr> 
          <td> 
            <form action="http://pub.alxnet.com/poll" METHOD="POST" >
              <input type="hidden" name="id" value="2061268">
              <input type="hidden" name="q" value="submit">
              <table border="1" bgcolor="#AAAAAA" cellpadding="3" cellspacing="0">
                <tr> 
                  <td bgcolor="#202020" align="middle" class="pollTitle"> Location</td>
                </tr>
                <tr> 
                  <td> 
                    <table border="0" cellpadding="0" cellspacing="0" width="100%">
                      <tr> 
                        <td class="pollQuestion">What part of the world do you 
                          live in?</td>
                      </tr>
                      <tr> 
                        <td class="pollResponses"> 
                          <input type="radio" name="rd" value="1">
                          North America</td>
                      </tr>
                      <tr> 
                        <td class="pollResponses"> 
                          <input type="radio" name="rd" value="2">
                          South America</td>
                      </tr>
                      <tr> 
                        <td class="pollResponses"> 
                          <input type="radio" name="rd" value="3">
                          Europe</td>
                      </tr>
                      <tr> 
                        <td class="pollResponses"> 
                          <input type="radio" name="rd" value="4">
                          Africa</td>
                      </tr>
                      <tr> 
                        <td class="pollResponses"> 
                          <input type="radio" name="rd" value="5">
                          West/North Asia (like Russia)</td>
                      </tr>
                      <tr> 
                        <td class="pollResponses"> 
                          <input type="radio" name="rd" value="6">
                          East/South Asia (like India and Japan)</td>
                      </tr>
                      <tr> 
                        <td class="pollResponses"> 
                          <input type="radio" name="rd" value="7">
                          Australia / Indonesia</td>
                      </tr>
                      <tr> 
                        <td class="pollResponses"> 
                          <input type="radio" name="rd" value="8">
                          Middle East</td>
                      </tr>
                      <tr> 
                        <td class="pollResponses"> 
                          <input type="radio" name="rd" value="9">
                          Other</td>
                      </tr>
                      <tr> 
                        <td align="middle">
<input type="submit" value="Vote">
                        </td>
                      </tr>
                      <tr> 
                        <td align="middle"><a href="http://pub.alxnet.com/poll?id=2061268&q=view" class="pollLink" >Current 
                          results</a></td>
                      </tr>
                    </table>
                  </td>
                </tr>
                <tr> 
                  <td align="middle"><a href="http://www.alxnet.com/services/poll/" class="pollLink">Alxnet 
                    Free Web Tools</a></td>
                </tr>
              </table>
            </form>
            <a href="../poll.htm">View old poll results</a></td>
        </tr>
        <tr> 
          <td>&nbsp;</td>
        </tr>
      </table>
      <table width="100%" border="0" cellspacing="0" cellpadding="0">
        <tr> 
          <td valign="middle" align="center" height="64"> 
            <!-- Start of TheCounter.com Code -->
            <script type="text/javascript" language="javascript">
s="na";c="na";j="na";f=""+escape(document.referrer)
</script>
            <script type="text/javascript" language="javascript1.2">
s=screen.width;v=navigator.appName
if (v != "Netscape") {c=screen.colorDepth}
else {c=screen.pixelDepth}
j=navigator.javaEnabled()
</script>
            <script type="text/javascript" language="javascript">
function pr(n) {document.write(n,"\n");}
NS2Ch=0
if (navigator.appName == "Netscape" &&
navigator.appVersion.charAt(0) == "2") {NS2Ch=1}
if (NS2Ch == 0) {
r="&size="+s+"&colors="+c+"&referer="+f+"&java="+j+""
pr("<A HREF=\"http://www.TheCounter.com\" TARGET=\"_top\"><IMG"+
" BORDER=0 SRC=\"http://c2.thecounter.com/id=1557583"+r+"\"><\/A>")}
</script>
            <noscript><a href="http://www.TheCounter.com" target="_top"><img
src="http://c2.thecounter.com/id=1557583" alt="TC" border=0></a> </noscript> 
            <!-- End of TheCounter.com Code -->
            <br>
            since 5/14/01</td>
        </tr>
      </table>
    </td>
    <td valign="top" align="left"><!-- #BeginEditable "content" --> 
      <h1>Chapter V -- Linked 
        Lists</h1>
      <p align="center"><a href="index.htm#TOC"><strong>Back to 
        Top</strong></a></p>
      <h2><a name="Using Pointers with Classes/Structs"></a>Using Pointers with Classes/Structs</h2>
      <p align="left">By now you should understand most of the 
        basic principles of objects and how to use them. It's all nice to learn 
        the syntax and the workings but now they need to be applied so they make 
        our programming much more efficent.</p>
      <p align="left">This is where pointers show up in C++ as 
        one of the most useful tools in programming. Before you may have wondered 
        why anyone would want to use pointers unless they wanted to allocate large 
        amounts of memory on and off during the program. This chapter will begin 
        to explain this and will form a foundation on which to create an &quot;engine&quot; 
        for your program, espically games.</p>
      <p align="left">In order to first start this, we need to 
        know how to use objects with pointers. Since a class is used in C++ like 
        any other variable, the pointer should intuitively follow this approach:</p>
      <div align="left"> 
        <pre>MyClass* classPtr;
classPtr = new MyClass();</pre>
      </div>
      <p align="left">As with other variables, all of the same 
        rules apply, the ampersand (&amp;) to get the address, and the leading 
        asterisk (*) to reach the actual data.</p>
      <p align="left">But what of the dot operator (.)? The dot 
        operator requires data on the left side in order to access a function/variable 
        in the class. You could do it this way:</p>
      <div align="left"> 
        <pre>(*classPtr).someFunction();
(*classPtr).someVariable = 15;</pre>
      </div>
      <p align="left">This statement works, but requires more typing. 
        Luckily there is a shortcut for this, using the indirection operator (-&gt;). 
        This operator works on a pointer to a class just like the dot operator. 
        Note that if you use it to access a variable it returns the data of that 
        variable and not a pointer to it:</p>
      <div align="left"> 
        <pre>classPtr-&gt;someFunction(); //Same as statements above
classPtr-&gt;someVariable = 15;</pre>
      </div>
      <h2><a name="Introducing the Linked List"></a>Introducing the Linked List</h2>
      <p align="left">Now that we know how to use these pointers, 
        let put them to use in a linklist. All these little simply silly programs 
        are probably starting to get boring. Well this is the first REAL, serious, 
        programming application in the tutorial. I still use this today (check 
        out the <a
href="../filesandprog.htm#linklist_H">linklist library</a> 
        which is a fully developed class based off of what's to follow).</p>
      <p align="left">A linklist is like an array, but different 
        -- to compare -- an array is contigous in memory, meaning it takes up 
        one solid block of memory with no gaps in between. A linklist contains 
        elements as well, but is like a chain, with each element connecting to 
        the next, and therefore does not have to be as &quot;rigid&quot; as an 
        array.</p>
      <p align="left">Why a linklist? Well imagine some of the 
        drawbacks of an array. First of all you cannot resize an array. It must 
        be of a fixed length. What if you have to add an element? You have to 
        shift the rest of the array down, copying a lot of memory, and the same 
        goes for deletion. In a linklist, in order to add an element, you simply 
        &quot;disconnect that chain,&quot; add the link, and reconnect -- just 
        three steps, and the same for deletion. Below is a chart showing the disadvantages 
        and advantages of both methods. Each one has its good and bad points and 
        neither is worse or better than the other. Use the best method for the 
        situtation. Don't worry if you don't understand all of it now as all topics 
        are highlighted and it is meant for future reference.<a name="LinkedVsArray"></a></p>
      <table border="2" cellspacing="0" width="100%" bgcolor="#C0C0C0"
bordercolor="#C0C0C0" bordercolordark="#808080"
bordercolorlight="#FFFFFF">
        <tr> 
          <td colspan="4">
            <p align="center"><font color="#FF0000"
        size="5"><strong>Linked Lists vs Arrays</strong></font></p>
          </td>
        </tr>
        <tr> 
          <td colspan="2">
            <p align="center"><strong>Linked Lists</strong></p>
          </td>
          <td colspan="2">
            <p align="center"><strong>Arrays</strong></p>
          </td>
        </tr>
        <tr> 
          <td align="center" width="25%" bgcolor="#008000">
            <p
        align="center">Advantages</p>
          </td>
          <td align="center" width="25%" bgcolor="#800000">
            <p
        align="center">Disadvantages</p>
          </td>
          <td align="center" width="25%" bgcolor="#008000">
            <p
        align="center">Advantages</p>
          </td>
          <td align="center" width="25%" bgcolor="#800000">
            <p
        align="center">Disadvantages</p>
          </td>
        </tr>
        <tr> 
          <td align="center" width="25%" bgcolor="#008000">
            <p
        align="center"><font color="#000000">Easy to add/delete elements</font></p>
          </td>
          <td align="center" width="25%" bgcolor="#800000">
            <p
        align="center"><font color="#000000">Cannot access an element in the list 
              directly -- must follow chain</font></p>
          </td>
          <td align="center" width="25%" bgcolor="#008000">
            <p
        align="center"><font color="#000000">Can access an element directly without 
              speed penalty</font></p>
          </td>
          <td align="center" width="25%" bgcolor="#800000">
            <p
        align="center"><font color="#000000">Hard to insert/delete elements</font></p>
          </td>
        </tr>
        <tr> 
          <td align="center" width="25%" bgcolor="#008000">
            <p
        align="center"><font color="#000000">Faster when sorting, adding, deleteing 
              many elements with very little penalty</font></p>
          </td>
          <td align="center" width="25%" bgcolor="#800000">
            <p
        align="center"><font color="#000000">Severe speed penalty for random access, 
              sequential access only acceptable way</font></p>
          </td>
          <td align="center" width="25%" bgcolor="#008000">
            <p
        align="center"><font color="#000000">No speed penalty for sequential or 
              random access, faster access in general</font></p>
          </td>
          <td align="center" width="25%" bgcolor="#800000">
            <p
        align="center"><font color="#000000">Severe penalty for adding and deleting 
              elements increasing exponentially for large data types</font></p>
          </td>
        </tr>
        <tr> 
          <td align="center" width="25%" bgcolor="#008000">
            <p
        align="center"><font color="#000000">No speed penalty for dealing with 
              larger objects</font></p>
          </td>
          <td align="center" width="25%" bgcolor="#800000">
            <p
        align="center"><font color="#000000">Harder to program, easier to lose 
              track of pointer and crash computer</font></p>
          </td>
          <td align="center" width="25%" bgcolor="#008000">
            <p
        align="center"><font color="#000000">Easier to program</font></p>
          </td>
          <td align="center" width="25%" bgcolor="#800000">
            <p
        align="center"><font color="#000000">Extreme penalty for dynamically resizing 
              array</font></p>
          </td>
        </tr>
        <tr> 
          <td align="center" width="25%" bgcolor="#008000"><font
        color="#000000">No speed penalty for resizing or shrinking size -- also 
            no fixed size</font></td>
          <td align="center" width="25%" bgcolor="#800000"><font
        color="#000000">Memory overhead (4 bytes per class) to store pointer to 
            the next link</font></td>
          <td align="center" width="25%" bgcolor="#008000"><font
        color="#000000">No memory overhead</font></td>
          <td align="center" width="25%" bgcolor="#800000"><font
        color="#000000">Can hold objects of only one type</font></td>
        </tr>
        <tr> 
          <td align="center" width="25%" bgcolor="#008000"><font
        color="#000000">Can hold virtually unlimited numbers of objects of virtually 
            unlimited types</font></td>
          <td align="center" width="25%" bgcolor="#800000">&nbsp;</td>
          <td align="center" width="25%" bgcolor="#008000"><font
        color="#000000">Some sorting algorithms faster on fixed arrays</font></td>
          <td align="center" width="25%" bgcolor="#800000">&nbsp;</td>
        </tr>
        <tr> 
          <td align="center" width="25%" bgcolor="#008000"><font
        color="#000000">Fast and easy for alphabetical or comparative sorting</font></td>
          <td align="center" width="25%" bgcolor="#800000">&nbsp;</td>
          <td align="center" width="25%" bgcolor="#008000">&nbsp;</td>
          <td align="center" width="25%" bgcolor="#800000">&nbsp;</td>
        </tr>
      </table>
      <p align="left">How does this work? Well each element in 
        a linked list keeps a pointer to the next element in the list, represented 
        by this graphic:</p>
      <p align="center"><img src="link.gif" width="115"
height="43"></p>
      <p align="left">First look at this imcompleted class:</p>
      <div align="left"> 
        <pre>class LinkedInteger {
private:
  LinkedInteger* next;   //pointer to the next element in the list
  int data;              //data in this link
}</pre>
      </div>
      <p>You can see that the pointer is the key element to get 
        this list to work. Below is a graphical representaion of a linked list 
        (a standard array is also shown for comparison):</p>
      <p align="center"><img src="linklist.gif"
width="512" height="128"></p>
      <h2><a name="Interface to the Linked List"></a>Interface to the Linked List</h2>
      <p>There are several ways to reference a linked list. The 
        first method deals with creating an object directly (LinkedInteger start;) 
        and adding elements to that. This has the disadvantage of not being able 
        to have an empty list. The second method is is create a pointer to the 
        first object in the list, or NULL if there are no objects (LinkedInteger* 
        LiList;), which has the advantage of being able to store an empty list, 
        but the disadvantage of only being able to hold one datatype. The third 
        method is to create a class which manages a linked list. This has the 
        advantage of data hiding (so you cannot access the links directly), and 
        centralizes the code so that any bug in the list can exist in only one 
        function in that class, rather than somewhere in your program when you 
        directly access the list. It is this third method which will be explained 
        here.</p>
      <p>First let's create a &quot;skeleton&quot; for our new 
        LinkList class. What operations do we want to perform on the list? Minimally, 
        we need to be able to add, delete, and access elements in the list (using 
        traverse functions). A length function may also be helpful, as well as 
        an insertion function. What variables will we need? A pointer to the current 
        element, a pointer to the previous element (for deletion and insertion), 
        the pointer to the start (so we can start over at the beginning again).</p>
      <pre>class Person { //This is the data we will use
public:
  void getData();
  void showData();
private:
  char* name;
  int age;
  char* occupation;
};</pre>
      <pre>struct Link {  //This is the fundamental unit of our list
  Person* next;//next element
  Person data; //actual data
};</pre>
      <pre>class LinkList {//Acts as the interface to the program
public:
  LinkList();  //Constructor
  ~LinkList(); //Destructor deallocates all used memory
  void add(Person data);   //Add an element to the start of the list
  void insert(Person data);//Insert element before current
  void delete();           //Delete current element
  Person* getThis();       //Get curr element
  void traverse();         //Go to next element
  void startOver();        //Go back to the start
  int  len();              //Returns current list length
private:
  Link* start; //beginning of list
  Link* curr;  //current element
  Link* prev;  //previous element
  int length;  //current list length
};</pre>
      <p>To use the LinkList, a user would first startOver();, 
        and use getThis() to get the first element in the list, and use traverse() 
        to proceed to the next. The user can modify/interact with the element 
        through the pointer, and changes made to that data change also in the 
        list. When getThis() returns NULL, the list is at the end. The method 
        insert() at this point will add an element to the end (it adds an element 
        before the current, and since it's one past the last, before the NULL 
        is at the end). This makes the LinkList work like a stack, LIFO (Last 
        in first out), so the first element is the last one added.</p>
      <p>When in the middle of the list, the delete() method will 
        delete the current element. The current element will become the next element 
        (effectively calling a traverse() after the delete()).</p>
      <p>Note that you did not need to know how this class worked 
        to know how to use it -- such is the advantage of OOP.</p>
      <h2><a name="Creating the Linked List"></a>Creating the Linked List</h2>
      <p>The first thing we need to do is construct the LinkList. 
        Since the list starts empty, start, prev, and curr will all be NULL, and 
        length will be zero.</p>
      <pre>LinkList::LinkList() {
  prev = curr = start = NULL;
  length = 0;
}</pre>
      <p>Now to destruct the LinkList, we need to free all of the 
        taken memory. But we don't know how the links work yet to do this, but, 
        we know of a function in LinkList that will help, and that's called delete(). 
        We can simply delete() all of the elements:</p>
      <pre>LinkList::~LinkList() {
  startOver();
  while(getThis() != NULL) {
    delete(); //This also effectively advances
  }
}</pre>
      <p>Also, since it really doesn't belong in any other section, 
        I'll mention the len() method here. Actually it's too simple to mention. 
        I'll leave it as an exercise to you to discover how that one works ;).</p>
      <h2><a name="Adding Links"></a>Adding Links</h2>
      <p>So how exactly do we work with these links? The first 
        operation we need to perform on a linked list is adding elements. We have 
        the option of creating at the start or the end of the list. But, the problem 
        with adding at the end of the list is that we have to traverse it to get 
        to the end, which is not very efficent. So, if we don't care about order, 
        we can add objects up front very easily and quickly. If we did care about 
        order, we would use the insert function which is comming later.</p>
      <p>This is a picture of the add operation. The other links 
        already exist, and the transparent arrow is the pointer about to be linked, 
        and the lower left link is the new link:</p>
      <p align="center"><img src="addlink.gif"
width="512" height="128"></p>
      <p>And below is the function to do this:</p>
      <pre>void LinkList::add(Person data) {
  Link* newLink = new Link; //Allocate mem for a new link
  newLink-&gt;next = start;    //start will become second element
  newLink-&gt;data = data;     //copy data over
}</pre>
      <p>You may ask, &quot;Well this is nice if there are already 
        elements, but what if the list is empty?&quot; Well, since the last link 
        in the list's next pointer is NULL, if the list is empty, start will be 
        NULL. NULL will be simply assigned to the next pointer of the link, making 
        it the end link.</p>
      <p>To insert links, we have to know the previous and next 
        links, so this must happen at the current position in the list. This method 
        is good for sorting lists, where you can search until you find an element 
        greater, then insert() which adds the element before the currently selected 
        one. Notice that the insert() code does not really alter the position 
        in the list. Here is the code to do this:</p>
      <pre>void LinkList::insert(Person data) {
  Link* newLink = new Link; //Allocate mem for a new link
  newLink-&gt;next = curr;     //current link becomes next
  newLink-&gt;data = data;     //copy data over
  prev-&gt;next = newLink;     //previous points to this now
  prev = newLink;           //this link is one before curr now
}</pre>
      <h2><a name="Getting the Data"></a>Getting the Data</h2>
      <p>Traversing the list is easy. The current pointer becomes 
        the next pointer of the current element (curr = curr-&gt;next;). It is 
        suggested to also check to see if (curr == NULL), so the list isn't overrun:</p>
      <pre>void LinkList::traverse() {
  if (curr != NULL) {
    curr = curr-&gt;next;
  }
}</pre>
      <p>To getThis(), simply return curr. See this linked list 
        stuff isn't too hard.</p>
      <h2><a name="Deleting Elements"></a>Deleting Elements</h2>
      <p align="left">Deleting is simple when you think about it 
        in the same context as the other functions -- they really all follow the 
        same theme. Well when you delete the previous will point to the next element, 
        so that the route simply &quot;skips&quot; over this element. Then we 
        can safely delete it. Unlike insert() though, this one will have to effectively 
        advance the list since the current element is invalid.</p>
      <div align="left"> 
        <pre>void LinkList::delete() {
  prev-&gt;next = curr-&gt;next; //&quot;skip&quot; over this element
  delete curr;             //remove this element
  curr = prev-&gt;next;       //&quot;advance&quot; to next element
}</pre>
      </div>
      <p align="left">Curr had to be assigned to prev-&gt;next 
        rather than curr-&gt;next (as in the traverse method) because when we 
        delete curr, its data is invalid and we can't reference it anymore. This 
        is a common oversight, as this is not the intuitive order, but this order 
        is required to get the list to work. Notice we could have chosen to fall 
        back or go forward after the delete, but it makes much more sense to continue 
        on with the list rather than backtracking.</p>
      <h2><a name="Other Functions"></a>Other Functions</h2>
      <p align="left">The other functions are small and simple 
        and are left as an exercise for you to do. In the next chapter we will 
        cover a very valuable usage for the LinkList. If you want to use a LinkList 
        or want to see a more complex and developed one, there is one available 
        in the Archive.</p>
      <p align="center"><a href="index.htm#TOC"><strong>Back to 
        Top</strong></a></p>
      <h1>Chapter VI -- Virtual 
        Functions</h1>
      <p align="center"><font size="5">Keep in mind this is still a work in progress!</font></p>
      <p align="center"><a href="index.htm#TOC"><strong>Back to 
        Top</strong></a></p>
      <h2><a name="Pointers and Derived Classes"></a>Pointers and Derived Classes</h2>
      <p align="left">This whole chapter comes from the concept 
        presented by this code:</p>
      <div align="left"> 
        <pre>class BaseClass {
public:
  void doStuff();

  int data;
};</pre>
      </div>
      <div align="left"> 
        <pre>class DervClass : public BaseClass {
public:
  void doStuff();

  int moreData;
};</pre>
      </div>
      <div align="left"> 
        <pre>void main() {
  DervClass obj1;
  BaseClass obj2;
  BaseClass* ptr1 = obj1; //Assigning an DervClass to a BaseClass pointer!
}</pre>
      </div>
      <p>This can seem pretty extreme, but if you think about it, 
        this is totally workable. On a BaseClass*, you can use all of the functions 
        available in BaseClass, which work on BaseClass variables. These functions 
        and variables also exist in DervClass, being a class derived from BaseClass, 
        and so the same things should work. This is because DervClass is really 
        a &quot;BaseClass and then some,&quot; and you can always in a sense &quot;downgrade&quot; 
        your status.</p>
      <p>When you call methods or access variables from the pointers, 
        everything works as normal except for the fact that when you use the base 
        pointer, you can only access things from the base class. For example, 
        given a continuation of main() from above:</p>
      <pre>ptr1-&gt;doStuff(); //Calls BaseClass::doStuff(), NOT DervClass:dostuff()!
ptr1-&gt;moreData = 5; // NOT valid since moreData is in DervClass, and
                    //this is a BaseClass*
ptr1-&gt;data = 10;    //Valid statement</pre>
      <p>In the next few lessons you will see how to overcome the 
        problem presented by the last code, where the BaseClass::doStuff() was 
        called when you probably wanted to call DervClass::doStuff().</p>
      <h2><a name="The Virtual Keyword"></a>The Virtual Keyword</h2>
      <p align="left">Imagine this -- You have a whole bunch of 
        different types of objects in your program, say, many different types 
        of people, but they all have only slightly differing propertities. Because 
        of this, you would make it simpler and have all of the classes share the 
        same code (Person class) and where there are different properties, create 
        a dervied class, like Student. Now imagine they have some sort of routine 
        that you must call on all of them they they have in common, such as display(), 
        which prints a message to the console telling themselves about them &quot;My 
        name is &lt;name&gt; and I am a Student. I'm &lt;age&gt; years old.&quot; 
        or something similar to that.</p>
      <p align="left">Now that you have the basic design set up, 
        you need to keep track of a large array of people. The only problem with 
        an array is that it can only hold only one type. Based on the previous 
        section with assigning pointers of derived classes to base class pointer 
        variables, you could make the array:</p>
      <div align="left"> 
        <pre>Person* array[512]; //An array of pointers</pre>
      </div>
      <p align="left">There is one major problem with this. You 
        have to know the maximum number of people to store. A better method would 
        be to use the linked list above, and modifying it so that it stores Person* 
        rather than Person data. That way we can just declare a LinkList and add 
        and delete people nearly as quickly as the array. This is also assuming 
        that we only need to access people sequentially (from start to end and 
        perform operations as you go along). If for some reason we wanted to access 
        people randomly or by some ID number, an array may have to do, or a Vector-type 
        class which is an array which expands and contracts itself as needed (Vectors 
        are not discussed in this tutorial). You can refer back to the chart dealing 
        with <a
href="#LinkedVsArray">LinkLists vs Arrays</a> to see when to pick one over the other.</p>
      <p align="left">So let's examine the code for the classes 
        before we go any further. The Person class is the basic functions which 
        apply to any person. All of the implementation (code) of the class except 
        for one method is not completed because it is unnessacary in this case. 
        The routines are simple and you can fill in the code as an exercise.</p>
      <div align="left"> 
        <pre>class Person {
public:
  Person(char* name, int age, char* address);
    //copies strings
  virtual ~Person();

  char* getName();
  int   getAge();
  char* getAddress();
    //set functions copy strings
  char* setName();
  int   setAge();
  char* setAddress();

  virtual void display();
private:
  char* name;
  int age;
  char* address;
};</pre>
      </div>
      <div align="left"> 
        <pre>class Student : public Person {
public:
  Student(char* name, int age, char* address, char* school);
    //copies strings
  virtual ~Student();

  void display();
private:
  char* school;
};</pre>
      </div>
      <p align="left">The reserved word <span class="keyTerm">virtual</span> 
        is the main concept presented by this code. On methods besides the destructor, 
        this means that the method can be overridden by an inherited class when 
        the method is called on the base pointer. This can sound confusing at 
        first since the previous lessons have already shown this is possible. 
        But with virtual functions the point is that you do not need to know which 
        class it came from! Observe the following code:</p>
      <div align="left"> 
        <pre>//The usual way:
Person man(&quot;Bob&quot;, 35, &quot;15th S Pine St&quot;);
Student woman(&quot;Jill&quot;, 19, &quot;n/a -- dormatory&quot;, &quot;RIT&quot;);
man.display();   //This is valid, called Person::display()
woman.display(); //calls Student::display()

//With virtual methods:
Person* baseptr = man;
baseptr-&gt;display(); //calls Person::display()
baseptr = woman;    //Can assign Student* to Person*
baseptr-&gt;display(); //Calls Student::display();</pre>
      </div>
      <p align="left">Using the virtual keyword we overcame the 
        problem we had in the first lesson for this chapter. Even when the pointer 
        loses its identity we can still override functions in the derived class. 
        Note that even still, the method must exist in the base class in order 
        to call it -- it is just simply virtual says it should look to see if 
        there is an override.</p>
      <h2><a name="Virtual Destructors"></a>Virtual Destructors</h2>
      <p align="left">You may also have noticed that the destructors 
        are virtual as well. What is this supposed to mean? Well when you use 
        the <span class="keyTerm">delete</span> operator, and call it on the base pointer, 
        it would call the destructor for the base class only without destructing 
        the derived class. With the virtual keyword, the compiler will look for 
        the destructor in the child class.</p>
      <p align="left">In other words: if you have any virtual functions 
        in a class, or you will be (or think you might be) using a class through 
        a pointer to one of its parent classes as we have done in this chapter, 
        you need to make the destructor virtual. If you do not the class will 
        not be destroyed properly and the correct destructor will not be called, 
        potentially causing memory leaks and other errors.</p>
      <p align="center"><a href="index.htm#TOC"><strong>Back to 
        Top</strong></a></p>
      <p>&nbsp;</p>
      <!-- #EndEditable --></td>
  </tr>
</table>
</body>
<!-- #EndTemplate --></html>

