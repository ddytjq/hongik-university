ID=E0278
URL=http://www.gotw.ca/gotw/066.htm
SIZE=40366
DATE=12/07/02
TIME=19:19:29
DATASET=C
HTML=
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta http-equiv="Content-Language" content="en-us">


<title>GotW #66: Constructor Failures</title>
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<link rel="stylesheet" type="text/css" href="../gotw.css">
<meta name="Microsoft Theme" content="gotw 111, default">
<meta name="Microsoft Border" content="tlb, default">
</head>

<body background="../_themes/gotw/glabkgnd.jpg" bgcolor="#CCFFFF" text="#000000" link="#008080" vlink="#008080" alink="#0000FF"  ><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font><table border="0" cellspacing="0" width="100%">
  <tr>
    <td colspan="2"><!--mstheme--><font face="Arial, Arial, Helvetica"><font size="6"><strong>
    GotW #66</strong></font> <!--mstheme--></font></td>
  </tr>
  <tr>
    <td valign="middle"><!--mstheme--><font face="Arial, Arial, Helvetica">




<p align="left" style="margin-top: 0; margin-bottom: 0">

<script language="JavaScript"><!--
MSFPhover = 
  (((navigator.appName == "Netscape") && 
  (parseInt(navigator.appVersion) >= 3 )) || 
  ((navigator.appName == "Microsoft Internet Explorer") && 
  (parseInt(navigator.appVersion) >= 4 ))); 
function MSFPpreload(img) 
{
  var a=new Image(); a.src=img; return a; 
}
// --></script><script language="JavaScript"><!--
if(MSFPhover) { MSFPnav1n=MSFPpreload("../_derived/home_cmp_gotw110_hbtn.gif"); MSFPnav1h=MSFPpreload("../_derived/home_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav1'].src=MSFPnav1h.src" onmouseout="if(MSFPhover) document['MSFPnav1'].src=MSFPnav1n.src"><img src="../_derived/home_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Home" align="middle" name="MSFPnav1"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav2n=MSFPpreload("../_derived/news.htm_cmp_gotw110_hbtn.gif"); MSFPnav2h=MSFPpreload("../_derived/news.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../news.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav2'].src=MSFPnav2h.src" onmouseout="if(MSFPhover) document['MSFPnav2'].src=MSFPnav2n.src"><img src="../_derived/news.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="News &amp; Events" align="middle" name="MSFPnav2"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav3n=MSFPpreload("../resources/_derived/index.htm_cmp_gotw110_hbtn.gif"); MSFPnav3h=MSFPpreload("../resources/_derived/index.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../resources/index.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav3'].src=MSFPnav3h.src" onmouseout="if(MSFPhover) document['MSFPnav3'].src=MSFPnav3n.src"><img src="../resources/_derived/index.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Community Resources" align="middle" name="MSFPnav3"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav4n=MSFPpreload("../_derived/consulting.htm_cmp_gotw110_hbtn.gif"); MSFPnav4h=MSFPpreload("../_derived/consulting.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../consulting.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav4'].src=MSFPnav4h.src" onmouseout="if(MSFPhover) document['MSFPnav4'].src=MSFPnav4n.src"><img src="../_derived/consulting.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Consulting Services" align="middle" name="MSFPnav4"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav5n=MSFPpreload("../_derived/presentations.htm_cmp_gotw110_hbtn.gif"); MSFPnav5h=MSFPpreload("../_derived/presentations.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../presentations.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav5'].src=MSFPnav5h.src" onmouseout="if(MSFPhover) document['MSFPnav5'].src=MSFPnav5n.src"><img src="../_derived/presentations.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Presentations" align="middle" name="MSFPnav5"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav6n=MSFPpreload("../publications/_derived/index.htm_cmp_gotw110_hbtn.gif"); MSFPnav6h=MSFPpreload("../publications/_derived/index.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../publications/index.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav6'].src=MSFPnav6h.src" onmouseout="if(MSFPhover) document['MSFPnav6'].src=MSFPnav6n.src"><img src="../publications/_derived/index.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Publications" align="middle" name="MSFPnav6"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav7n=MSFPpreload("_derived/index.htm_cmp_gotw110_hbtn.gif"); MSFPnav7h=MSFPpreload("_derived/index.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="index.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav7'].src=MSFPnav7h.src" onmouseout="if(MSFPhover) document['MSFPnav7'].src=MSFPnav7n.src"><img src="_derived/index.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Guru of the Week" align="middle" name="MSFPnav7"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav8n=MSFPpreload("../conv/_derived/index.htm_cmp_gotw110_hbtn.gif"); MSFPnav8h=MSFPpreload("../conv/_derived/index.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../conv/index.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav8'].src=MSFPnav8h.src" onmouseout="if(MSFPhover) document['MSFPnav8'].src=MSFPnav8n.src"><img src="../conv/_derived/index.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Conversations" align="middle" name="MSFPnav8"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav9n=MSFPpreload("../_derived/search.htm_cmp_gotw110_hbtn.gif"); MSFPnav9h=MSFPpreload("../_derived/search.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../search.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav9'].src=MSFPnav9h.src" onmouseout="if(MSFPhover) document['MSFPnav9'].src=MSFPnav9n.src"><img src="../_derived/search.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Search GotW.ca" align="middle" name="MSFPnav9"></a>
</p>




    <!--mstheme--></font></td>
    <td valign="middle"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 0; margin-bottom: 0">
      <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav10n=MSFPpreload("../_derived/back_cmp_gotw110_back.gif"); MSFPnav10h=MSFPpreload("../_derived/back_cmp_gotw110_back_a.gif"); }
// --></script><a href="065.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav10'].src=MSFPnav10h.src" onmouseout="if(MSFPhover) document['MSFPnav10'].src=MSFPnav10n.src"><img src="../_derived/back_cmp_gotw110_back.gif" width="100" height="20" border="0" alt="Prev" name="MSFPnav10"></a><br><script language="JavaScript"><!--
if(MSFPhover) { MSFPnav11n=MSFPpreload("../_derived/up_cmp_gotw110_up.gif"); MSFPnav11h=MSFPpreload("../_derived/up_cmp_gotw110_up_a.gif"); }
// --></script><a href="index.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav11'].src=MSFPnav11h.src" onmouseout="if(MSFPhover) document['MSFPnav11'].src=MSFPnav11n.src"><img src="../_derived/up_cmp_gotw110_up.gif" width="100" height="20" border="0" alt="Up" name="MSFPnav11"></a><br><script language="JavaScript"><!--
if(MSFPhover) { MSFPnav12n=MSFPpreload("../_derived/next_cmp_gotw110_next.gif"); MSFPnav12h=MSFPpreload("../_derived/next_cmp_gotw110_next_a.gif"); }
// --></script><a href="067.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav12'].src=MSFPnav12h.src" onmouseout="if(MSFPhover) document['MSFPnav12'].src=MSFPnav12n.src"><img src="../_derived/next_cmp_gotw110_next.gif" width="100" height="20" border="0" alt="Next" name="MSFPnav12"></a><!--mstheme--></font></td>
  </tr>
  <tr>
    <td height="5" background="../images/bar.gif" colspan="2"><!--mstheme--><font face="Arial, Arial, Helvetica">&nbsp;<!--mstheme--></font></td>
  </tr>
</table><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font></td></tr><!--msnavigation--></table><!--msnavigation--><table dir="ltr" border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td valign="top" width="1%"><!--mstheme--><font face="Arial, Arial, Helvetica">

<!--mstheme--></font><table border="0" cellspacing="0" bgcolor="#000000" cellpadding="0">
  <tr>
    <td><!--mstheme--><font face="Arial, Arial, Helvetica">
    <!--mstheme--></font><table border="0" cellpadding="2" cellspacing="1" width="100%" height="483">
        <tr>
          <td align="center" bgcolor="#000000" colspan="2" height="16"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin-top: 0; margin-bottom: 0"><a href="../news.htm"><b><font color="#FFFF00">News</font></b></a><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="center" bgcolor="#CCCCCC" bordercolor="#CCCCCC" rowspan="3"><!--mstheme--><font face="Arial, Arial, Helvetica">
          <font size="1" color="#0000FF">J<br>
          U<br>
          L<br>
          Y</font><!--mstheme--></font></td>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin-left: 3; margin-right: 3; margin-top: 0" align="center"><font size="1" color="#0000FF">
            Print articles newly available online</font><!--mstheme--></font><table border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%" id="AutoNumber1" bgcolor="#FFFFCC" bordercolordark="#006666" bordercolorlight="#99CCCC">
              <tr>
                <td width="100%" bordercolor="#808000"><!--mstheme--><font face="Arial, Arial, Helvetica">
                <p style="margin: 3"><font size="1" color="#0000FF">
                <a href="../publications/mill20.htm"><b><i>
                <font color="#0000FF">Sutter's Mill</font></i></b><font color="#0000FF"> 
                column, &quot;Toward a Standard C++ Library, Part 1&quot;</font></a></font><!--mstheme--></font></td>
              </tr>
              <tr>
                <td width="100%" bordercolor="#808000" bgcolor="#FFFFCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
                <p style="margin: 3"><font size="1" color="#0000FF">
                <a href="../publications/mxc++-item-4.htm">
                <font color="#0000FF">Excerpt from MXC++, &quot;Extensible Templates: 
                Via Inheritance or Traits?&quot;</font></a></font><!--mstheme--></font></td>
              </tr>
              <tr>
                <td width="100%" bordercolor="#808000"><!--mstheme--><font face="Arial, Arial, Helvetica">
                <p style="margin: 3"><font size="1" color="#0000FF">
                <a href="../publications/mcd_review.htm"><font color="#0000FF">
                Book Review: Modern C++ Design</font></a></font><!--mstheme--></font></td>
              </tr>
              <tr>
                <td width="100%" bordercolor="#808000"><!--mstheme--><font face="Arial, Arial, Helvetica">
                <p style="margin: 3"><font size="1" color="#0000FF">
                <a href="../publications/mill21.htm"><b><i>
                <font color="#0000FF">Sutter's Mill</font></i></b><font color="#0000FF"> 
                column, &quot;Toward a Standard C++ Library, Part 2: Namespaceops and 
                Library Versioning&quot;</font></a></font><!--mstheme--></font></td>
              </tr>
            </table><!--mstheme--><font face="Arial, Arial, Helvetica">
          <!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin: 0 3"><font size="1" color="#0000FF"><b><i>Sutter's 
            Mill</i></b> column,
            &quot;A Pragmatic Look at Exception Specifications&quot;<br>
            </font><font size="1" color="#000080">The usefulness, or lack 
            thereof, of exception specifications, and how results can vary 
            across real-world compilers</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin: 0 3">
            <a target="_blank" href="http://www.cuj.com/experts/2007/hyslop.htm"><font size="1" color="#0000FF"><i><b>Conversations</b></i> column,
            &quot;Getting to the Point&quot;</font></a><font color="#0000FF" size="1"><br>
            </font><font size="1" color="#000080">The Boost library has five 
            smart pointers that provide a rich array [sic] of useful behaviors.</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="center" bgcolor="#CCCCCC" bordercolor="#CCCCCC" rowspan="2"><!--mstheme--><font face="Arial, Arial, Helvetica"><font color="#0000FF" size="1">A<br>
            U<br>
          G<br>
          U<br>
          S<br>
          T</font><!--mstheme--></font></td>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin:0 3; ">
            <a target="_blank" href="http://www.cuj.com/experts/2008/sutter.htm"><i><b><font size="1" color="#0000FF">The New C++</font></b></i> <font size="1" color="#0000FF">
            column, &quot;Smart(er) Pointers&quot;</font></a><font size="1" color="#000080"><br>
            A closer look at one of the proposed new standard C++ library 
            features -- smart pointers, particularly those in Boost and Loki, 
            and a sneak peek at the usefulness of the proposed typedef templates</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
          <p style="margin:0 3; ">
          <a target="_blank" href="http://www.cuj.com/experts/2008/hyslop.htm"><font size="1" color="#0000FF"><i><b>Conversations</b></i> column,
            &quot;A Midsummer Night's Madness&quot;</font></a><font color="#0000FF" size="1"><br>
            </font><font size="1" color="#000080">A brew that mixes pointers, 
          typedefs, and const</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="center" bgcolor="#CCCCCC" bordercolor="#CCCCCC" rowspan="3"><!--mstheme--><font face="Arial, Arial, Helvetica">
          <p style="margin-top: 0; margin-bottom: 0">
          <font size="1" color="#0000FF">S<br>
          E<br>
          P<br>
          T<br>
          E<br>
          M<br>
          B<br>
          E<br>
          R</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin: 0 3">
            <font size="1" color="#0000FF">&quot;Standard C++ Meets Managed C++&quot;<br>
            </font><font size="1" color="#000080">A survey of the main (in)compatibilities 
            between Standard C++ and Microsoft’s managed extensions for C++, and 
            how the two could converge</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin: 0 3"><font size="1" color="#0000FF"><b><i>Sutter's 
            Mill</i></b> column,
            &quot;Export Restrictions, Part 1&quot;<br>
            </font><font size="1" color="#000080">The scoop on export -- what 
            some people think it does, what it actually does, and why it’s the 
            most widely-ignored feature in the C++ standard</font><!--mstheme--></font></td>
        </tr>
      </table><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font></td>
  </tr>
</table><!--mstheme--><font face="Arial, Arial, Helvetica">
<p style="margin-top: 0; margin-bottom: 0">
<img border="0" src="../images/140.gif" width="140" height="1"></p>

<!--mstheme--></font></td><td valign="top" width="24"></td><!--msnavigation--><td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica">
<!--mstheme--></font><table border="1" cellpadding="6" cellspacing="0" width="100%" bgcolor="#CCCCFF" bordercolordark="#006666" bordercolorlight="#99CCCC">
  <tr>
    <td width="100%"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p align="center">This is the original GotW problem and solution
      substantially as posted to Usenet. See the book <i><a href="../publications/mxc++.htm"><b>More
      Exceptional C++</b></a></i> (Addison-Wesley, 2002) for the most current
      solution to this GotW issue. The solutions in the book have been revised
      and expanded since their initial appearance in GotW. The book versions
      also incorporate corrections, new material, and conformance to the final
      ANSI/ISO C++ standard.</p>
    <!--mstheme--></font></td>
  </tr>
</table><!--mstheme--><font face="Arial, Arial, Helvetica">
      <h2><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Constructor Failures&nbsp;<font size="3"><br>
      Difficulty: 7 / 10</font><!--mstheme--></font></h2>
<p><i>What exactly happens when a constructor emits an exception? What if the
exception comes from an attempt to construct a subobject or member object? This
issue of GotW analyzes one aspect of C++ in detail, shows why it should work the
way that it does, and demonstrates the implications for constructor exception
specifications.</i></p>
<p align="center"><img border="0" src="../images/h-line.gif" width="248" height="2"></p>

<h3><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Problem<!--mstheme--></font></h3>

<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">JG Question<!--mstheme--></font></h4>
<p><b><font size="4">1.</font></b>   Consider the following class:</p>
<blockquote>
<p><font face="Courier New">// Example 1<br>
//<br>
class C : private A<br>
{<br>
&nbsp; B b_;<br>
};</font></p>
</blockquote>
<p>In the C constructor, how can you catch an exception thrown from the
constructor of a base subobject (such as A) or a member object (such as B)?</p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Guru Questions<!--mstheme--></font></h4>
<p><b><font size="4">2.</font></b>   In Example 1, if the A or B constructor
throws an exception, is it possible for the C constructor to absorb the
exception, and emit no exception at all? Justify your answer, explaining by
example why this is as it should be.</p>
<p><b><font size="4">3.</font></b>   What are the minimal requirements that A
and B must meet in order for us to safely put an empty throw- specification on
C's constructor(s)?</p>
<p align="center"><img border="0" src="../images/h-line.gif" width="248" height="2"></p>
<h3><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666"><a name="Solution"></a>Solution<!--mstheme--></font></h3>

<p>This issue of GotW was inspired by questions and a lengthy email exchange
with Bobby Schmidt, renowned columnist for CUJ and MSDN Online's &quot;Deep
C++.&quot; For more information about Bobby's treatments of the topics addressed
below, be sure to check out the very interesting reading in the online
references mentioned in Note 1.<b><a href="#1"><sup>[1]</sup></a></b></p>

<p><font color="#999933"><b><font size="4">1.</font></b>   Consider the
following class:</font></p>
<blockquote>
<p><font face="Courier New" color="#999933">// Example 1<br>
//<br>
class C : private A<br>
{<br>
&nbsp; B b_;<br>
};</font></p>
</blockquote>
<p><font color="#999933">In the C constructor, how can you catch an exception
thrown from the constructor of a base subobject (such as A) or a member object
(such as B)?</font></p>
<p>The short answer is: By using a function-try-block.</p>
<p>For example, here's how we can write a function-try-block for C's
constructor:</p>
<blockquote>
  <p><font face="Courier New">// Example 1(a): Constructor function-try-block<br>
  //<br>
  C::C()<br>
  try<br>
  &nbsp; : A ( /*...*/ ) // optional initialization list<br>
  &nbsp; , b_( /*...*/ )<br>
  {<br>
  }<br>
  catch( ... )<br>
  {<br>
  &nbsp; // We get here if either A::A() or B::B() throws.<br>
  <br>
  &nbsp; // If A::A() succeeds and then B::B() throws, the<br>
  &nbsp; // language guarantees that A::~A() will be called<br>
  &nbsp; // to destroy the already-created A base subobject<br>
  &nbsp; // before control reaches this catch block.<br>
  }</font></p>
</blockquote>
<p>The more interesting, question, though is: Why would you want to do this?
That question is at the heart of this GotW issue.</p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Object Lifetimes, and What a Constructor Exception Means<!--mstheme--></font></h4>
<p>In order to answer Question #2 correctly, we need only to fully understand
object lifetimes<b><a href="#2"><sup>[2]</sup></a></b> and what it means for a
constructor to throw an exception.</p>
<p>Take a simple example:</p>
<blockquote>

<p><font face="Courier New">{<br>
&nbsp; Parrot parrot;<br>
}</font></p>

</blockquote>
<p>In the above code, when does the object's lifetime begin? When does it end?
Outside the object's lifetime, what is the status of the object? Finally, what
would it mean if the constructor threw an exception? Take a moment to think
about these questions before reading on.</p>
<p>Let's take these items one at a time:</p>
<p>Q: When does an object's lifetime begin?</p>
<p>A: When its constructor completes successfully and returns normally. That is,
control reaches the end of the constructor body or an earlier return statement.</p>
<p>Q: When does an object's lifetime end?</p>
<p>A: When its destructor begins. That is, control reaches the beginning of the
destructor body.</p>
<p>Q: What is the state of the object after its lifetime has ended?</p>
<p>A: As a well-known software guru<b><a href="#3"><sup>[3]</sup></a></b> once
put it, speaking about a similar code fragment and anthropomorphically referring
to the local object as a &quot;he&quot;:</p>
<blockquote>
  <p><i>He's not pining! He's passed on! This parrot is no more! He has ceased
  to be! He's expired and gone to meet his maker! He's a stiff! Bereft of life,
  he rests in peace! If you hadn't nailed him to the perch he'd be pushing up
  the daisies! His metabolic processes are now history! He's off the twig! He's
  kicked the bucket, he's shuffled off his mortal coil, run down the curtain and
  joined the bleedin' choir invisible! THIS IS AN EX-PARROT!</i></p>
  <p align="right">- Dr. M. Python, BMath, MASc, PhD (CompSci)</p>
  <p>[The actual code example being commented upon by the above guru was only
  slightly different:</p>
  <p><font face="Courier New">{<br>
  &nbsp; Parrot();<br>
  &nbsp; const Parrot&amp; perch = Parrot();<br>
  <br>
  &nbsp; // ... more code; at this point, only the first<br>
  &nbsp; // temporary object is pushing up daisies ...<br>
  }</font></p>
  <p>Get it? It's a lifetime-of-temporaries-bound-to-references joke. Remember
  it for Bay area parties.]</p>
</blockquote>
<p>Kidding aside, the important point here is that the state of the object
before its lifetime begins is exactly the same as after its lifetime ends --
there is no object, period. This observation brings us to the key question:</p>
<p>Q: What does emitting an exception from a constructor mean?</p>
<p>A: It means that construction has failed, the object never existed, its
lifetime never began. Indeed, the only way to report the failure of construction
-- that is, the inability to correctly build a functioning object of the given
type -- is to throw an exception. (I will presently comment on the obsolete
&quot;if you get into trouble just set a status flag to 'bad' and let the caller
check it via an IsOK() function&quot; programming convention.)</p>
<p>In biological terms, conception took place -- the constructor began --, but
despite best efforts it was followed by a miscarriage -- the constructor never
ran to term(ination).</p>
<p>Incidentally, this is why a destructor will never be called if the
constructor didn't succeed -- there's nothing to destroy. &quot;It cannot die,
for it never lived.&quot; Note that this makes the phrase &quot;an object whose
constructor threw an exception&quot; really an oxymoron. Such a thing is even
less than an ex-object... it never lived, never was, never breathed its first.</p>
<p>We might summarize the C++ constructor model as follows:</p>
<blockquote>
  <p>Either:</p>
  <p>(a) The constructor returns normally by reaching its end or a return
  statement, and the object exists.</p>
  <p>Or:</p>
  <p>(b) The constructor exits by emitting an exception, and the object not only
  does not now exist, but never existed.</p>
</blockquote>
<p>There are no other possibilities. Armed with this information, we can now
fairly easily tackle Question #2.</p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">I Can't Keep No Caught Exceptions<a href="#7"><b><sup>[7]</sup></b></a><!--mstheme--></font></h4>
<p><font color="#999933"><b><font size="4">2.</font></b>   In Example 1, if the
A or B constructor throws an exception, is it possible for the C constructor to
absorb the exception, and emit no exception at all?</font></p>

<p>If you didn't consider the object lifetime rules, you might have tried
something like the following:</p>

<blockquote>

<p><font face="Courier New">// Example 2(a): Absorbing exceptions?<br>
//<br>
C::C()<br>
try<br>
&nbsp; : A ( /*...*/ ) // optional initialization-list<br>
&nbsp; , b_( /*...*/ )<br>
{<br>
}<br>
catch( ... )<br>
{<br>
&nbsp; // ?<br>
}</font></p>

</blockquote>
<p>If the handler body contained the statement &quot;throw;&quot; then the catch
block would obviously rethrow whatever exception A::A() or B::B() had emitted.
What's less obvious, but clearly stated in the standard, is that if the catch
block does not throw (either rethrow the original exception, or throw something
new), and control reaches the end of the catch block of a constructor or
destructor, then the original exception is automatically rethrown.</p>
<p>Think about what this means: A constructor or destructor function-try-block's
handler code MUST finish by emitting some exception. There's no other way. The
language doesn't care what exception it is that gets emitted -- it can be the
original one, or some other translated exception -- but an exception there must
be! It is impossible to keep any exceptions thrown by base or member subobject
constructors from causing some exception to leak beyond their containing
constructors.</p>
<p>In fewer words, it means that:</p>
<blockquote>
  <p>If construction of any base or member subobject fails, the whole object's
  construction <i>must </i>fail.</p>
</blockquote>
<p>This is no different than saying &quot;there is no way for a human to exist
(i.e., be born alive) if any of its vital organs (e.g., heart, liver) were never
formed.&quot; If you tried to continue by keeping at least those parts you were
able to make, the result may be a hunk of flesh, probably rotting, but it was
never a human being. There is no such thing as an &quot;optional&quot; base or
member (held by value or reference) subobject.</p>
<p>A constructor cannot possibly recover and do something sensible after one of
its base or member subobjects' constructors throws. It cannot even put its own
object into a &quot;construction failed&quot; state... its object <i>is not</i>
constructed, it never will be constructed no matter what Frankensteinian efforts
the handler attempts in order to breathe life into the non-object, and whatever
destruction can be done has already been done automatically by the language --
and that includes all base and member subobjects.</p>
<p>What if your class can honestly have a sensible &quot;construction partially
failed&quot; state -- i.e., it really does have some &quot;optional&quot;
members that aren't strictly required and the object can limp along without
them, possibly with reduced functionality? Then use the Pimpl idiom to hold the
possibly-bad parts of the object at arm's length. For similar reasoning, see <a href="../publications/xc++.htm"><i>Exceptional
C++</i></a> Items 31-34 about abuses of inheritance<b><a href="#4"><sup>[4]</sup></a></b>;
incidentally, this &quot;optional parts of an object&quot; idea is another great
reason to use delegation instead of inheritance whenever possible, because base
subobjects can never be made optional because you can't put base subobjects into
a Pimpl.</p>
<div align="right">
  <!--mstheme--></font><table border="1" cellpadding="6" cellspacing="0" width="50%" align="right" bordercolordark="#006666" bordercolorlight="#99CCCC">
    <tr>
      <td width="100%"><!--mstheme--><font face="Arial, Arial, Helvetica">
<p>Aside: Convergence is funny sometimes. Long after I
started pushing the Pimpl idiom and bashing needless inheritance, I kept on
coming across new problems that were solved by using Pimpl or removing needless
inheritance, especially to improve exception safety. I guess it shouldn't have
been a surprise because it's just this whole coupling thing again: Higher
coupling means greater exposure to failure in a related component. To this
comment, Bobby Schmidt responded:</p>
<blockquote>
  <p><i>And maybe that's the core lesson to pull out of
  this -- we've really just rediscovered and amplified the old
  minimal-coupling-maximum-cohesion axiom.</i><a href="#5"><b><sup>[5]</sup></b></a></p>
</blockquote>
      <!--mstheme--></font></td>
    </tr>
  </table><!--mstheme--><font face="Arial, Arial, Helvetica">
</div>
<p>I've always had a love/hate relationship with exceptions, but even so I've
always had to agree that exceptions are the right way to signal constructor
failures given that constructors cannot report errors via return codes (ditto
for most operators). I have found the &quot;if a constructor encounters an
error, set a status bit and let the user call IsOK() to see if construction
actually worked&quot; method to be outdated, dangerous, tedious, and in no way
better than throwing an exception.</p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Toward Some Morals<!--mstheme--></font></h4>
<p>Incidentally, this also means that the only (repeat only) possible use for a
constructor function-try-block is to translate an exception thrown from a base
or member subobject. That's Moral #1. Next, Moral #2 says that destructor
function-try-blocks are entirely usele--</p>
<p>&quot;--But wait!&quot; I hear someone interrupting from the middle of the
room. &quot;I don't agree with Moral #1. I can think of another possible use for
constructor function-try-blocks, namely to free resources allocated in the
initializer list or in the constructor body!&quot;</p>
<p>Sorry, nope. After all, remember that once you get into your constructor
try-block's handler, any local variables in the constructor body are also
already out of scope, and you are guaranteed that no base subobjects or member
objects exist any more, period. You can't even refer to their names. Either the
parts of your object were never constructed, or those that were constructed have
already been destroyed. So you can't be cleaning up anything that relies on
referring to a base or member of the class (and anyway, that's what the base and
member destructors are for, right?).</p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Aside: Why Does C++ Do It That Way?<!--mstheme--></font></h4>
<p>To see why it's good that C++ does it this way, let's put that restriction
aside for the moment and imagine, just imagine, that C++ did let you mention
member names in those handlers. Then imagine the following case, and try to
decide: Should the handler delete t_ or z_? (Again, ignore for the moment that
in real C++ it can't even refer to t_ or z_.)</p>
<blockquote>

<p><font face="Courier New">// Example 2(b): Very Buggy Class<br>
//<br>
class X : Y {<br>
&nbsp; T* t_;<br>
&nbsp; Z* z_;<br>
public:<br>
&nbsp; X()<br>
&nbsp; try<br>
&nbsp;&nbsp;&nbsp; : Y(1)<br>
&nbsp;&nbsp;&nbsp; , t_( new T( static_cast&lt;Y*&gt;(this) )<br>
&nbsp;&nbsp;&nbsp; , z_( new Z( static_cast&lt;Y*&gt;(this), t_ ) )<br>
&nbsp; {<br>
&nbsp;&nbsp;&nbsp; /*...*/<br>
&nbsp; }<br>
&nbsp; catch(...)<br>
&nbsp; // Y::Y or T::T or Z::Z or X::X's body has thrown<br>
&nbsp; {<br>
&nbsp;&nbsp;&nbsp; // Q: should I delete t_ or z_? (note: not legal C++)<br>
&nbsp; }<br>
};</font></p>

</blockquote>
<p>First, we cannot possibly know whether t_ or z_ were ever allocated, so
neither delete could be safe.</p>
<p>Second, even if we did know that we had reached one of the allocations, we
probably can't destroy *t_ or *z_ because they refer to a Y (and possibly a T)
that no longer exists and they may try to use that Y (and possibly T).
Incidentally, this means that not only can't we destroy *t_ or *z_, but they can
never be destroyed by anyone!</p>
<p>If that didn't just sober you up, it should have. I have seen people write
code similar in spirit to the above, never imagining that they were creating
objects that, should the wrong things happen, could never be destroyed! The good
news is that there's a simple way to avoid the problem: These difficulties would
largely go away if the T* members were auto_ptrs or similar manager objects.</p>
<p>Finally, if Y::~Y() can throw, it is not possible to reliably create an X
object at any time! If you haven't been sobered yet, this should definitely do
it. If Y::~Y() can throw, even writing &quot;X x;&quot; is fraught with peril.
This reinforces the dictum that destructors must never be allowed to emit an
exception under any circumstances, and writing a destructor that could emit an
exception is simply an error. Destruction and emitting exceptions don't mix.</p>
<p>The above side discussion was to help better understand why the rules are as
they are. After all, as noted, you can't even refer to t_ or z_ inside the
handler anyway. I've refrained from quoting standardese elsewhere in this GotW,
so here's your dose... from the C++ standard, clause 15.3, paragraph 10:</p>
<blockquote>
  <p><i>Referring to any non-static member or base class of an object in the
  handler for a function-try-block of a constructor or destructor for that
  object results in undefined behavior.</i></p>
</blockquote>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Some Morals<!--mstheme--></font></h4>
<p>Therefore the status quo can be summarized as follows:</p>
<blockquote>
  <p><b>Moral #1:</b> Constructor function-try-block handlers have only one
  purpose -- to translate an exception. (And maybe to do logging or some other
  side effects.) They are not useful for any other purpose.</p>
  <p><b>Moral #2:</b> Since destructors should never emit an exception,
  destructor function-try-blocks have no practical use at all.<b><a href="#6"><sup>[6]</sup></a></b>
  There should never be anything for them to detect, and even if there were
  something to detect because of evil code, the handler is not very useful for
  doing anything about it because it can not suppress the exception.</p>
  <p><b>Moral #3:</b> Always perform unmanaged resource acquisition in the
  constructor body, never in initializer lists. In other words, either use
  &quot;resource acquisition is initialization&quot; (thereby avoiding unmanaged
  resources entirely) or else perform the resource acquisition in the
  constructor body.</p>
</blockquote>
<p>For example, building on Example 2(b), say T was char and t_ was a plain old
char* that was new[]'d in the initializer-list; then in the handler there would
be no way to delete[] it. The fix would be to instead either wrap the
dynamically allocated memory resource (e.g., change char* to string) or new[] it
in the constructor body where it can be safely cleaned up using a local
try-block or otherwise.</p>
<blockquote>
  <p><b>Moral #4:</b> Always clean up unmanaged resource acquisition in local
  try-block handlers within the constructor or destructor body, never in
  constructor or destructor function-try-block handlers.</p>
  <p><b>Moral #5:</b> If a constructor has an exception specification, that
  exception specification must allow for the union of all possible exceptions
  that could be thrown by base and member subobjects. As Holmes might add,
  &quot;It really must, you know.&quot; (Indeed, this is the way that the
  implicitly generated constructors are declared; see <a href="069.htm">GotW #69</a>.)</p>
  <p><b>Moral #6:</b> If a constructor of a member object can throw but you can
  get along without said member, hold it by pointer and use the pointer's
  nullness to remember whether you've got one or not, as usual. Use the Pimpl
  idiom to group such &quot;optional&quot; members so you only have to allocate
  once.</p>
</blockquote>
<p>And finally, one last moral that overlaps with the above but is worth
restating in its own right:</p>
<blockquote>
  <p><b>Moral #7:</b> Prefer using &quot;resource acquisition is
  initialization&quot; to manage resources. Really, really, really. It will save
  you more headaches than you can probably imagine.</p>
</blockquote>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Justifying the Rules<!--mstheme--></font></h4>
<p>From legality, we now turn to morality:</p>
<p><font color="#999933">Justify your answer, explaining by example why this is
as it should be.</font></p>
<p>In short, the way the language works is entirely correct and easily
defensible, once you think about the meaning of C++'s object lifetime model and
philosophy.</p>
<p>A constructor exception must be propagated, for there is no other way to
signal that the constructor failed. Two cases spring to mind:</p>
<blockquote>

<p><font face="Courier New">// Example 2(c): Auto object<br>
//<br>
{<br>
&nbsp; X x;<br>
&nbsp; g( x ); // do something else<br>
}</font></p>

</blockquote>
<p>If X's construction fails -- whether it's due to X's own constructor body
code, or due to some X base subobject or member object construction failure --
control must not continue within f(). After all, there is no x object! The only
way for control not to continue in f()'s body is to emit an exception. Therefore
a failed construction of an auto object must result in some sort of exception,
whether it be the same exception that caused the base or member subobject
construction failure or some translated exception emitted from an X constructor
function try block.</p>
<p>Similarly:</p>
<blockquote>

<p><font face="Courier New">// Example 2(d): Array of objects<br>
//<br>
{<br>
&nbsp; X ax[10];<br>
&nbsp; // ...<br>
}</font></p>

</blockquote>
<p>If the 5th X object construction fails -- whether it's due to X's own
constructor body code failing, or due to some X base subobject or member object
construction failing -- control must not continue within the scope. After all,
if you tried to continue, you'd end up with an array not all of whose objects
really exist.</p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">A Final Word: Failure-Proof Constructors?<!--mstheme--></font></h4>
<p>We could slyly rephrase Question #2 as follows: Is it possible to write and
enforce an empty throw-specification for a constructor of a class, if some base
or member constructor could throw? After all, to enforce a &quot;throws
nothing&quot; guarantee for any function, we must be able to absorb any possible
exceptions that come our way from lower-level code, to avoid accidentally trying
to emit them to our own caller.</p>
<p>This, not coincidentally, brings us to the final question:</p>
<p><font color="#999933"><b><font size="4">3.</font></b>   What are the minimal
requirements that A and B must meet in order for us to safely put an empty
throw- specification on C's constructor(s)?</font></p>
<p>Now that we've done all the hard work, this one's easy: For a constructor to
have an empty throw-specification, all base and member subobjects must be known
to never throw (whether they have throw-specs that say so or not).</p>
<p>An empty throw-specification on a constructor declares to the world that
construction cannot fail. If for whatever reason it can indeed fail, then the
empty throw-spec isn't appropriate, that's all.</p>

<p>&nbsp;</p>

<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Notes<!--mstheme--></font></h4>
<p><a name="1"></a>1. R. Schmidt. <b><a href="http://msdn.microsoft.com/library/default.asp?URL=/library/welcome/dsmsdn/deep02032000.htm" target="_blank">&quot;Handling Exceptions in C and C++,
Parts 14-16&quot;</a></b>. (The link is to Part 15; you can navigate from there.)</p>
<p><a name="2"></a>2. For simplicity, I'm speaking only of the lifetime of an
object of class type that has a constructor.</p>
<p><a name="3"></a>3. The inventor of the Python programming language?</p>
<p><a name="4"></a>4. H. Sutter. <b><a href="../publications/xc++.htm">Exceptional
C++</a></b> (Addison-Wesley, 2000).</p>
<p><a name="5"></a>5. R. Schmidt. Private correspondence, February 2, 2000.</p>
<p><a name="6"></a>6. Not even for logging or other side effects, because there
shouldn't be any exceptions from base or member subobject destructors and
therefore anything you could catch in a destructor function-try-block could be
caught equally well using a normal try-block inside the destructor body.</p>
<p><a name="7"></a>7. A double pun, can be sung to the chorus of
&quot;Satisfaction&quot; or to the opening bars of &quot;Another Brick in the
Wall, Part N.&quot;</p>
<!--mstheme--></font><!--msnavigation--></td></tr><!--msnavigation--></table><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td><!--mstheme--><font face="Arial, Arial, Helvetica"><h4 align="right"><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666"><a href="../copyright.htm"><font size="2">Copyright ©
2002 Herb Sutter</font></a><!--mstheme--></font></h4>

<!--mstheme--></font></td></tr><!--msnavigation--></table></body>
</html>

