ID=E0253
URL=http://www.gotw.ca/gotw/083.htm
SIZE=40712
DATE=12/07/02
TIME=19:19:12
DATASET=C
HTML=
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta http-equiv="Content-Language" content="en-us">


<title>GotW #83: Style Case Study #2: Generic Callbacks</title>
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<link rel="stylesheet" type="text/css" href="../gotw.css">
<style>
<!--
code         { font-size: 12pt }
-->
</style>
<meta name="Microsoft Theme" content="gotw 111, default">
<meta name="Microsoft Border" content="tlb, default">
</head>

<body background="../_themes/gotw/glabkgnd.jpg" bgcolor="#CCFFFF" text="#000000" link="#008080" vlink="#008080" alink="#0000FF"  ><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font><table border="0" cellspacing="0" width="100%">
  <tr>
    <td colspan="2"><!--mstheme--><font face="Arial, Arial, Helvetica"><font size="6"><strong>
    GotW #83</strong></font> <!--mstheme--></font></td>
  </tr>
  <tr>
    <td valign="middle"><!--mstheme--><font face="Arial, Arial, Helvetica">




<p align="left" style="margin-top: 0; margin-bottom: 0">

<script language="JavaScript"><!--
MSFPhover = 
  (((navigator.appName == "Netscape") && 
  (parseInt(navigator.appVersion) >= 3 )) || 
  ((navigator.appName == "Microsoft Internet Explorer") && 
  (parseInt(navigator.appVersion) >= 4 ))); 
function MSFPpreload(img) 
{
  var a=new Image(); a.src=img; return a; 
}
// --></script><script language="JavaScript"><!--
if(MSFPhover) { MSFPnav1n=MSFPpreload("../_derived/home_cmp_gotw110_hbtn.gif"); MSFPnav1h=MSFPpreload("../_derived/home_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav1'].src=MSFPnav1h.src" onmouseout="if(MSFPhover) document['MSFPnav1'].src=MSFPnav1n.src"><img src="../_derived/home_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Home" align="middle" name="MSFPnav1"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav2n=MSFPpreload("../_derived/news.htm_cmp_gotw110_hbtn.gif"); MSFPnav2h=MSFPpreload("../_derived/news.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../news.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav2'].src=MSFPnav2h.src" onmouseout="if(MSFPhover) document['MSFPnav2'].src=MSFPnav2n.src"><img src="../_derived/news.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="News &amp; Events" align="middle" name="MSFPnav2"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav3n=MSFPpreload("../resources/_derived/index.htm_cmp_gotw110_hbtn.gif"); MSFPnav3h=MSFPpreload("../resources/_derived/index.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../resources/index.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav3'].src=MSFPnav3h.src" onmouseout="if(MSFPhover) document['MSFPnav3'].src=MSFPnav3n.src"><img src="../resources/_derived/index.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Community Resources" align="middle" name="MSFPnav3"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav4n=MSFPpreload("../_derived/consulting.htm_cmp_gotw110_hbtn.gif"); MSFPnav4h=MSFPpreload("../_derived/consulting.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../consulting.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav4'].src=MSFPnav4h.src" onmouseout="if(MSFPhover) document['MSFPnav4'].src=MSFPnav4n.src"><img src="../_derived/consulting.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Consulting Services" align="middle" name="MSFPnav4"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav5n=MSFPpreload("../_derived/presentations.htm_cmp_gotw110_hbtn.gif"); MSFPnav5h=MSFPpreload("../_derived/presentations.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../presentations.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav5'].src=MSFPnav5h.src" onmouseout="if(MSFPhover) document['MSFPnav5'].src=MSFPnav5n.src"><img src="../_derived/presentations.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Presentations" align="middle" name="MSFPnav5"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav6n=MSFPpreload("../publications/_derived/index.htm_cmp_gotw110_hbtn.gif"); MSFPnav6h=MSFPpreload("../publications/_derived/index.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../publications/index.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav6'].src=MSFPnav6h.src" onmouseout="if(MSFPhover) document['MSFPnav6'].src=MSFPnav6n.src"><img src="../publications/_derived/index.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Publications" align="middle" name="MSFPnav6"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav7n=MSFPpreload("_derived/index.htm_cmp_gotw110_hbtn.gif"); MSFPnav7h=MSFPpreload("_derived/index.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="index.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav7'].src=MSFPnav7h.src" onmouseout="if(MSFPhover) document['MSFPnav7'].src=MSFPnav7n.src"><img src="_derived/index.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Guru of the Week" align="middle" name="MSFPnav7"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav8n=MSFPpreload("../conv/_derived/index.htm_cmp_gotw110_hbtn.gif"); MSFPnav8h=MSFPpreload("../conv/_derived/index.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../conv/index.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav8'].src=MSFPnav8h.src" onmouseout="if(MSFPhover) document['MSFPnav8'].src=MSFPnav8n.src"><img src="../conv/_derived/index.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Conversations" align="middle" name="MSFPnav8"></a> <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav9n=MSFPpreload("../_derived/search.htm_cmp_gotw110_hbtn.gif"); MSFPnav9h=MSFPpreload("../_derived/search.htm_cmp_gotw110_hbtn_a.gif"); }
// --></script><a href="../search.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav9'].src=MSFPnav9h.src" onmouseout="if(MSFPhover) document['MSFPnav9'].src=MSFPnav9n.src"><img src="../_derived/search.htm_cmp_gotw110_hbtn.gif" width="140" height="40" border="0" alt="Search GotW.ca" align="middle" name="MSFPnav9"></a>
</p>




    <!--mstheme--></font></td>
    <td valign="middle"><!--mstheme--><font face="Arial, Arial, Helvetica">
      <p style="margin-top: 0; margin-bottom: 0">
      <script language="JavaScript"><!--
if(MSFPhover) { MSFPnav10n=MSFPpreload("../_derived/back_cmp_gotw110_back.gif"); MSFPnav10h=MSFPpreload("../_derived/back_cmp_gotw110_back_a.gif"); }
// --></script><a href="082.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav10'].src=MSFPnav10h.src" onmouseout="if(MSFPhover) document['MSFPnav10'].src=MSFPnav10n.src"><img src="../_derived/back_cmp_gotw110_back.gif" width="100" height="20" border="0" alt="Prev" name="MSFPnav10"></a><br><script language="JavaScript"><!--
if(MSFPhover) { MSFPnav11n=MSFPpreload("../_derived/up_cmp_gotw110_up.gif"); MSFPnav11h=MSFPpreload("../_derived/up_cmp_gotw110_up_a.gif"); }
// --></script><a href="index.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav11'].src=MSFPnav11h.src" onmouseout="if(MSFPhover) document['MSFPnav11'].src=MSFPnav11n.src"><img src="../_derived/up_cmp_gotw110_up.gif" width="100" height="20" border="0" alt="Up" name="MSFPnav11"></a><br><script language="JavaScript"><!--
if(MSFPhover) { MSFPnav12n=MSFPpreload("../_derived/next_cmp_gotw110_next.gif"); MSFPnav12h=MSFPpreload("../_derived/next_cmp_gotw110_next_a.gif"); }
// --></script><a href="084.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav12'].src=MSFPnav12h.src" onmouseout="if(MSFPhover) document['MSFPnav12'].src=MSFPnav12n.src"><img src="../_derived/next_cmp_gotw110_next.gif" width="100" height="20" border="0" alt="Next" name="MSFPnav12"></a><!--mstheme--></font></td>
  </tr>
  <tr>
    <td height="5" background="../images/bar.gif" colspan="2"><!--mstheme--><font face="Arial, Arial, Helvetica">&nbsp;<!--mstheme--></font></td>
  </tr>
</table><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font></td></tr><!--msnavigation--></table><!--msnavigation--><table dir="ltr" border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td valign="top" width="1%"><!--mstheme--><font face="Arial, Arial, Helvetica">

<!--mstheme--></font><table border="0" cellspacing="0" bgcolor="#000000" cellpadding="0">
  <tr>
    <td><!--mstheme--><font face="Arial, Arial, Helvetica">
    <!--mstheme--></font><table border="0" cellpadding="2" cellspacing="1" width="100%" height="483">
        <tr>
          <td align="center" bgcolor="#000000" colspan="2" height="16"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin-top: 0; margin-bottom: 0"><a href="../news.htm"><b><font color="#FFFF00">News</font></b></a><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="center" bgcolor="#CCCCCC" bordercolor="#CCCCCC" rowspan="3"><!--mstheme--><font face="Arial, Arial, Helvetica">
          <font size="1" color="#0000FF">J<br>
          U<br>
          L<br>
          Y</font><!--mstheme--></font></td>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin-left: 3; margin-right: 3; margin-top: 0" align="center"><font size="1" color="#0000FF">
            Print articles newly available online</font><!--mstheme--></font><table border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%" id="AutoNumber1" bgcolor="#FFFFCC" bordercolordark="#006666" bordercolorlight="#99CCCC">
              <tr>
                <td width="100%" bordercolor="#808000"><!--mstheme--><font face="Arial, Arial, Helvetica">
                <p style="margin: 3"><font size="1" color="#0000FF">
                <a href="../publications/mill20.htm"><b><i>
                <font color="#0000FF">Sutter's Mill</font></i></b><font color="#0000FF"> 
                column, &quot;Toward a Standard C++ Library, Part 1&quot;</font></a></font><!--mstheme--></font></td>
              </tr>
              <tr>
                <td width="100%" bordercolor="#808000" bgcolor="#FFFFCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
                <p style="margin: 3"><font size="1" color="#0000FF">
                <a href="../publications/mxc++-item-4.htm">
                <font color="#0000FF">Excerpt from MXC++, &quot;Extensible Templates: 
                Via Inheritance or Traits?&quot;</font></a></font><!--mstheme--></font></td>
              </tr>
              <tr>
                <td width="100%" bordercolor="#808000"><!--mstheme--><font face="Arial, Arial, Helvetica">
                <p style="margin: 3"><font size="1" color="#0000FF">
                <a href="../publications/mcd_review.htm"><font color="#0000FF">
                Book Review: Modern C++ Design</font></a></font><!--mstheme--></font></td>
              </tr>
              <tr>
                <td width="100%" bordercolor="#808000"><!--mstheme--><font face="Arial, Arial, Helvetica">
                <p style="margin: 3"><font size="1" color="#0000FF">
                <a href="../publications/mill21.htm"><b><i>
                <font color="#0000FF">Sutter's Mill</font></i></b><font color="#0000FF"> 
                column, &quot;Toward a Standard C++ Library, Part 2: Namespaceops and 
                Library Versioning&quot;</font></a></font><!--mstheme--></font></td>
              </tr>
            </table><!--mstheme--><font face="Arial, Arial, Helvetica">
          <!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin: 0 3"><font size="1" color="#0000FF"><b><i>Sutter's 
            Mill</i></b> column,
            &quot;A Pragmatic Look at Exception Specifications&quot;<br>
            </font><font size="1" color="#000080">The usefulness, or lack 
            thereof, of exception specifications, and how results can vary 
            across real-world compilers</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin: 0 3">
            <a target="_blank" href="http://www.cuj.com/experts/2007/hyslop.htm"><font size="1" color="#0000FF"><i><b>Conversations</b></i> column,
            &quot;Getting to the Point&quot;</font></a><font color="#0000FF" size="1"><br>
            </font><font size="1" color="#000080">The Boost library has five 
            smart pointers that provide a rich array [sic] of useful behaviors.</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="center" bgcolor="#CCCCCC" bordercolor="#CCCCCC" rowspan="2"><!--mstheme--><font face="Arial, Arial, Helvetica"><font color="#0000FF" size="1">A<br>
            U<br>
          G<br>
          U<br>
          S<br>
          T</font><!--mstheme--></font></td>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin:0 3; ">
            <a target="_blank" href="http://www.cuj.com/experts/2008/sutter.htm"><i><b><font size="1" color="#0000FF">The New C++</font></b></i> <font size="1" color="#0000FF">
            column, &quot;Smart(er) Pointers&quot;</font></a><font size="1" color="#000080"><br>
            A closer look at one of the proposed new standard C++ library 
            features -- smart pointers, particularly those in Boost and Loki, 
            and a sneak peek at the usefulness of the proposed typedef templates</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
          <p style="margin:0 3; ">
          <a target="_blank" href="http://www.cuj.com/experts/2008/hyslop.htm"><font size="1" color="#0000FF"><i><b>Conversations</b></i> column,
            &quot;A Midsummer Night's Madness&quot;</font></a><font color="#0000FF" size="1"><br>
            </font><font size="1" color="#000080">A brew that mixes pointers, 
          typedefs, and const</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="center" bgcolor="#CCCCCC" bordercolor="#CCCCCC" rowspan="3"><!--mstheme--><font face="Arial, Arial, Helvetica">
          <p style="margin-top: 0; margin-bottom: 0">
          <font size="1" color="#0000FF">S<br>
          E<br>
          P<br>
          T<br>
          E<br>
          M<br>
          B<br>
          E<br>
          R</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin: 0 3">
            <font size="1" color="#0000FF">&quot;Standard C++ Meets Managed C++&quot;<br>
            </font><font size="1" color="#000080">A survey of the main (in)compatibilities 
            between Standard C++ and Microsoft’s managed extensions for C++, and 
            how the two could converge</font><!--mstheme--></font></td>
        </tr>
        <tr>
          <td align="left" bgcolor="#FFFF99" bordercolor="#CCCCCC"><!--mstheme--><font face="Arial, Arial, Helvetica">
            <p style="margin: 0 3"><font size="1" color="#0000FF"><b><i>Sutter's 
            Mill</i></b> column,
            &quot;Export Restrictions, Part 1&quot;<br>
            </font><font size="1" color="#000080">The scoop on export -- what 
            some people think it does, what it actually does, and why it’s the 
            most widely-ignored feature in the C++ standard</font><!--mstheme--></font></td>
        </tr>
      </table><!--mstheme--><font face="Arial, Arial, Helvetica"><!--mstheme--></font></td>
  </tr>
</table><!--mstheme--><font face="Arial, Arial, Helvetica">
<p style="margin-top: 0; margin-bottom: 0">
<img border="0" src="../images/140.gif" width="140" height="1"></p>

<!--mstheme--></font></td><td valign="top" width="24"></td><!--msnavigation--><td valign="top"><!--mstheme--><font face="Arial, Arial, Helvetica"><h2><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Style Case Study #2: Generic Callbacks<font size="3"><br>
      Difficulty: 5 / 10</font><!--mstheme--></font></h2>
<p align="left"><i>Part of the allure of generic code is its usability and
reusability in as many kinds of situations as reasonably possible. How can the
simple facility presented in the cited article be stylistically improved, and how can
it be made more useful than it is and really qualify as generic and
widely-usable code?</i></p>
<p align="center"><img border="0" src="../images/h-line.gif" width="248" height="2"></p>
<h3><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Problem<!--mstheme--></font></h3>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">JG Question<!--mstheme--></font></h4>
<p style="margin-top: 0; margin-bottom: 6"><b><font size="4">1.</font></b>  What
qualities are desirable in designing and writing generic facilities? Explain.</p>
<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Guru Question<!--mstheme--></font></h4>
<p style="margin-top: 0; margin-bottom: 6"><b><font size="4">2.</font></b> The
following code presents an interesting and genuinely useful idiom for wrapping
callback functions. For a more detailed explanation, see the original article.<a href="#references">[1]</a></p>
<p style="margin-top: 0; margin-bottom: 6">Critique this code and identify:</p>
<blockquote>
<p style="margin-top: 0; margin-bottom: 12">a) Stylistic choices that could be
improved to make the design better for more idiomatic C++ usage.</p>
<p style="margin-top: 0; margin-bottom: 12">b) Mechanical limitations that
restrict the usefulness of the facility.</p>
<p style="margin-top: 0; margin-bottom: 6"><font face="Courier New">template
&lt; class T, void (T::*F)() &gt;<br>
class callback<br>
{<br>
public:<br>
&nbsp; callback(T&amp; t) : object(t) {} // assign actual object to T<br>
&nbsp; void execute() {(object.*F)();}// launch callback function<br>
private:<br>
&nbsp; T&amp; object;<br>
};</font></p>
</blockquote>
<p align="left">(For an idea of the kinds of things I'm looking for, see also <a href="073.htm">Style
Case Study #1</a>.)</p>
<p align="center"><img border="0" src="../images/h-line.gif" width="248" height="2"></p>
<h3><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666"><a name="Solution"></a>Solution<!--mstheme--></font></h3>

<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">JG Question<!--mstheme--></font></h4>
<p style="margin-top: 0; margin-bottom: 6"><font color="#808000"><b><font size="4">1.</font></b>  What
qualities are desirable in designing and writing generic facilities? Explain.</font></p>
<p style="margin-top: 0; margin-bottom: 6">Generic code should above all be
usable. That doesn't mean it has to include all options up to and including the
kitchen sink. What it does mean is that generic code ought to make a reasonable
and balanced effort to avoid at least three things:</p>

<p style="margin-top: 0; margin-bottom: 6"><b>a) Avoid undue type restrictions.</b></p>
<p style="margin-top: 0; margin-bottom: 6">For example, are you writing a
generic container? Then it's perfectly reasonable to require that the contained
type have, say, a copy constructor and a nonthrowing destructor. But what about
a default constructor, or an assignment operator? Many useful types that users
might want to put into our container don't have a default constructor, and if
our container uses it then we've eliminated such a type from being used with our
container. That's not very generic. (For a complete example, see Item 15 of <i>Exceptional
C++</i>. [2])</p>
<p style="margin-top: 0; margin-bottom: 6"><b>b) Avoid undue functional
restrictions.</b></p>
<p style="margin-top: 0; margin-bottom: 6">If you're writing a facility that
does X and Y, then what if some user wants to do Z, and Z isn't so much
different from Y? Sometimes you'll want to make your facility flexible enough to
support Z; sometimes you won't. Part of good generic design is choosing the ways
and means by which your facility can be customized or extended. That this is
important in generic design should hardly be a surprise, though, because the
same principle applies to object-oriented class design.</p>
<p style="margin-top: 0; margin-bottom: 6">Policy-based design is one of several
important techniques that allow &quot;pluggable&quot; behavior with generic
code. For examples of policy-based design, see any of several chapters in
Alexandrescu's <i>Modern C++ Design</i> [3]; the SmartPtr and Singleton chapters
are a good place to start.&nbsp;</p>
<p style="margin-top: 0; margin-bottom: 6">This leads to a related issue:</p>
<p style="margin-top: 0; margin-bottom: 6"><b>c) Avoid unduly monolithic designs.</b></p>
<p style="margin-top: 0; margin-bottom: 6">I'll break out discussion of this
third item to a separate GotW #84. The issue of &quot;unduly monolithic
designs&quot; doesn't arise as directly in our style example under consideration
below, and it deserves some dedicated consideration in its own right, hence it
gets its own article.</p>
<p style="margin-top: 0; margin-bottom: 6">Above, you'll note the recurring word
&quot;undue.&quot; That means just what it says: Good judgment is needed when
deciding where to draw the line between failing to be sufficiently generic (the
&quot;I'm sure nobody would want to use it with anything but char&quot;
syndrome) on the one hand, and overengineering (the &quot;what if someday some
wants to use this toaster-oven LED display routine to control the booster cutoff
on an interplanetary spacecraft?&quot; misguided fantasy) on the other.</p>

<h4><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Guru Question<!--mstheme--></font></h4>
<p style="margin-top: 0; margin-bottom: 6"><font color="#808000"><b><font size="4">2.</font></b> The
following code presents an interesting and genuinely useful idiom for wrapping
callback functions. For a more detailed explanation, see the original article.<a href="#references">[1]</a></font></p>

<p style="margin-top: 0; margin-bottom: 6">Here again is the code:</p>

<blockquote>
<p style="margin-top: 0; margin-bottom: 6"><font face="Courier New" color="#808000">template
&lt; class T, void (T::*F)() &gt;<br>
class callback<br>
{<br>
public:<br>
&nbsp; callback(T&amp; t) : object(t) {} // assign actual object to T<br>
&nbsp; void execute() {(object.*F)();}// launch callback function<br>
private:<br>
&nbsp; T&amp; object;<br>
};</font></p>
</blockquote>
<p style="margin-top: 0; margin-bottom: 6">Now, really, how many ways are there
to go wrong in a simple class with just two one-liner member functions? Well, as
it turns out, its extreme simplicity is part of the problem. This class template
doesn't need to be heavyweight, not at all, but it could stand to be a little
less lightweight.</p>

<p style="margin-top: 0; margin-bottom: 6">&nbsp;</p>
<p style="margin-top: 0; margin-bottom: 6"><font color="#808000">Critique this code and identify:</font></p>
<blockquote>
<p style="margin-top: 0; margin-bottom: 12"><font color="#808000">a) Stylistic choices that could be
improved to make the design better for more idiomatic C++ usage.</font></p>
</blockquote>
<p style="margin-top: 0; margin-bottom: 6">How many did you spot? Here's what I
came up with:</p>

<p style="margin-top: 0; margin-bottom: 6">&nbsp;</p>

<p style="margin-top: 0; margin-bottom: 6"><b>The constructor should be explicit.</b></p>
<p style="margin-top: 0; margin-bottom: 6">The author probably didn't mean to
provide an implicit conversion from T to callback&lt;T&gt;. Well-behaved classes
avoid creating the potential for such problems for their users. So what we
really want is more like this:</p>
<blockquote>
<p style="margin-top: 0; margin-bottom: 6"><font face="Courier New" color="#808000">
&nbsp; </font><font face="Courier New" color="#0000FF">explicit</font><font face="Courier New" color="#808000">
</font><font face="Courier New">callback(T&amp; t) : object(t) {}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// assign actual object to T</font></p>
</blockquote>
<p style="margin-top: 0; margin-bottom: 6">While we're already looking at this
particular line, there's another stylistic issue that's not about the design <i>per
se</i>, but about the description:</p>
<p style="margin-top: 0; margin-bottom: 6">&nbsp;</p>
<p style="margin-top: 0; margin-bottom: 6"><b>(Nit) The comment is wrong.</b></p>
<p style="margin-top: 0; margin-bottom: 6">The word &quot;assign&quot; in the
comment is incorrect and so somewhat misleading. More correctly, in the
constructor we're &quot;binding&quot; a T object to the reference, and by
extension to the callback object. Also, after many rereadings I'm still not sure
what the &quot;to T&quot; part means. So better still would be &quot;bind actual
object.&quot;</p>
<blockquote>
  <p style="margin-top: 0; margin-bottom: 6"><font face="Courier New">
&nbsp; explicit callback(T&amp; t) : object(t) {} // </font><font face="Courier New" color="#0000FF">bind</font><font face="Courier New" color="#808000">
  </font><font face="Courier New"> actual object</font></p>
</blockquote>
<p style="margin-top: 0; margin-bottom: 6">But then all that comment is saying
is what the code already says, which is faintly ridiculous and a stellar example
of a useless comment, so best of all would be:</p>
<blockquote>
  <p style="margin-top: 0; margin-bottom: 6"><font face="Courier New">&nbsp; explicit callback(T&amp; t) : object(t) {}</font></p>
</blockquote>

<p style="margin-top: 0; margin-bottom: 6">&nbsp;</p>

<p style="margin-top: 0; margin-bottom: 6"><b>The execute() function should be
const.</b></p>
<p style="margin-top: 0; margin-bottom: 6">The execute() function isn't doing
anything to the callback&lt;T&gt; object's state, after all! This is a
&quot;back to basics&quot; issue: Const-correctness may be an oldie, but it's a
goodie. The value of const-correctness has been known in C and C++ since at
least the early 1980s, and that value didn't just evaporate when we clicked over
to the new millennium and started writing lots of templates.</p>
<blockquote>
  <p style="margin-top: 0; margin-bottom: 6"><font face="Courier New">
&nbsp; void execute() {(object.*F)();} </font><font face="Courier New" color="#0000FF">const</font><font face="Courier New" color="#FF0000"><br>
  </font><font face="Courier New"><font color="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  </font>// launch callback function
  </font></p>
</blockquote>
<p style="margin-top: 0; margin-bottom: 6">While we're already beating on the
poor execute() function, there's an arguably more serious idiomatic problem:</p>
<p style="margin-top: 0; margin-bottom: 6">&nbsp;</p>
<p style="margin-top: 0; margin-bottom: 6"><b>(Idiom) And t</b></p>
<p style="margin-top: 0; margin-bottom: 6">In C++, it's idiomatic to use the
function-call operator for executing a function-style operation. Indeed, then
the comment, already somewhat redundant, becomes completely so and can be
removed without harm because now our code is already idiomatically commenting
itself. To wit:</p>
<blockquote>
  <p style="margin-top: 0; margin-bottom: 6"><font face="Courier New">
&nbsp; void</font><font face="Courier New" color="#808000"> </font><font face="Courier New" color="#0000FF">operator()</font><font face="Courier New">() const
  {(object.*F)();}</font></p>
</blockquote>
<p style="margin-top: 0; margin-bottom: 6">&quot;But,&quot; you might be
wondering, &quot;if we provide the function-call operator, then isn't this some
kind of function object?&quot; That's an excellent point, which leads us to
observe that, as a function object, maybe callback instances ought to be
adaptable too:</p>
<p style="margin-top: 0; margin-bottom: 6">&nbsp;</p>
<p style="margin-top: 0; margin-bottom: 6"><b>Pitfall: (Idiom) Should this
callback should be derived from std::unary_function?</b></p>
<p style="margin-top: 0; margin-bottom: 6">See Item 40 in Meyers' <i>Effective
STL</i> [4] for a more detailed discussion about adaptability and why it's a
Good Thing in general. Alas, here, there are two excellent reasons why callback
should not be derived from std::unary_function, at least not yet:</p>
<!--mstheme--></font><!--msthemelist--><table border="0" cellpadding="0" cellspacing="0" width="100%">
  <!--msthemelist--><tr><td valign="baseline" width="42"><img src="../_themes/gotw/aglabul1.gif" width="15" height="15" hspace="13" alt="bullet"></td><td valign="top" width="100%"><!--mstheme--><font face="Arial, Arial, Helvetica">
    <p style="margin-top: 0; margin-bottom: 6"><i>It's not a unary function.</i>
    It takes no parameter, and unary functions take a parameter. (No,
    &quot;void&quot; doesn't count.)<!--mstheme--></font><!--msthemelist--></td></tr>
  <!--msthemelist--><tr><td valign="baseline" width="42"><img src="../_themes/gotw/aglabul1.gif" width="15" height="15" hspace="13" alt="bullet"></td><td valign="top" width="100%"><!--mstheme--><font face="Arial, Arial, Helvetica">
    <p style="margin-top: 0; margin-bottom: 6"><i>Deriving from
    std::unary_function isn't </i> Later
    on, we're going to see that callback perhaps ought to work with other kinds
    of function signatures too, and depending on the number of parameters
    involved, there may well be no standard base class to derive from. For
    example, if we supported callback functions with three parameters, we have
    no std::ternary_function to derive from.<!--mstheme--></font><!--msthemelist--></td></tr>
<!--msthemelist--></table><!--mstheme--><font face="Arial, Arial, Helvetica">
<p style="margin-top: 0; margin-bottom: 6">Deriving from std::unary_function or
std::binary_function is a convenient way to give callback a handful of important
typedefs that binders and similar facilities often rely upon, but it only
matters if you're going to use the function objects with those facilities.
Because of the nature of these callbacks and how they're intended to be used,
it's unlikely that this will be needed. (If in the future it turns out that they
ought to be usable this way for the common one- and two-parameter cases, then
the one- and two-parameter versions we'll mention later can be derived from
std::unary_function and std::binary_function, respectively.)</p>
<p style="margin-top: 0; margin-bottom: 6">&nbsp;</p>
<blockquote>
<p style="margin-top: 0; margin-bottom: 12"><font color="#808000">b) Mechanical limitations that
restrict the usefulness of the facility.</font></p>
</blockquote>
<p style="margin-top: 0; margin-bottom: 6"><b>Consider making the callback
function a normal parameter, not a template parameter.</b></p>
<p style="margin-top: 0; margin-bottom: 6">Non-type template parameters are rare
in part because there's rarely much benefit in so strictly fixing a type at
compile time. That is, we could instead have:</p>
<blockquote>
  <p style="margin-top: 0; margin-bottom: 6"><font face="Courier New">template &lt; class T ><br>
  class callback<br>
  {<br>
  public:<br>
  <font color="#0000FF">&nbsp; typedef void (T::*Func)();<br>
  </font><br>
  &nbsp; callback( T&amp; t<font color="#0000FF">, Func func</font> ) : object(t)<font color="#0000FF">,
  f(func)</font> { }<br>
  &nbsp; void operator()() { (object.*<font color="#0000FF">f</font>)(); }<br>
  <br>
  private:<br>
  &nbsp; T&amp; object;<br>
  <font color="#0000FF">&nbsp; Func f;<br>
  </font>};</font></p>
</blockquote>
<p style="margin-top: 0; margin-bottom: 6">Now the function to be used can vary
at runtime, and it would be simple to add a member function that allowed the
user to change the function that an existing callback object was bound to,
something not possible in previous versions of the code.</p>
<blockquote>
  <p style="margin-top: 0; margin-bottom: 6"><b>Guideline:<br>
  </b>
  It's usually a good idea to prefer making non-type parameters into normal
  function parameters, unless they really need to be template parameters.</p>
</blockquote>
<p style="margin-top: 0; margin-bottom: 6">&nbsp;</p>
<p style="margin-top: 0; margin-bottom: 6"><b>Containerization</b></p>
<p style="margin-top: 0; margin-bottom: 6">If a program wants to keep one
callback object for later use, it's likely to want to keep more of them. What if
it wants to put the callback objects into a container, like a vector or a list?
Currently that's not possible, because callback objects aren't assignable --
they don't support operator=(). Why not? Because they contain a reference, and
once that reference is bound during construction it can never be rebound to
something else.</p>
<p style="margin-top: 0; margin-bottom: 6">Pointers, however, have no such
compunction, and are quite happy to point at whatever you'd ask them to. In this
case it's perfectly safe for callback instead to store a pointer, not a
reference, to the object it's to be called on, and then to use the default
compiler-generated copy constructor and copy assignment operator:</p>
<blockquote>
<p style="margin-top: 0; margin-bottom: 6"><font face="Courier New">template &lt; class T ><br>
class callback<br>
{<br>
public:<br>
&nbsp; typedef void (T::*Func)();<br>
<br>
&nbsp; callback( T&amp; t, Func func ) : object(<font color="#0000FF">&amp;</font>t),
f(func) { }<br>
&nbsp;  void operator()() { (object<font color="#0000FF">-&gt;</font>*f)(); }<br>
<br>
private:<br>
&nbsp; T<font color="#0000FF">*</font> object;<br>
&nbsp; Func f;<br>
};</font></p>
</blockquote>
<p style="margin-top: 0; margin-bottom: 6">Now it's possible to have, for
example, a list&lt; callback&lt; Widget, &amp;Widget::SomeFunc &gt; &gt;.</p>
<p style="margin-top: 0; margin-bottom: 6">&quot;But wait,&quot; you might
wonder at this point, &quot;if I could have that kind of a list, why couldn't I
have a list of arbitrary kinds of callbacks of various types, so that I can
remember them all, and go execute them all when I want to?&quot; Indeed, you
can, if you add a base class:</p>
<p style="margin-top: 0; margin-bottom: 6">&nbsp;</p>
<p style="margin-top: 0; margin-bottom: 6"><b>Provide a common base class for
callback types.</b></p>
<p style="margin-top: 0; margin-bottom: 6">If we want to let users have a
list&lt;callbackbase*&gt;, we can do it by providing just such a base class,
which by default happens to do nothing in its operator()():</p>
<blockquote>
<p style="margin-top: 0; margin-bottom: 6"><font face="Courier New" color="#0000FF">class
callbackbase<br>
{<br>
public:<br>
&nbsp; virtual void operator()() const { };<br>
&nbsp; virtual ~callbackbase() = 0;<br>
};<br>
<br>
callbackbase::~callbackbase() { }<br>
<br>
</font><font face="Courier New">template &lt; class T ><br>
class callback </font><font face="Courier New" color="#0000FF">:
public callbackbase</font><font face="Courier New"><br>
{<br>
public:<br>
&nbsp; typedef void (T::*Func)();<br>
<br>
&nbsp; callback( T&amp; t, Func func ) : object(&amp;t), f(func) { }<br>
&nbsp;  void operator()() const { (object-&gt;*f)(); }<br>
<br>
private:<br>
&nbsp; T* object;<br>
&nbsp;  Func f;<br>
};</font></p>
</blockquote>
<p style="margin-top: 0; margin-bottom: 6">Now anyone who wants to can keep a
list&lt;callbackbase*&gt; and polymorphically invoke operator()() on its
elements. Of course, a list&lt;boost::shared_ptr&lt;callback&gt; &gt; would be
even better.</p>
<p style="margin-top: 0; margin-bottom: 6">Note that adding a base class is a
tradeoff, but only a small one: We've added the overhead of a second
indirection, namely a virtual function call, when the callback is triggered
through the base interface. But that overhead only actually manifests <i>when
you use the base interface</i>. Code that doesn't need the base interface
doesn't pay for it.</p>
<p style="margin-top: 0; margin-bottom: 6">&nbsp;</p>
<p style="margin-top: 0; margin-bottom: 6"><b>(Idiom, Tradeoff) There could be a
helper make_callback function to aid in type deduction.</b></p>
<p style="margin-top: 0; margin-bottom: 6">After a while, users may get tired of
explicitly specifying template parameters for temporary objects:</p>
<blockquote>
  <p style="margin-top: 0; margin-bottom: 6"><font face="Courier New">  list&lt; callback&lt; Widget > >
  l;<br>
  l.push_back( <font color="#FF0000">callback&lt;Widget&gt;( w,
  &amp;Widget::SomeFunc )</font> );</font></p>
</blockquote>
<p style="margin-top: 0; margin-bottom: 6">Why write Widget twice? Doesn't the
compiler know? Well, no, it doesn't, but we can help it to know. in contexts
where only a temporary object like this is needed. Instead, we could provide a
helper so that they need only type:</p>
<blockquote>
  <p style="margin-top: 0; margin-bottom: 6"><font face="Courier New">  list&lt; callback&lt; Widget > >
  l;<br>
  l.push_back( <font color="#0000FF"> make_callback( w, &amp;Widget::SomeFunc )</font> );</font></p>
</blockquote>
<p style="margin-top: 0; margin-bottom: 6">This make_callback works just like
the standard make_pair(). The missing make_callback() helper should be a function
template, because that's the only kind of template for which compiler can deduce
types. Here's what the helper looks like:</p>
<blockquote>
  <p style="margin-top: 0; margin-bottom: 6"><font face="Courier New" color="#0000FF">template&lt;typename T ><br>
  callback&lt;T> make_callback( T&amp; t, void (T::*f) () )<br>
  {<br>
  &nbsp; return callback&lt;T>( t, f );<br>
  }</font></p>
</blockquote>

<p style="margin-top: 0; margin-bottom: 6">&nbsp;</p>

<p style="margin-top: 0; margin-bottom: 6"><b>(Tradeoff) Add support for other
callback signatures.</b></p>
<p style="margin-top: 0; margin-bottom: 6">I've left the biggest job for last.
As the Bard might have put it, &quot;There are more function signatures in
heaven and earth, Horatio, than are dreamt of in your void (T::*F) ()!&quot;</p>

<p style="margin-top: 0; margin-bottom: 6">If enforcing that signature for
callback functions is sufficient, then by all means stop right there. There's no
sense in complicating a design if we don't need to&nbsp; -- for complicate it we
will, if we want to allow for more function signatures!</p>

<p style="margin-top: 0; margin-bottom: 6">I won't write out all the code,
because it's significantly tedious. (If you really want to see code this
repetitive, or are having trouble with insomnia, see books and articles like [3]
for similar examples.) What I will do is briefly sketch the main things you'd
have to support, and how you'd have to support them:</p>

<p style="margin-top: 0; margin-bottom: 6">First, what about const member
functions? The easiest way to deal with this one is to provide a parallel
callback that uses the const signature type, and in that version remember to
take and hold the T by reference or pointer to const.</p>

<p style="margin-top: 0; margin-bottom: 6">Second, what about non-void return
types? The simplest way to allow the return type to vary is by adding another
template parameter.</p>

<p style="margin-top: 0; margin-bottom: 6">Third, what about callback functions
that take parameters? Again, add template parameters, remember to add parallel
function parameters to operator()(), and stir well. Remember to add a new
template to handle each potential number of callback arguments.</p>
<p style="margin-top: 0; margin-bottom: 6">Alas, the code explodes, and you have
to do things like set artificial limits on the number of function parameters
that callback supports. Perhaps in a future C++0x language we'll have features
like template &quot;varargs&quot; that will help to deal with this, but not
today.</p>

<p style="margin-top: 0; margin-bottom: 6">&nbsp;</p>

<h4 style="margin-top: 0; margin-bottom: 6"><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666">Summary<!--mstheme--></font></h4>

<p style="margin-top: 0; margin-bottom: 6">Putting it all together, and making
some purely stylistic adjustments like using &quot;typename&quot; consistently
and naming conventions and whitespace conventions that I happen to like better,
here's what we get:</p>

<blockquote>
<p style="margin-top: 0; margin-bottom: 6"><font face="Courier New">class
CallbackBase<br>
{<br>
public:<br>
&nbsp; virtual void operator()() const { };<br>
&nbsp; virtual ~CallbackBase() = 0;<br>
};<br>
<br>
CallbackBase::~CallbackBase() { }<br>
<br>
template&lt;typename T><br>
class Callback : public CallbackBase<br>
{<br>
public:<br>
&nbsp; typedef void (T::*F)();<br>
<br>
&nbsp; Callback( T&amp; t, F f ) : t_(&amp;t), f_(f) { }<br>
&nbsp;  void operator()() const { (t_-&gt;*f_)(); }<br>
<br>
private:<br>
&nbsp; T* t_;<br>
&nbsp; F&nbsp; f_;<br>
};<br>
<br>
template&lt;typename T><br>
Callback&lt;T> make_callback( T&amp; t, void (T::*f) () )<br>
{<br>
&nbsp; return Callback&lt;T>( t, f );<br>
}
</font></p>
</blockquote>
<p style="margin-top: 0; margin-bottom: 6">&nbsp;</p>

<h3><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666"><a name="References"></a>References<!--mstheme--></font></h3>
<p style="margin-top: 0; margin-bottom: 6">[1] D. Kalev. &quot;<a href="../publications/xc++s/dk_callbacks.htm" target="_blank">Designing
a Generic Callback Dispatcher</a>&quot; (DevX).<p style="margin-top: 0; margin-bottom: 6">[2]
H. Sutter, <i><b><a href="../publications/xc++.htm">Exceptional C++</a></b></i>
(Addison-Wesley, 2000).<p style="margin-top: 0; margin-bottom: 6">[3] A.
Alexandrescu. <i>Modern C++ Design</i> (Addison-Wesley, 2001).<p style="margin-top: 0; margin-bottom: 6">[4]
S. Meyers. <i>Effective STL</i> (Addison-Wesley, 2001).<!--mstheme--></font><!--msnavigation--></td></tr><!--msnavigation--></table><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td><!--mstheme--><font face="Arial, Arial, Helvetica"><h4 align="right"><!--mstheme--><font face="Verdana, Arial, Helvetica" color="#006666"><a href="../copyright.htm"><font size="2">Copyright ©
2002 Herb Sutter</font></a><!--mstheme--></font></h4>

<!--mstheme--></font></td></tr><!--msnavigation--></table></body>
</html>

