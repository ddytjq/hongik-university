ID=E0271
URL=http://www.research.att.com/~bs/3rd_long_tbl.html
SIZE=31224
DATE=12/07/02
TIME=19:19:26
DATASET=C
HTML=<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.0//EN">
<HTML>
<HEAD>

<TITLE>Table of Contents</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<H2><H1><a href ="3rd.html">The C++ Programming Language, Third Edition and Special Edition </a></H1></H2>
<H3><H2> <a href="homepage.html">Bjarne Stroustrup</a></H2></H3><BR>
<P>
<H3>Table of Contents</H3><HR>

</P>
<B><A HREF="3rd_pref.html">Preface </A><P>
<B><A HREF="2nd_pref.html">Preface to Second Edition</A><P>
<B><A HREF="1st_pref.html">Preface Preface to First Edition</A><P>
Contents<P>
<P>

</P>
Introductory Material: ... pg 1</B>

	<BLOCKQUOTE><A HREF="3rd_notes.pdf">1  Notes to the Reader</A><BR>
	<BLOCKQUOTE>1.1	The Structure of This Book<BR>
	<BLOCKQUOTE>1.1.1	Examples and References<BR>
	1.1.2	Exercises<BR>
	1.1.3	Implementation Note</BLOCKQUOTE>
	1.2	Learning C++<BR>
	1.3	The Design of C++<BR>
	<BLOCKQUOTE>1.3.1	Efficiency and Structure<BR>
	1.3.2	Philosophical Note</BLOCKQUOTE>
	1.4	Historical Note<BR>
	1.5	Use of C++<BR>
	1.6	C and C++<BR>
	<BLOCKQUOTE>1.6.1	Suggestions for C Programmers<BR>
	1.6.2	Suggestions for C++ Programmers</BLOCKQUOTE>
	1.7	Thinking about Programming in C++<BR>
	1.8	Advice<BR>
	<BLOCKQUOTE>1.8.1	References</BLOCKQUOTE></BLOCKQUOTE>

	<A HREF="3rd_tour.pdf">2  A Tour of C++</A><BR>
	<BLOCKQUOTE>2.1	What is C++<BR>
	2.2	Programming Paradigms<BR>
	2.3	Procedural Programming<BR>
	<BLOCKQUOTE>2.3.1	Variables and Arithmetic<BR>
	2.3.2	Tests and Loops<BR>
	2.3.3	Pointers and Arrays</BLOCKQUOTE>
	2.4	Modular Programming<BR>
	<BLOCKQUOTE>2.4.1	Separate Compilation<BR>
	2.4.2	Exception Handling</BLOCKQUOTE>
	2.5	Data Abstraction<BR>
	<BLOCKQUOTE>2.5.1	Modules Defining Types<BR>
	2.5.2	User-Defined Types<BR>
	2.5.3	Concrete Types<BR>
	2.5.4	Abstract Types<BR>
	2.5.5	Virtual Functions</BLOCKQUOTE>
	2.6	Object-Oriented Programming<BR>
	<BLOCKQUOTE>2.6.1	Problems with Concrete Types<BR>
	2.6.2	Class Hierarchies</BLOCKQUOTE>
	2.7	Generic Programming<BR>
	<BLOCKQUOTE>2.7.1	Containers<BR>
	2.7.2		Generic Algorithms</BLOCKQUOTE>
	2.8	Postscript<BR>
	2.9	Advice</BLOCKQUOTE>

	<A HREF="3rd_tour2.pdf">3  A Tour of the Standard Library</A></BLOCKQUOTE>
	<BLOCKQUOTE>3.1	Introduction<BR>
	3.2	Hello, world!<BR>
	3.3	The Standard Library Namespace<BR>
	3.4	Output<BR>
	3.5	Strings<BR>
	<BLOCKQUOTE>3.5.1	C-Style Strings</BLOCKQUOTE>
	3.6	Input<BR>
	3.7	Containers<BR>
	<BLOCKQUOTE>3.7.1	Vector<BR>
	3.7.2	Range Checking<BR>
	3.7.3	List<BR>
	3.7.4	Map<BR>
	3.7.5	Standard Containers</BLOCKQUOTE>
	3.8	Algorithms<BR>
	<BLOCKQUOTE>3.8.1	Use of Iterators<BR>
	3.8.2	Iterator Types<BR>
	3.8.3	Iterators and I/O<BR>
	3.8.4	Traversals and Predicates<BR>
	3.8.5	Algorithms Using Member Functions<BR>
	3.8.6	Standard Library Algorithms</BLOCKQUOTE>
	3.9	Math<BR>
	<BLOCKQUOTE>3.9.1	Complex Numbers
	3.9.2	Vector Arithmetic<BR>
	3.9.3	Basic Numeric Support</BLOCKQUOTE>
	3.10	Standard Library Facilities<BR>
	3.11	Advice</BLOCKQUOTE>


<P>

</P>
<B>Part I: Basic Facilities ... pg 67
</B>
	<BLOCKQUOTE>4  Types and Declarations<BR>
	<BLOCKQUOTE>4.1	Types<BR>
	<BLOCKQUOTE>4.1.1	Fundamental Types</BLOCKQUOTE>
	4.2	Booleans<BR>
	4.3	Character Types<BR>
	<BLOCKQUOTE>4.3.1	Character Literals</BLOCKQUOTE>
	4.4	Integer Types<BR>
	<BLOCKQUOTE>4.4.1	Integer Literals</BLOCKQUOTE>
	4.5	Floating-Point Types<BR>
	<BLOCKQUOTE>4.5.1	Floating-Point Literals</BLOCKQUOTE>
	4.6	Sizes<BR>
	4.7	Void<BR>
	4.8	Enumerations<BR>
	4.9	Declarations<BR>
	<BLOCKQUOTE>4.9.1	The Structure of a Declaration<BR>
	4.9.2	Declaring Multiple Names<BR>
	4.9.3	Names<BR>
	4.9.4	Scope<BR>
	4.9.5	Initialization<BR>
	4.9.6	Objects and Lvalues<BR>
	4.9.7	Typedef</BLOCKQUOTE>
	4.10	Advice<BR>
	4.11	Exercises</BLOCKQUOTE>    

	5  Pointers, Arrays, and Structures<BR>
	<BLOCKQUOTE>5.1	Pointers<BR>
	<BLOCKQUOTE>5.1.1	Zero</BLOCKQUOTE>
	5.2	Arrays<BR>
	<BLOCKQUOTE>5.2.1	Array Initializers
	5.2.2	String Literals</BLOCKQUOTE>
	5.3	Pointers into Arrays<BR>
	<BLOCKQUOTE>5.3.1	Navigating Arrays</BLOCKQUOTE>
	5.4	Constants<BR>
	<BLOCKQUOTE>5.4.1	Pointers and Constants</BLOCKQUOTE>
	5.5	References<BR>
	5.6	Pointer to Void<BR>
	5.7	Structures<BR>
	<BLOCKQUOTE>5.7.1	Type Equivalence</BLOCKQUOTE>
	5.8	Advice<BR>
	5.9	Exercises</BLOCKQUOTE>  

	6  Expressions and Statements<BR>
	<BLOCKQUOTE>6.1	A Desk Calculator<BR>
	<BLOCKQUOTE>6.1.1	The Parser<BR>
	6.1.2	The Input Function<BR>
	6.1.3	Low-level Input<BR>
	6.1.4	Error Handling<BR>
	6.1.5	The Driver<BR>
	6.1.6	Headers<BR>
	6.1.7	Command-Line Arguments<BR>
	6.1.8	A Note on Style</BLOCKQUOTE>
	6.2	Operator Summary<BR>
	<BLOCKQUOTE>6.2.1	Results<BR>
	6.2.2	Evaluation Order<BR>
	6.2.3	Operator Precedence<BR>
	6.2.4	Bitwise Logical Operators<BR>
	6.2.5	Increment and Decrement<BR>
	6.2.6	Free Store<BR>
	<BLOCKQUOTE>6.2.6.1	Arrays<BR>
	6.2.6.2	Memory Exhaustion</BLOCKQUOTE>
	6.2.7	Explicit Type Conversion<BR>
	6.2.8	Constructors</BLOCKQUOTE>
	6.3	Statement Summary<BR>
	<BLOCKQUOTE>6.3.1	Declarations as Statements<BR>
	6.3.2	Selection Statements<BR>
	<BLOCKQUOTE>6.3.2.1	Declarations in Conditions</BLOCKQUOTE>
	6.3.3	Iteration Statements<BR>
	<BLOCKQUOTE>6.3.3.1	Declarations in For-Statements</BLOCKQUOTE>
	6.3.4	Goto</BLOCKQUOTE>
	6.4	Comments and Indentation<BR>
	6.5	Advice<BR>
	6.6	Exercises</BLOCKQUOTE>

	7  Functions<BR>
	<BLOCKQUOTE>7.1	Function Declarations<BR>
	<BLOCKQUOTE>7.1.1	Function Definitions<BR>
	7.1.2	Static Variables</BLOCKQUOTE>
	7.2	Argument Passing<BR>
	<BLOCKQUOTE>7.2.1	Array Arguments</BLOCKQUOTE>
	7.3	Value Return<BR>
	7.4	Overloaded Function Names<BR>
	<BLOCKQUOTE>7.4.1	Overloading and Return Type<BR>
	7.4.2	Overloading and Scopes<BR>
	7.4.3	Manual Ambiguity Resolution<BR>
	7.4.4	Resolution for Multiple Arguments</BLOCKQUOTE>
	7.5	Default Arguments<BR>
	7.6	Unspecified Number of Arguments<BR>
	7.7	Pointer to Function<BR>
	7.8	Macros<BR>
	<BLOCKQUOTE>7.8.1	Conditional Compilation</BLOCKQUOTE>
	7.9	Advice<BR>
	7.10	Exercises</BLOCKQUOTE>

	8  Namespaces and Exceptions<BR>
	<BLOCKQUOTE>8.1	Modularization and Interfaces<BR>
	8.2	Namespaces<BR>
	<BLOCKQUOTE>8.2.1	Qualified Names<BR>
	8.2.2	Using Declarations<BR>
	8.2.3	Using Directives<BR>
	8.2.4	Multiple Interfaces<BR>
	<BLOCKQUOTE>8.2.4.1	Interface Design Alternatives</BLOCKQUOTE>
	8.2.5	Avoiding Name Clashes<BR>
	<BLOCKQUOTE>8.2.5.1	Unnamed Namespaces</BLOCKQUOTE>
	8.2.6	Name Lookup<BR>
	8.2.7	Namespace Aliases<BR>
	8.2.8	Namespace Composition<BR>
	<BLOCKQUOTE>8.2.8.1	Selection<BR>
	8.2.8.2	Composition and Selection</BLOCKQUOTE>
	8.2.9	Namespaces and Old Code<BR>
	<BLOCKQUOTE>8.2.9.1	Namespaces and C<BR>
	8.2.9.2	Namespaces and Overloading<BR>
	8.2.9.3	Namespaces Are Open</BLOCKQUOTE></BLOCKQUOTE>
	8.3	Exceptions<BR>
	<BLOCKQUOTE>8.3.1	Throw and Catch<BR>
	8.3.2	Discrimination of Exceptions<BR>
	8.3.3	Exceptions in the Calculator<BR>
	<BLOCKQUOTE>8.3.3.1	Alternative Error-Handling Strategies</BLOCKQUOTE></BLOCKQUOTE>
	8.4	Advice<BR>
	8.5	Exercises</BLOCKQUOTE>

	9  Source Files and Programs<BR>
	<BLOCKQUOTE>9.1	Separate Compilation<BR>
	9.2	Linkage<BR>
	<BLOCKQUOTE>9.2.1	Header Files<BR>
	9.2.2	Standard Library Headers<BR>
	9.2.3	The One-Definition Rule<BR>
	9.2.4	Linkage to Non-C++ Code<BR>
	9.2.5	Linkage and Pointers to Functions</BLOCKQUOTE>
	9.3	Using Header Files<BR>
	<BLOCKQUOTE>9.3.1	Single Header File<BR>
	9.3.2	Multiple Header Files<BR>
	<BLOCKQUOTE>9.3.2.1	Other Calculator Modules<BR>
	9.3.2.2	Use of Headers</BLOCKQUOTE>
	9.3.3	Include Guards</BLOCKQUOTE>
	9.4	Programs<BR>
	<BLOCKQUOTE>9.4.1	Initialization of Nonlocal Variables<BR>
	<BLOCKQUOTE>9.4.1.1	Program Termination</BLOCKQUOTE></BLOCKQUOTE>
	9.5	Advice<BR>
	9.6	Exercises</BLOCKQUOTE>

</BLOCKQUOTE>

<P>

</P>
<B>Part II:   Abstraction Mechanisms ... pg 221</B>



	<BLOCKQUOTE>10  Classes<BR>
	<BLOCKQUOTE>10.1	Introduction<BR>
	10.2	Classes<BR>
	<BLOCKQUOTE>10.2.1	Member Functions<BR>
	10.2.2	Access Control<BR>
	10.2.3	Constructors<BR>
	10.2.4	Static Members<BR>
	10.2.5	Copying Class Objects<BR>
	10.2.6	Constant Member Functions<BR>
	10.2.7	Self-Reference<BR>
	<BLOCKQUOTE>10.2.7.1	Physical and Logical Constness<BR>
	10.2.7.2	Mutable</BLOCKQUOTE>
	10.2.8	Structures and Classes<BR>
	10.2.9	In-Class Function Definitions</BLOCKQUOTE>
	10.3	Efficient User-Defined Types<BR>
	<BLOCKQUOTE>10.3.1	Member Functions<BR>
	10.3.2	Helper Functions<BR>
	10.3.3	Overloaded Operators<BR>
	10.3.4	The Significance of Concrete Classes</BLOCKQUOTE>
	10.4	Objects<BR>
	<BLOCKQUOTE>10.4.1	Destructors<BR>
	10.4.2	Default Constructors<BR>
	10.4.3	Construction and Destruction<BR>
	10.4.4	Local Variables<BR>
	<BLOCKQUOTE>10.4.4.1	Copying Objects</BLOCKQUOTE>
	10.4.5	Free Store<BR>
	10.4.6	Class Objects as Members<BR>
	<BLOCKQUOTE>10.4.6.1	Necessary Member Initialization<BR>
	10.4.6.2	Member Constants<BR>
	10.4.6.3	Copying Members</BLOCKQUOTE>
	10.4.7	Arrays<BR>
	10.4.8		Local Static Store<BR>
	10.4.9	Nonlocal Store<BR>
	<BLOCKQUOTE>10.4.10	Temporary Objects<BR>
	10.4.11	Placement of Objects<BR>
	10.4.12	Unions</BLOCKQUOTE></BLOCKQUOTE>
	10.5	Advice<BR>
	10.6	Exercises</BLOCKQUOTE>

	11  Operator Overloading<BR>
	<BLOCKQUOTE>11.1	Introduction<BR>
	11.2	Operator Functions<BR>
	<BLOCKQUOTE>11.2.1	Binary and Unary Operators<BR>
	11.2.2	Predefined Meanings for Operators<BR>
	11.2.3	Operators and User-Defined Types<BR>
	11.2.4	Operators in Namespaces</BLOCKQUOTE>
	11.3	A Complex Number Type<BR>
	<BLOCKQUOTE>11.3.1	Member and Nonmember Operators<BR>
	11.3.2	Mixed-Mode Arithmetic<BR>
	11.3.3	Initialization<BR>
	11.3.4	Copying<BR>
	11.3.5	Constructors and Conversions<BR>
	11.3.6	Literals<BR>
	11.3.7	Additional Member Functions<BR>
	11.3.8	Helper Functions</BLOCKQUOTE>
	11.4	Conversion Operators<BR>
	<BLOCKQUOTE>11.4.1	Ambiguities</BLOCKQUOTE>
	11.5	Friends<BR>
	<BLOCKQUOTE>11.5.1	Finding Friends<BR>
	11.5.2	Friends and Members</BLOCKQUOTE>
	11.6	Large Objects<BR>
	11.7	Essential Operators<BR>
	<BLOCKQUOTE>11.7.1	Explicit Constructors</BLOCKQUOTE>
	11.8	Subscripting<BR>
	11.9	Function Call<BR>
	11.10	Dereferencing<BR>
	11.11	Increment and Decrement<BR>
	11.12	A String Class<BR>
	11.13	Advice<BR>
	11.14	Exercises</BLOCKQUOTE>

	12  Derived Classes<BR>
	<BLOCKQUOTE>12.1	Introduction<BR>
	12.2	Derived Classes<BR>
	<BLOCKQUOTE>12.2.1	Member Functions<BR>
	12.2.2	Constructors and Destructors<BR>
	12.2.3	Copying<BR>
	12.2.4	Class Hierarchies<BR>
	12.2.5	Type Fields<BR>
	12.2.6	Virtual Functions</BLOCKQUOTE>
	12.3	Abstract Classes<BR>
	12.4	Design of Class Hierarchies<BR>
	<BLOCKQUOTE>12.4.1	A Traditional Class Hierarchy<BR>
	<BLOCKQUOTE>12.4.1.1	Critique</BLOCKQUOTE>
	12.4.2	Abstract Classes<BR>
	12.4.3	Alternative Implementations<BR>
	<BLOCKQUOTE>12.4.3.1	Critique</BLOCKQUOTE>
	12.4.4	Localizing Object Creation</BLOCKQUOTE>
	12.5	Class Hierarchies and Abstract Classes<BR>
	12.6	Advice<BR>
	12.7	Exercises</BLOCKQUOTE>

	13  Templates<BR>
	<BLOCKQUOTE>13.1	Introduction<BR>
	13.2	A Simple String Template<BR>
	<BLOCKQUOTE>13.2.1	Defining a Template<BR>
	13.2.2	Template Instantiation<BR>
	13.2.3	Template Parameters<BR>
	13.2.4	Type Equivalence<BR>
	13.2.5	Type Checking</BLOCKQUOTE>
	13.3	Function Templates<BR>
	<BLOCKQUOTE>13.3.1	Function Template Arguments<BR>
	13.3.2	Function Template Overloading</BLOCKQUOTE>
	13.4	Using Template Arguments to Specify Policy<BR>
	<BLOCKQUOTE>13.4.1	Default Template Parameters</BLOCKQUOTE>
	13.5	Specialization<BR>
	<BLOCKQUOTE>13.5.1	Order of Specializations<BR>
	13.5.2	Template Function Specialization</BLOCKQUOTE>
	13.6	Derivation and Templates<BR>
	<BLOCKQUOTE>13.6.1	Parameterization and Inheritance<BR>
	13.6.2	Member Templates<BR>
	13.6.3	Inheritance Relationships<BR>
	<BLOCKQUOTE>13.6.3.1	Template Conversions</BLOCKQUOTE></BLOCKQUOTE>
	13.7	Source Code Organization<BR>
	13.8	Advice<BR>
	13.9	Exercises</BLOCKQUOTE>

	14  Exception Handling<BR>
	<BLOCKQUOTE>14.1	Error Handling<BR>
	<BLOCKQUOTE>14.1.1	Alternative Views on Exceptions</BLOCKQUOTE>
	14.2	Grouping of Exceptions<BR>
	<BLOCKQUOTE>14.2.1	Derived Exceptions<BR>
	14.2.2	Composite Exceptions</BLOCKQUOTE>
	14.3	Catching Exceptions<BR>
	<BLOCKQUOTE>14.3.1	Re-Throw<BR>
	14.3.2	Catch Every Exception<BR>
	<BLOCKQUOTE>14.3.2.1	Order of Handlers</BLOCKQUOTE></BLOCKQUOTE>
	14.4	Resource Management<BR>
	<BLOCKQUOTE>14.4.1	Using Constructors and Destructors<BR>
	14.4.2	Auto_ptr<BR>
	14.4.3	Caveat<BR>
	14.4.4	Exceptions and New<BR>
	14.4.5	Resource Exhaustion<BR>
	14.4.6	Exceptions in Constructors<BR>
	<BLOCKQUOTE>14.4.6.1	Exceptions and Member Initialization<BR>
	14.4.6.1	Exceptions and Copying</BLOCKQUOTE>
	14.4.7	Exceptions in Destructors</BLOCKQUOTE>
	14.5	Exceptions That Are Not Errors<BR>
	14.6	Exception Specifications<BR>
	<BLOCKQUOTE>14.6.1	Checking Exception Specifications<BR>
	14.6.2	Unexpected Exceptions<BR>
	14.6.3	Mapping Exceptions<BR>
	<BLOCKQUOTE>14.6.3.1	User Mapping of Exceptions<BR>
	14.6.3.2	Recovering the Type of an Exception</BLOCKQUOTE></BLOCKQUOTE>
	14.7	Uncaught Exceptions<BR>
	14.8	Exceptions and Efficiency<BR>
	14.9	Error-Handling Alternatives<BR>
	14.10	Standard Exceptions<BR>
	14.11	Advice<BR>
	14.12	Exercises</BLOCKQUOTE>

	15 Class Hierarchies
	<BLOCKQUOTE>15.1	Introduction and Overview<BR>
	15.2	Multiple Inheritance<BR>
	<BLOCKQUOTE>15.2.1		Ambiguity Resolution<BR>
	15.2.2	Inheritance and Using-Declarations<BR>
	15.2.3	Replicated Base Classes<BR>
	<BLOCKQUOTE>15.2.3.1	Overriding</BLOCKQUOTE>
	15.2.4	Virtual Base Classes<BR>
	<BLOCKQUOTE>15.2.4.1	Programming Virtual Bases</BLOCKQUOTE>
	15.2.5	Using Multiple Inheritance<BR>
	<BLOCKQUOTE>15.2.5.1	Overriding Virtual Base Functions</BLOCKQUOTE></BLOCKQUOTE>
	15.3	Access Control<BR>
	<BLOCKQUOTE>15.3.1	Protected Members<BR>
	<BLOCKQUOTE>15.3.1.1	Use of Protected Members</BLOCKQUOTE>
	15.3.2	Access to Base Classes<BR>
	<BLOCKQUOTE>15.3.2.1	Multiple Inheritance and Access Control<BR>
	15.3.2.2	Using-Declarations and Access Control</BLOCKQUOTE></BLOCKQUOTE>
	15.4	Run-Time Type Information<BR>
	<BLOCKQUOTE>15.4.1	Dynamic_cast<BR>
	<BLOCKQUOTE>15.4.1.1	Dynamic_cast of References</BLOCKQUOTE>
	15.4.2	Navigating Class Hierarchies<BR>
	<BLOCKQUOTE>15.4.2.1	Static and Dynamic Casts</BLOCKQUOTE>
	15.4.3	Class Object Construction and Destruction<BR>
	15.4.4	Typeid and Extended Type Information<BR>
	<BLOCKQUOTE>15.4.4.1	Extended Type Information</BLOCKQUOTE>
	15.4.5	Uses and Misuses of RTTI</BLOCKQUOTE>
	15.5	Pointers to Members<BR>
	<BLOCKQUOTE>15.5.1	Base and Derived Classes</BLOCKQUOTE>
	15.6	Free Store<BR>
	<BLOCKQUOTE>15.6.1	Array Allocation<BR>
	15.6.2	``Virtual Constructors''</BLOCKQUOTE>
	15.7	Advice<BR>
	15.8	Exercises</BLOCKQUOTE>

</BLOCKQUOTE>


<P>

</P>
<B>Part III:   The Standard Library ... pg 427
</B>
	<BLOCKQUOTE>16  Library Organization and Containers<BR>
	16.1	Standard Library Design<BR>
	<BLOCKQUOTE>16.1.1	Design Constraints<BR>
	16.1.2	Standard Library Organization<BR>
	16.1.3	Language Support</BLOCKQUOTE>
	16.2	Container Design<BR>
	<BLOCKQUOTE>16.2.1	Specialized Containers and Iterators<BR>
	16.2.2	Based Containers<BR>
	16.2.3	STL Containers</BLOCKQUOTE>
	16.3	Vector<BR>
	<BLOCKQUOTE>16.3.1	Types<BR>
	16.3.2	Iterators<BR>
	16.3.3	Element Access<BR>
	16.3.4	Constructors<BR>
	16.3.5	Stack Operations<BR>
	16.3.6	List Operations<BR>
	16.3.7	Addressing Elements<BR>
	16.3.8	Size and Capacity<BR>
	16.3.9	Other Member Functions<BR>
	16.3.10	Helper Functions<BR>
	16.3.11	Vector<bool></BLOCKQUOTE>
	16.4	Advice<BR>
	16.5	Exercises</BLOCKQUOTE>

	17  Standard Containers<BR>
	<BLOCKQUOTE>17.1	Standard Containers<BR>
	<BLOCKQUOTE>17.1.1	Operations Summary<BR>
	17.1.2	Container Summary<BR>
	17.1.3	Representation<BR>
	17.1.4	Element Requirements<BR>
	<BLOCKQUOTE>17.1.4.1	Comparisons<BR>
	17.1.4.2	Other Relational Operators</BLOCKQUOTE></BLOCKQUOTE>
	17.2	Sequences<BR>
	<BLOCKQUOTE>17.2.1	Vector<BR>
	17.2.2	List<BR>
	<BLOCKQUOTE>17.2.2.1	Splice, Sort, and Merge<BR>
	17.2.2.2	Front Operations<BR>
	17.2.2.3	Other Operations</BLOCKQUOTE>
	17.2.3	Deque</BLOCKQUOTE>
	17.3	Sequence Adapters<BR>
	<BLOCKQUOTE>17.3.1	Stack<BR>
	17.3.2	Queue<BR>
	17.3.3	Priority Queue</BLOCKQUOTE>
	17.4	Associative Containers<BR>
	<BLOCKQUOTE>17.4.1	Map<BR>
	<BLOCKQUOTE>17.4.1.1	Types<BR>
	17.4.1.2	Iterators and Pairs<BR>
	17.4.1.3	Subscripting<BR>
	17.4.1.4	Constructors<BR>
	17.4.1.5	Comparisons<BR>
	17.4.1.6	Map Operations<BR>
	17.4.1.7	List Operations<BR>
	17.4.1.8	Other Functions</BLOCKQUOTE>
	17.4.2	Multimap<BR>
	17.4.3	Set<BR>
	17.4.4	Multiset</BLOCKQUOTE>
	17.5	Almost Containers<BR>
	<BLOCKQUOTE>17.5.1	String<BR>
	17.5.2	Valarray<BR>
	17.5.3	Bitset<BR>
	<BLOCKQUOTE>17.5.3.1	Constructors<BR>
	17.5.3.2	Bit Manipulation Operations<BR>
	17.5.3.3	Other Operations</BLOCKQUOTE>
	17.5.4	Built-In Arrays</BLOCKQUOTE>
	17.6	Defining a New Container<BR>
	<BLOCKQUOTE>17.6.1	Hash_map<BR>
	17.6.2	Representation and Construction<BR>
	<BLOCKQUOTE>17.6.2.1	Lookup<BR>
	17.6.2.2	Erase and Resize<BR>
	17.6.2.3	Hashing</BLOCKQUOTE>
	17.6.3	Other Hashed Associative Containers</BLOCKQUOTE>
	17.7	Advice<BR>
	17.8	Exercises</BLOCKQUOTE>


	18  Algorithms and Function Objects<BR>
	<BLOCKQUOTE>18.1	Introduction<BR>
	18.2	Overview of Standard Library Algorithms<BR>
	18.3	Sequences and Containers<BR>
	<BLOCKQUOTE>18.3.1	Input Sequences</BLOCKQUOTE>
	18.4	Function Objects<BR>
	<BLOCKQUOTE>18.4.1	Function Object Bases<BR>
	18.4.2	Predicates<BR>
	<BLOCKQUOTE>18.4.2.1	Overview of Predicates</BLOCKQUOTE>
	18.4.3	Arithmetic Function Objects<BR>
	18.4.4	Binders, Adapters, and Negaters<BR>
	<BLOCKQUOTE>18.4.4.1	Binders<BR>
	18.4.4.2	Member Function Adapters<BR>
	18.4.4.3	Pointer to Function Adapters<BR>
	18.4.4.4	Negaters</BLOCKQUOTE></BLOCKQUOTE>
	18.5	Nonmodifying Sequence Algorithms<BR>
	<BLOCKQUOTE>18.5.1	For_each<BR>
	18.5.2	The Find Family<BR>
	18.5.3	Count<BR>
	18.5.4	Equal and Mismatch<BR>
	18.5.5	Search</BLOCKQUOTE>
	18.6	Modifying Sequence Algorithms<BR>
	<BLOCKQUOTE>18.6.1	Copy<BR>
	18.6.2	Transform<BR>
	18.6.3	Unique<BR>
	<BLOCKQUOTE>18.6.3.1	Sorting Criteria</BLOCKQUOTE>
	18.6.4	Replace<BR>
	18.6.5	Remove<BR>
	18.6.6	Fill and Generate<BR>
	18.6.7	Reverse and Rotate<BR>
	18.6.8	Swap</BLOCKQUOTE>
	18.7	Sorted Sequences<BR>
	<BLOCKQUOTE>18.7.1	Sorting<BR>
	18.7.2	Binary Search<BR>
	18.7.3	Merge<BR>
	18.7.4	Partitions<BR>
	18.7.5	Set Operations on Sequences</BLOCKQUOTE>
	18.8	Heaps<BR>
	18.9	Min and Max<BR>
	18.10	Permutations<BR>
	18.11	C-Style Algorithms<BR>
	18.12	Advice<BR>
	18.13	Exercises</BLOCKQUOTE>

	19  Iterators and Allocators<BR>
	<BLOCKQUOTE>19.1	Introduction<BR>
	19.2	Iterators and Sequences<BR>
	<BLOCKQUOTE>19.2.1	Iterator Operations<BR>
	19.2.2	Iterator Traits<BR>
	19.2.3	Iterator Categories<BR>
	19.2.4	Inserters<BR>
	19.2.5	Reverse Iterators<BR>
	19.2.6	Stream Iterators<BR>
	<BLOCKQUOTE>19.2.6.1	Stream Buffers</BLOCKQUOTE></BLOCKQUOTE>
	19.3	Checked Iterators<BR>
	<BLOCKQUOTE>19.3.1	Exceptions, Containers, and Algorithms</BLOCKQUOTE>
	19.4	Allocators<BR>
	<BLOCKQUOTE>19.4.1	The Standard Allocator</BLOCKQUOTE>
	19.4.2	A User-Defined Allocator<BR>
	19.4.3	Generalized Allocators<BR>
	19.4.4	Uninitialized Memory<BR>
	19.4.5	Dynamic Memory<BR>
	19.4.6	C-Style Allocation</BLOCKQUOTE>
	19.5	Advice<BR>
	19.6	Exercises</BLOCKQUOTE>

	20  Strings<BR>
	<BLOCKQUOTE>20.1	Introduction<BR>
	20.2	Characters<BR>
	<BLOCKQUOTE>20.2.1	Character Traits</BLOCKQUOTE>
	20.3	Basic_string<BR>
	<BLOCKQUOTE>20.3.1	Types<BR>
	20.3.2	Iterators<BR>
	20.3.3	Element Access<BR>
	20.3.4	Constructors<BR>
	20.3.5	Errors<BR>
	20.3.6	Assignment<BR>
	20.3.7	Conversion to C-Style Strings<BR>
	20.3.8	Comparisons<BR>
	20.3.9	Insert<BR>
	20.3.10	Concatenation<BR>
	20.3.11	Find<BR>
	20.3.12	Replace<BR>
	20.3.13	Substrings<BR>
	20.3.14	Size and Capacity<BR>
	20.3.15	I/O Operations<BR>
	20.3.16	Swap</BLOCKQUOTE>
	20.4	The C Standard Library<BR>
	<BLOCKQUOTE>20.4.1	C-Style Strings<BR>
	20.4.2	Character Classification</BLOCKQUOTE>
	20.5	Advice<BR>
	20.6	Exercises</BLOCKQUOTE>

	21  Streams<BR>
	<BLOCKQUOTE>21.1	Introduction<BR>
	21.2	Output  <BR>     
	<BLOCKQUOTE>21.2.1	Output Streams<BR>
	21.2.2	Output of Built-In Types<BR>
	21.2.3	Output of User-Defined Types<BR>
	<BLOCKQUOTE>21.2.3.1	Virtual Output Functions</BLOCKQUOTE></BLOCKQUOTE>
	21.3	Input          <BR>
	<BLOCKQUOTE>21.3.1	Input Streams<BR>
	21.3.2	Input of Built-In Types<BR>
	21.3.3	Stream State<BR>
	21.3.4	Input of Characters<BR>
	21.3.5	Input of User-Defined Types<BR>
	21.3.6	Exceptions<BR>
	21.3.7	Tying of Streams<BR>
	21.3.8	Sentries</BLOCKQUOTE>
	21.4	Formatting<BR>
	<BLOCKQUOTE>21.4.1	Format State<BR>
	<BLOCKQUOTE>21.4.1.1	Copying Format State</BLOCKQUOTE>
	21.4.2	Integer Output<BR>
	21.4.3	Floating-Point Output<BR>
	21.4.4	Output Fields<BR>
	21.4.5	Field Adjustment<BR>
	21.4.6	Manipulators<BR>
	<BLOCKQUOTE>21.4.6.1	Manipulators Taking Arguments<BR>
	21.4.6.2	Standard I/O Manipulators<BR>
	21.4.6.3	User-Defined Manipulators</BLOCKQUOTE></BLOCKQUOTE>
	21.5	File Streams and String Streams<BR>
	<BLOCKQUOTE>21.5.1	File Streams<BR>
	21.5.2	Closing of Streams<BR>
	21.5.3	String Streams</BLOCKQUOTE>
	21.6	Buffering<BR>
	<BLOCKQUOTE>21.6.1	Output Streams and Buffers<BR>
	21.6.2	Input Streams and Buffers<BR>
	21.6.3	Streams and Buffers<BR>
	21.6.4	Stream Buffers</BLOCKQUOTE>
	21.7	Locale<BR>
	<BLOCKQUOTE>21.7.1	Stream Callbacks</BLOCKQUOTE>
	21.8	C Input/Output<BR>
	21.9	Advice<BR>
	21.10	Exercises</BLOCKQUOTE>

	22  Numerics</BLOCKQUOTE>
	<BLOCKQUOTE>22.1	Introduction<BR>
	22.2	Numeric Limits<BR>
	<BLOCKQUOTE>22.2.1	Limit Macros</BLOCKQUOTE>
	22.3	Standard Mathematical Functions<BR>
	22.4	Vector Arithmetic<BR>
	<BLOCKQUOTE>22.4.1	Valarray Construction<BR>
	22.4.2	Valarray Subscripting and Assignment<BR>
	22.4.3	Member Operations<BR>
	22.4.4	Nonmember Operations<BR>
	22.4.5	Slices<BR>
	22.4.6	Slice_array<BR>
	22.4.7	Temporaries, Copying, and Loops<BR>
	22.4.8	Generalized Slices<BR>
	22.4.9	Masks<BR>
	22.4.10	Indirect Arrays</BLOCKQUOTE>
	22.5	Complex Arithmetic<BR>
	22.6	Generalized Numeric Algorithms<BR>
	<BLOCKQUOTE>22.6.1	Accumulate<BR>
	22.6.2	Inner_product<BR>
	22.6.3	Incremental Change</BLOCKQUOTE>
	22.7	Random Numbers<BR>
	22.8	Advice<BR>
	22.9	Exercises</BLOCKQUOTE>

<P>

</P>
<B>Part IV:  Design Using C++ ... pg 689</B>

	<BLOCKQUOTE>23  Development and Design<BR>
	<BLOCKQUOTE>23.1	Overview<BR>
	23.2	Introduction<BR>
	23.3	Aims and Means<BR>
	23.4	The Development Process<BR>
	<BLOCKQUOTE>23.4.1	The Development Cycle</BLOCKQUOTE>
	23.4.2	Design Aims<BR>
	23.4.3	Design Steps<BR>
	<BLOCKQUOTE>23.4.3.1	Step 1: Find Classes<BR>
	23.4.3.2	Step 2: Specify Operations<BR>
	23.4.3.3	Step 3: Specify Dependencies<BR>
	23.4.3.4	Step 4: Specify Interfaces<BR>
	23.4.3.5	Reorganization of Class Hierarchies<BR>
	23.4.3.6	Use of Models</BLOCKQUOTE>
	23.4.4	Experimentation and Analysis<BR>
	23.4.5	Testing<BR>
	23.4.6	Software Maintenance<BR>
	23.4.7	Efficiency</BLOCKQUOTE>
	23.5	Management<BR>
	<BLOCKQUOTE>23.5.1	Reuse<BR>
	23.5.2	Scale<BR>
	23.5.3	Individuals<BR>
	23.5.4	Hybrid Design</BLOCKQUOTE>
	23.6	Annotated Bibliography<BR>
	23.7	Advice</BLOCKQUOTE>

	24  Design and Programming<BR>
	<BLOCKQUOTE>24.1	Overview<BR>
	24.2	Design and Programming Language<BR>
	<BLOCKQUOTE>24.2.1	Ignoring Classes<BR>
	24.2.2	Avoiding Inheritance<BR>
	24.2.3	Ignoring Static Type Checking<BR>
	24.2.4	Avoiding Programming<BR>
	24.2.5	Using Class Hierarchies Exclusively</BLOCKQUOTE>
	24.3	Classes<BR>
	<BLOCKQUOTE>24.3.1	What Do Classes Represent?<BR>
	24.3.2	Class Hierarchies<BR>
	<BLOCKQUOTE>24.3.2.1	Dependencies within a Class Hierarchy</BLOCKQUOTE>
	24.3.3	Containment Relationships<BR>
	24.3.4	Containment and Inheritance<BR>
	<BLOCKQUOTE>24.3.4.1	Member/Hierarchy Tradeoffs<BR>
	24.3.4.2	Containment/Hierarchy Tradeoffs</BLOCKQUOTE>
	24.3.5	Use Relationships<BR>
	24.3.6	Programmed-In Relationships<BR>
	24.3.7	Relationships within a Class<BR>
	<BLOCKQUOTE>24.3.7.1	Invariants<BR>
	24.3.7.2	Assertions<BR>
	24.3.7.3	Preconditions and Postconditions<BR>
	24.3.7.4	Encapsulation</BLOCKQUOTE></BLOCKQUOTE>
	24.4	Components<BR>
	<BLOCKQUOTE>24.4.1	Templates<BR>
	24.4.2	Interfaces and Implementations<BR>
	24.4.3	Fat Interfaces</BLOCKQUOTE>
	24.5	Advice</BLOCKQUOTE>

	25  Roles of Classes<BR>
	<BLOCKQUOTE>25.1	Kinds of Classes<BR>
	25.2	Concrete Types<BR>
	<BLOCKQUOTE>25.2.1	Reuse of Concrete Types</BLOCKQUOTE>
	25.3	Abstract Types<BR>
	25.4	Node Classes<BR>
	<BLOCKQUOTE>25.4.1	Changing Interfaces</BLOCKQUOTE>
	25.5	Actions<BR>
	25.6	Interface Classes<BR>
	<BLOCKQUOTE>25.6.1	Adjusting Interfaces</BLOCKQUOTE>
	25.7	Handle Classes<BR>
	<BLOCKQUOTE>25.7.1	Operations in Handles</BLOCKQUOTE>
	25.8	Application Frameworks<BR>
	25.9	Advice<BR>
	25.10	Exercises     </BLOCKQUOTE>

		</BLOCKQUOTE>
		<P>

</P>
<B>Appendices:</B>
	<BLOCKQUOTE>A  The C++ Grammar ... pg 793<BR>
	<BLOCKQUOTE>A.1	Introduction<BR>
	A.2	Keywords<BR>
	A.3	Lexical Conventions<BR>
	A.4	Programs<BR>
	A.5	Expressions<BR>
	A.6	Statements<BR>
	 A.7	Declarations<BR>
	<BLOCKQUOTE>A.7.1	Declarators</BLOCKQUOTE>
	A.8	Classes<BR>
	<BLOCKQUOTE>A.8.1	Derived Classes</BLOCKQUOTE>
	A.8.2	Special Member Functions<BR>
	A.8.3	Overloading<BR>
	A.9	Templates<BR>
	A.10	Exception Handling<BR>
	A.11	Preprocessing Directives</BLOCKQUOTE>

	<A HREF="3rd_compat.pdf">B  Compatibility</A>
	<BLOCKQUOTE>B.1	Introduction<BR>
	B.2	C/C++ Compatibility<BR>
	<BLOCKQUOTE>B.2.1	``Silent'' Differences<BR>
	B.2.2	C Code That Is Not C++<BR>
	B.2.3	Deprecated Features<BR>
	B.2.4	C++ Code That Is Not C</BLOCKQUOTE>
	B.3	Coping with Older C++ Implementations<BR>
	<BLOCKQUOTE>B.3.1	Headers<BR>
	B.3.2	The Standard Library<BR>
	B.3.3	Namespaces<BR>
	B.3.4	Allocation Errors<BR>
	B.3.5	Templates<BR>
	B.3.6	For-Statement Initializers</BLOCKQUOTE></BLOCKQUOTE>

	C  Technicalities
	<BLOCKQUOTE>C.1	Introduction and Overview<BR>
	C.2	The Standard<BR>
	C.3	Character Sets<BR>
	<BLOCKQUOTE>C.3.1	Restricted Character Sets<BR>
	C.3.2	Escape Characters<BR>
	C.3.3	Large Character Sets<BR>
	C.3.4	Signed and Unsigned Characters</BLOCKQUOTE>
	C.4	Types of Integer Literals<BR>
	C.5	Constant Expressions<BR>
	C.6	Implicit Type Conversion<BR>
	<BLOCKQUOTE>C.6.1	Promotions<BR>
	C.6.2	Conversions<BR>
	<BLOCKQUOTE>C.6.2.1	Integral Conversions<BR>
	C.6.2.2	Floating-Point Conversions<BR>
	C.6.2.3	Pointer and Reference Conversions<BR>
	C.6.2.4	Pointer-to-Member Conversions<BR>
	C.6.2.5	Boolean Conversions<BR>
	C.6.2.6	Floating-Integral Conversions</BLOCKQUOTE>
	C.6.3	Usual Arithmetic Conversions</BLOCKQUOTE>
	C.7	Multidimensional Arrays<BR>
	<BLOCKQUOTE>C.7.1	Vectors<BR>
	C.7.2	Arrays<BR>
	C.7.3	Passing Multidimensional Arrays</BLOCKQUOTE>
	C.8	Saving Space<BR>
	<BLOCKQUOTE>C.8.1	Fields<BR>
	C.8.2	Unions<BR>
	C.8.3	Unions and Classes</BLOCKQUOTE>
	C.9	Memory Management<BR>
	<BLOCKQUOTE>C.9.1	Automatic Garbage Collection<BR>
	<BLOCKQUOTE>C.9.1.1	Disguised Pointers<BR>
	C.9.1.2	Delete<BR>
	C.9.1.3	Destructors<BR>
	C.9.1.4	Memory Fragmentation</BLOCKQUOTE></BLOCKQUOTE>
	C.10	Namespaces<BR>
	<BLOCKQUOTE>C.10.1	Convenience vs. Safety<BR>
	C.10.2	Nesting of Namespaces<BR>
	C.10.3	Namespaces and Classes</BLOCKQUOTE>
	C.11	Access Control<BR>
	<BLOCKQUOTE>C.11.1	Access to Members<BR>
	C.11.2	Access to Base Classes<BR>
	C.11.3	Access to Member Class<BR>
	C.11.4	Friendship</BLOCKQUOTE>
	C.12	Pointers to Data Members<BR>
	C.13	Templates<BR>
	<BLOCKQUOTE>C.13.1	Static Members<BR>
	C.13.2	Friends<BR>
	C.13.3	Templates as Template Parameters<BR>
	C.13.4	Typename and Template<BR>
	C.13.6	Template as a Qualifier<BR>
	C.13.7	Instantiation<BR>
	C.13.8	Name Binding<BR>
	<BLOCKQUOTE>C.13.8.1	Dependent Names<BR>
	C.13.8.2	Point of Definition Binding<BR>
	C.13.8.3	Point of Instantiation Binding<BR>
	C.13.8.4	Templates and Namespaces</BLOCKQUOTE>
	C.13.9	When Is a Specialization Needed?<BR>
	<BLOCKQUOTE>C.13.9.1	Template Function Instantiation</BLOCKQUOTE>
	C.13.10	Explicit Instantiation</BLOCKQUOTE>
	C.14	Advice</BLOCKQUOTE>


	<A HREF="3rd_loc.pdf">D  Locales</A>
	<BLOCKQUOTE>
	D.1	Handling Cultural Differences<BR>
	<BLOCKQUOTE>D.1.1	Programming Cultural Differences<BR></BLOCKQUOTE>
	D.2	The locale Class<BR>
	<BLOCKQUOTE>D.2.1	Named Locales<BR>
	<BLOCKQUOTE>D.2.1.1	Constructing New Locales<BR>
	D.2.2	Copying and Comparing Locales<BR>
	D.2.3	The global() and the classic() Locales<BR>
	D.2.4	Comparing Strings<BR></BLOCKQUOTE></BLOCKQUOTE>
	D.3	Facets<BR>
	<BLOCKQUOTE>D.3.1	Accessing Facets in a Locale<BR>
	D.3.2	A Simple User-Defined Facet<BR>
	D.3.3	Uses of Locales and Facets<BR></BLOCKQUOTE>
	D.4	Standard Facets<BR>
	<BLOCKQUOTE>D.4.1	String Comparison<BR>
	<BLOCKQUOTE>D.4.1.1	Named Collate<BR></BLOCKQUOTE>
	D.4.2	Numeric Input and Output<BR>
	<BLOCKQUOTE>D.4.2.1	Numeric Punctuation<BR>
	D.4.2.2	Numeric Output<BR>
	D.4.2.3	Numeric Input<BR></BLOCKQUOTE>
	D.4.3	Input and Output of Monetary Values<BR>
	<BLOCKQUOTE>D.4.3.1	Money Punctuation<BR>
	D.4.3.2	Money Output<BR>
	D.4.3.3	Money Input<BR></BLOCKQUOTE>
	D.4.4	Date and Time Input and Output<BR>
	<BLOCKQUOTE>D.4.4.1	Clocks and Timers<BR>
	D.4.4.2	A Date Class<BR>
	D.4.4.3	Date and Time Output<BR>
	D.4.4.4	Date and Time Input<BR>
	D.4.4.5	A More Flexible Date Class<BR>
	D.4.4.6	Specifying a Date Format<BR>
	D.4.4.7	A Date Input Facet<BR></BLOCKQUOTE>
	D.4.5	Character Classification<BR>
	<BLOCKQUOTE>D.4.5.1	Convenience Interfaces<BR></BLOCKQUOTE>
	D.4.6	Character Code Conversion<BR>
	D.4.7	Messages<BR>
	<BLOCKQUOTE>D.4.7.1	Using Messages from Other Facets<BR></BLOCKQUOTE></BLOCKQUOTE>
	D.5	Advice<BR>
	D.6	Exercises<BR></BLOCKQUOTE>


	<A HREF="3rd_safe.pdf">E  Standard-Library Exception Safety</A>
	<BLOCKQUOTE>
	E.1	Introduction<BR>
	E.2	Exception Safety<BR>
	E.3	Exception-Safe Implementation Techniques<BR>
	<BLOCKQUOTE>E.3.1	A Simple Vector<BR>
	E.3.2	Representing Memory Explicitly<BR>
	E.3.3	Assignment<BR>
	E.3.4	push_back()<BR>
	E.3.5	Constructors and Invariants<BR>
	<BLOCKQUOTE>E.3.5.1	Using init() Functions<BR>
	E.3.5.2	Relying on a Default Valid State<BR>
	E.3.5.3	Delaying resource acquisition<BR></BLOCKQUOTE></BLOCKQUOTE>
	E.4	Standard Container Guarantees<BR>
	<BLOCKQUOTE>E.4.1	Insertion and Removal of Elements<BR>
	E.4.2	Guarantees and Tradeoffs<BR>
	E.4.3	Swap<BR>
	E.4.4	Initialization and Iterators<BR>
	E.4.5	References to Elements<BR>
	E.4.6	Predicates<BR></BLOCKQUOTE>
	E.5	The Rest of the Standard Library<BR>
	<BLOCKQUOTE>E.5.1	Strings<BR>
	E.5.2	Streams<BR>
	E.5.3	Algorithms<BR>
	E.5.4	Valarray and Complex<BR>
	E.5.5	The C Standard Library<BR></BLOCKQUOTE>
	E.6	Implications for Library Users<BR>
	E.7	Advice<BR>
	E.8	Exercises</BLOCKQUOTE>

</BLOCKQUOTE>


<B>Index ... pg 969</B>
</BODY>
</HTML>


